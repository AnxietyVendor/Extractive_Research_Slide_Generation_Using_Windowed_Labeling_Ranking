Building expressive encrypted databases that can scale to large volumes of data while enjoying formal security guarantees has been one of the holy grails of security and cryptography research.
Searchable Encryption (SE) is considered to be an attractive implementation choice for this goal: It naturally supports basic database queries such as point, join, group-by and range, and is very practical at the expense of well-defined leakage such as search and access pattern.
Nevertheless , recent attacks have exploited these leakages to recover the plaintext database or the posed queries, casting doubt to the usefulness of SE in encrypted systems.
Defenses against such leakage-abuse attacks typically require the use of Oblivious RAM or worst-case padding-such countermeasures are however quite impractical.
In order to efficiently defend against leakage-abuse attacks on SE-based systems, we propose SEAL, a family of new SE schemes with adjustable leakage.
In SEAL, the amount of privacy loss is expressed in leaked bits of search or access pattern and can be defined at setup.
As our experiments show, when protecting only a few bits of leakage (e.g., three to four bits of access pattern), enough for existing and even new more aggressive attacks to fail, SEAL query execution time is within the realm of practical for real-world applications (a little over one order of magnitude slowdown compared to traditional SE-based en-crypted databases).
Thus, SEAL could comprise a promising approach to build efficient and robust encrypted databases.
Encrypted databases enable a data owner to outsource a database to a server in a private manner, so that the server can still answer database queries on the underlying encrypted data.
Initially implemented with weak primitives like order-preserving (OPE) and deterministic (DET) encryption (e.g., [5,6,43,48]) 1 , encrypted databases have now moved to more "secure" implementations through other primitives like searchable or structured encryption (SE) [12], offering support for a plethora of queries such as point queries [17,18], range queries [15,16,20], and SQL queries [30] (e.g., join and group-by queries).
SE-based encrypted databases are quite practical at the expense of well-defined leakage.
This leakage information includes the search pattern (whether a query q has been made in the past or not) and the access pattern that consists of the volume pattern (number of database tuples contained in the query result) and the overlapping pattern (which database tuples, if any, in the result for query q appeared in the result of a previous query).
Leakage-abuse attacks.
Unfortunately the aforementioned leakages exposed by SE can be quite harmful, enabling the recovery of the encrypted database or/and the posed queries.
In particular, the works of Islam et al. [28] and Cash et al. [11] were the first to exploit access pattern leakage and prior knowledge about the dataset to recover the queried keywords.
Zhang et al. [51] propose file injection attacks for encrypted email applications to improve the recovery rate of queried keywords.
Blackstone et al. [7] revisit various assumptions of existing leakage-abuse attacks.
For private range search, effective access pattern and volumetric attacks through which the attacker learns the plaintext order and value of encrypted records, without any prior knowledge, have been proposed [13,24,25,27,32,[34][35][36]39].
This growing body of leakage-abuse attacks has already alerted the community about using SE for implementing encrypted databases [1].
Current defenses.
To provably defend against leakage-abuse attacks on SE-based systems one has to (i) use expensive cryptographic tools to eliminate the search/overlapping patterns, i.e., Oblivious RAM (ORAM) [46] (introducing a polylogarithmic search overhead) and (ii) perform worst-case padding (resulting in worst-case linear search time [29] or quadratic index size) for eliminating the volume pattern.
Both approaches above incur large overheads leading to quite impractical protocols.
We present other, more practical, but less effective defenses in our prior work section.Our contributions.
In light of the above, we ask in this paper whether practical SE primitives can still somehow be used to implement secure encrypted databases.
Towards this goal, we propose SEAL 2 , a family of new SE schemes with adjustable leakage which allow the client to define a trade-off between efficiency and leaked information.
We show that hiding only a few bits of the search/overlapping/volume pattern significantly reduces the success of existing as well new, even more aggressive, leakage-abuse attacks.
At the same time SEAL's practical performance is close to traditional SE.
In particular our contributions are as follows:1.
To better motivate SEAL, we first present new attacks on existing SE-based encrypted databases.
In particular, we show that the same inference attacks on DET systems [41] can be used by a persistent adversary to recover the database values in SE-based systems, such as those implementing point queries (e.g., [15,17]), and group-by and join queries (e.g., [30]).
The high-level reason is that after the adversary observes a certain number of SE queries in these constructions, tuples with the same values are revealed and therefore frequency information is readily available to the adversary.
Even for more robust SE-based range query schemes [15,20], we present new attacks that can work under certain assumptions about the dataset (see Section 3).2.
We present SEAL(α, x), a family of SE schemes with adjustable leakage.
SEAL is based on two other "adjustable" primitives, an adjustable ORAM, parameterized by a value α and an adjustable padding algorithm, parameterized by a value x.
The adjustable ORAM, ADJ-ORAM-α, hides only α bits of the access pattern by partitioning the accessed N-sized array into N/2 α regions of 2 α size each and by applying an individual standard ORAM per region.
The adjustable padding algorithm, ADJ-PADDING-x, reduces the volume pattern leakage by padding every list to the the closest power of x, leading to a dataset with at most log x N distinct sizes.
Clearly, larger values for α and x yield slower but more secure SEAL (see Section 4).3.
We use SEAL to build encrypted databases with adjustable leakage.
We first present three new construction POINT-ADJ-SE-(α, x) (for point queries), JOIN-ADJ-SE-(α, x) (for join queries) and RANGE-ADJ-SE-(α, x) (for range queries) that use SEAL(α, x) as black box, instead of plain SE.
Finally, we present a more efficient adjustable construction for ranges, RANGE-SRC-SE, that reduces access pattern leakage and volume pattern leakage implicitly by modifying an existing constructions [15] and not by using our (more expensive) SEAL (α, x).
(see Sections 4.4 and 4.5).4.
We evaluate the robustness of our SEAL-based encrypted databases for various values α and x against particularly powerful adversaries that observe the leaked search/overlapping and volume patterns and have plaintext access to the entire input dataset.
Such strong threat model offers additional credibility to our proposed mitigation techniques.
We consider two new attacks.
The first is a query recovery attack that aims at decrypting the encrypted queries posed by the client.
The second is a database recovery attack that aims at mapping plaintext values (for the queried attribute) to the tuples of the encrypted database.
Note that since SEAL hides some bits of access pattern via ADJ-ORAM, database recovery can be quite challenging (see Section 5).5.
We observe that for all above attacks we can find certain values for α and x that reduce the attacker's success rate significantly while maintaining good performance.
For instance we show that if we use SEAL to hide three bits of access pattern while at the same time pad the keyword lists to powers of 4 (thus hiding a few bits of volume pattern as well), we can defend against our powerful attackers only at the expense of an acceptable slowdown from plain SE-around 32×.
3Prior work.
Wagh et al. [49] introduces an ORAM with a tunable trade-off between the search/storage efficiency and security.
This trade-off is controlled by an (ε, δ)-differential privacy modification of PathORAM [46].
Their construction could potentially be used as a drop-in replacement in our proposed encrypted database algorithms (instead of our adjustable ORAM).
It would be interesting to explore how different choices of ε and δ affect the performance of existing leakage-abuse attacks-we leave this as future work.
The works of Cash et al. [11], and Bost and Fouque [9] propose padding techniques for keyword search that can hide a portion of the volume pattern.
Unlike our proposed padding in Section 4.2, their padding depends on the distribution of the input dataset, which results in leakage even prior to query execution.
Similar padding approaches have been also proposed in other areas, e.g., [37] proposes padding approaches for preventing snapshot attacks on deterministically encrypted data and [38] proposes padding for traffic analysis attacks.
Bost and Fouque [9] also propose new security definitions for SE aiming at capturing existing leakage abuse attacks.These theoretical definitions could potentially provide some intuition on how we can modify existing schemes in order to make them robust against such attacks.Recently, Kamara et al. [31] showed how to suppress the search pattern leakage without using ORAM.
However suppressing only the search pattern leakage is not enough for mitigating leakage-abuse attacks.
Kamara and Moataz [29] showed theoretically how to perform worst-case padding without requiring quadratic index size, while sometimes assuming certain properties for the input dataset, such as a Zipf distribution or highly-concentrated multimaps.
We now provide some notation, definitions and background that we use throughout the paper.
We write out ← Alg(in) to indicate the output of an algorithm Alg and (client out , server out ) ↔ Prot(client in , server in ) to indicate the execution of a protocol Prot between a client and a server.Negligible function.
A function ν: N → R is negligible in λ, denoted by negl(λ), if for every positive polynomial p(·) and all sufficiently large λ, ν(λ) < 1/p(λ).
Oblivious RAM (ORAM).
Oblivious RAM (ORAM), introduced in [22], is a compiler that encodes the memory such that accesses on the compiled memory do not reveal access patterns on the original memory.
An ORAM scheme consists of two algorithms/protocols ORAM = (ORAMINITIALIZE, ORAMACCESS), where ORAMINITIALIZE initializes the memory, and ORAMACCESS performs the oblivious accesses.
We provide the formal definition in Section 4.3.
Oblivious dictionary (ODICT).
An oblivious dictionary is an oblivious data structure that can support oblivious queries from an arbitrary domain.
ODICT offers the following protocols (see [50] for a detailed description):• (T, σ) ← ODICTSETUP(1 λ , N): Given a security parameter λ, and an upper bound N on the number of elements, it creates an oblivious data structure T .
The client sends T to the server and maintains locally the state σ.
• ((value, σ ), T ) ↔ ODICTSEARCH((key, σ), T ): Given the search key key and σ, returns the corresponding value value, the updated T and σ .
• (σ , T ) ↔ ODICTINSERT((key, value, σ), T ): Given a key-value pair key, value and σ, it inserts this entry in the dictionary.
It returns the updated T and σ .
Searchable encryption (SE).
Let D be a collection of documents.
Each document D ∈ D is assigned a unique document identifier and contains a set of keywords from a dictionary ∆.
Let D(w) denote the identifiers of documents containing keyword w. SE schemes build an encrypted index I on the document identifiers which can be queried using keyword "tokens".
Note that we do not store encrypted documents in the index, just their identifiers.
Encrypted documents can be retrieved in an extra round.
We denote with N the data collection size, i.e., N = ∑ w∈∆ |D(w)|.
An SE protocol involves two parties, a client and a server and consists of the following algorithms/protocols [12]:• (st C , I ) ← SETUP(1 λ , D):is a probabilistic algorithm performed by the client prior to sending any data to the server.
It receives the security parameter as input and the data collection D, and outputs an encrypted index I which is sent to the server.
st C is sent to the client and it contains the secret key k.• ((X , st C ), I ) ↔ SEARCH((st C , w), I ): is a protocol executed between the client and the server.
The client inserts the secret state st C and a keyword w, while the server inserts an encrypted index I .
At the end of the protocol the client learns X , the set of all document identifiers D(w)corresponding to keyword w and the updated secret state st C , while the server's output is the updated index I .
The security of the above SE scheme is captured by the following definition, using the standard SE's real/ideal security game [12] (see Figure 1).
Definition 1 Suppose (KEYGEN, SETUP, SEARCH) is a SE scheme based on the above definition, let λ ∈ N be the security parameter and consider experiments Real(λ) and Figure 1, where L 1 and L 2 are leakage functions.
SE is (L 1 , L 2 )-secure if for all polynomialsize adversaries A there exist polynomial-time simulators SIMSETUP and SIMSEARCH, such that for all polynomialtime algorithms DIST:Ideal L 1 ,L 2 (λ) presented in| Pr[DIST(v, st A ) = 1 : (v, st A ) ← Real(λ)]− Pr[DIST(v, st A ) = 1 : (v, st A ) ← Ideal L 1 ,L 2 (λ)]| ≤ negl(λ)where probabilities are taken over the coins of KeyGen and Setup algorithms.The above definition captures strong adversarial capabilities, i.e., even adaptive adversaries that can select their new queries based on previous ones cannot learn anything more than the specified leakage functions L 1 , L 2 [12].
Next, we discuss these leakage functions in more detail.Leakage functions.
Leakage L 1 is associated with information that is leaked from the index alone (before any queries have been executed) and typically contains the size of the data collection N. Leakage L 2 represents the information leaked during a query.
It typically consists of the search pattern that indicates whether the client searches for a particular w, and the access pattern that contains the document identifiers matching the queried keyword w, namely L 2 (D, w) = (id(w), D(w)).
In the above, id : ∆ → {0, 1} λ is a mapping of keywords to λ-bit numbers.
We refer to id(w) as the alias of w. InReal(λ) 1: (D, st A ) ← A(1 λ ) 2: (st C , I 0 ) ←Setup(1 λ , D) 3: for 1 ≤ i ≤ q do 4: (w i , st A ) ← A(st A , I i−1 , M 1 , . . . , M i−1 )* 5: (X i , st C , I i ) ↔Search(st C , w i , I i−1 ) 6: Let M = M 1 . . . M q , I = I 0 . . . I q , X = X 0 . . . X q 7: return v = (I , M, X ), st A Ideal L SETUP ,L QUERY (λ) 1: (D, st A ) ← A(1 λ ) 2: (st S , I 0 ) ←SimSetup(L SETUP (D)) 3: for 1 ≤ i ≤ q do 4: (w i , st A ) ← A(st A , I i−1 , M 1 , . . . , M i−1 )* 5: (X i , st S , I i ) ↔ SimSearch(st S , L QUERY (D, w i ), I i−1 ) 6: Let M = M 1 . . . M q , I = I 0 . . . I q and X = X 0 . . . X q 7: return v = (I , M, X ), st A* Let M k be the messages from client to server in the Search/SimSearch protocols.
practice, this will be a random allocation of keywords to aliases that is used to capture the search pattern leakage.
That is, while id(w) does not directly reveal w, when querying for the same keyword repeatedly the server observes the same id(w).
Recall that D(w) contains the document identifiers 4 matching the queried keyword w and this captures the access pattern leakage.
More specifically, the access pattern consists of (i) the size of the result which we call volume pattern, and (ii) the document overlaps between previously queried keywords, which we call overlapping pattern.For certain database query types, such as point queries, L 2 leakage contains only the search and volume pattern leakage.
The reason is that there is a structural difference between the keyword search problem and database point queries.
In keyword search, one document identifier can be included in multiple keywords, while in database search one tuple-id or an encrypted tuple can have exactly one searchable value per attribute.
For example, a patient cannot have more than one date of birth.
Using this observation, we can store in the encrypted index directly the encrypted tuples instead of the tuple-ids without increasing asymptotically the storage.SE through ORAM.
One way to reduce the SE query leakage would be to replace all the memory accesses performed with oblivious memory accesses using an ORAM as a black box.
In that case, the only leaked information during queries is the result size.Attacks on deterministically-encrypted systems.
[41] pro- 4 We assume that the order of the documents does not reveal any significant information.
This can be achieved by assigning a random λ-bit number to each document.
posed the frequency analysis and p -optimization attacks that apply to databases encrypted with the use of deterministic schemes such as CryptDB [43].
The frequency analysis attack is the most basic and wellknown inference attack in the area of cryptography.
We define C k and M k to be the ciphertext and message spaces, respectively of the deterministic encryption scheme.
Given a deterministically encrypted column c over C k and an auxiliary dataset z over M k , the attack works by assigning the i-th most frequent element of c to the i-th most frequent element of z.The p -optimization attack is a family of attacks against deterministic encryption.
The main goal is to find an assignment from ciphertexts to plaintexts that minimizes a given cost function, e.g., the p distance between the histograms of the dataset.
This attack minimizes the total mismatch identified in frequencies across all plaintext and ciphertext pairs.
In this section we first show how SE can be used to support various queries on encrypted databases, such as point/groupby/join/range queries and then show various attacks (some existing and some new) on these constructions.
Our findings systematically re-establish that using SE to implement encrypted databases [15,20,30] is particularly risky when the adversary is persistent and also has access to prior information about the underlying encrypted database (e.g., distribution of first names/gender).
For snapshot adversaries that have no prior information about the encrypted database, there could be value in SE-based systems, however these are assumptions that are unlikely to hold in the real world [26,41].
The most basic database query is the point query for a value v.A point query retrieves all the tuples from table T that contain value v in attribute x, i.e.,SELECT * FROM T WHERE T .
x = v;We can use an SE scheme to implement private point queries (e.g., see Demertzis et al. [15], and Kamara and Moataz [30]) by viewing attribute values as keywords, and database tuples as document identifiers.
In this case an SE-based point query will return the encrypted tuples that match this value.
We call this scheme POINT-SE.
Note that POINT-SE can also be used to implement group-by queries (e.g., see Kamara and Moataz [30]), where a client can compute the group-by query through point queries for all distinct values of attribute x.Attacks on POINT-SE.
When using POINT-SE, the attacker can identify which encrypted tuples have the same value v, after he observes the execution of a query.
Finally, after he observes the execution of all queries, the attacker can group the encrypted database tuples by value, and can therefore compute the size of each group.
By running a frequency analysis attack or an p -optimization attack (described in Section 2), it is easy to map plaintext values to encrypted tuples.
Note that the above attack requires the attacker to see all queries.
However, in the case of group-by queries, the very nature of the query reveals all possible point queries, resulting in total leakage exposure with just a single query.
To conclude, observing all possible results from point queries (either one by one or via a group-by query) turns an SE-implemented database into a deterministically-encrypted database, making it vulnerable to simple attacks.
A fundamental query type for relational databases is the join query.
A simple join of two tables T and R on attribute x returns all pairs of tuples from T and R that agree on x, i.e.,SELECT * FROM T , R WHERE T .
x = R .
x;A simple approach that allows us to support private join queries using SE is the following: We encrypt T with a semantically-secure encryption scheme and R with POINT-SE for private point queries on attribute x.
Then we stream all the tuples of T to the client.
Then the client decrypts each tuple t in T and queries the SE index for R (on attribute x) to retrieve the matching tuples of R .
Clearly this approach has high bandwidth since it requires streaming a large number of tuples to the client.
We call this scheme JOIN-SE.
To address the above bandwidth issue, Kamara and Moataz [30] propose a construction that, in the case of two tables T and R , precomputes the answers to join queries on each possible attribute x.
Then they store with SE a mapping from "keyword" x to the precomputed answer (i.e., pairs of pointers to tuples from T and R that have the same value on attribute x).
This approach requires both significant amount of storage and setup time.
We call this scheme JOIN-SE-PRECOMPUTE.
Attacks on JOIN-SE, JOIN-SE-PRECOMPUTE.
It is easy to see that JOIN-SE and JOIN-SE-PRECOMPUTE leak the encrypted join graph.
That is, for each encrypted tuple t of T , the respective encrypted tuples t of R that have the same value on x with t are leaked (if such tuples exist).
We propose a simple attack that recovers the values of the encrypted tuples: Assuming we have access to (part of) the plaintext dataset, we can compute the plaintext join graph by connecting with an edge tuples from T and tuples from R that have the same plaintext value on attribute x.
If all tuples in T and R have at least one incident edge the attacker can perform the frequency analysis attack on both T and R and recover the plaintext values for the encrypted values of attribute x.
In this case JOIN-SE and JOIN-SE-PRECOMPUTE provide exactly the same security properties for joins as more efficient encrypted systems based on deterministic encryption (e.g., CryptDB [43]).
Otherwise the attack can be performed only on the leaked frequencies and JOIN-SE and JOIN-SE-PRECOMPUTE have potentially less leakage than systems based on deterministic encryption.
In the case of range queries, we want to retrieve all tuples from table T that contain value v ∈ [l, u] in attribute x, i.e.,SELECT * FROM T WHERE T .
x ≥ l and T .
x ≤ u;One way to support private range queries is to treat each numeric value of attribute x as a keyword and use SE.
Then, private range queries can be supported by transforming the range [l, u] to series of private point queries, i.e., searching for the individual values l, l + 1, . . . , u − 1, u.
We call this scheme RANGE-SE.
Many attacks that exploit the overlapping and volume patterns exist against RANGE-SE-see [13,25,32,35,36,39].
In general, these attacks first compute an ordering of the encrypted tuples and then retrieve the actual values after observing a certain number of queries.To address this leakage, Faber et al. [20] and Demertzis et al. [15,16] have proposed new private range constructions that use SE and are response-hiding, in that they do not leak overlaps between different range queries.
Their main idea, called LOGARITHMIC-SRC in [15], builds a binary-tree data structure with some extra "internal" nodes (see Fig- ure 2) on top of the database.
Each leaf corresponds to a value k ∈ {0, 1, . . . , M − 1} (where M is the size of the domain of attribute x) and stores all tuples that have value k at attribute x (i.e., a leaf can store more than one tuples).
Data stored in a leaf is also copied to its parents.
To answer a range search query, we select the root of the smallest subtree fully covering the query.
The above data structure defines a natural key-value relationship, where each tree node is a key with the value being its respective database tuples.
This allows us to query the data structure privately using SE.LOGARITHMIC-SRC yields up to O(N) false positives where N is the size of the database table.
For example, if the range [3,5] is being queried in Figure 2 and there is a single tuple in the range but the rest of the dataset has value 2, node N 2,5 will be returned and therefore the response will be the entire dataset.
LOGARITHMIC-SRC-I, proposed for this problem [15], maintains two LOGARITHMIC-SRC-type binary trees, one on the domain {0, . . . , M − 1} that stores constant-size metadata in the leaves (let us call this tree T 1 ) and one on the domain {0, . . . , N − 1} that stores the actual database tuples in the leaves (one per leaf) sorted by the search attribute (let us call this tree T 2 ).
In particular, for every value of the domain i ∈ {0, . . . , M − 1}, T 1 stores the subrange of {0, . . . , N − 1} that corresponds to database tuples with value i in T 2 .
Therefore, a range query [a, b] is transformed into two queries: One range query [a, b] in T 1 that returns information that allows one to reconstruct the range [a , b ] in T 2 that returns those tuples.
This approach brings down the worst-case query cost from O(N) to O(R + r), where R is the size of the queried range (and is due to querying T 1 ) and r is the size of the result (and is due to querying T 2 ).
Do existing attacks apply?
It seems that existing (volumetric) attacks on RANGE-SE [13,24,25,27,32,[34][35][36]39] do not apply to the above, response-hiding, schemes.
However we must note that LOGARITHMIC-SRC and LOGARITHMIC-SRC-I leak the volume pattern of a restricted set of queries and may be vulnerable to new volumetric attacks.
In particular, the very recent and concurrent work of Gui et al. [27] proposed new volumetric attacks that can handle cases of missing/spurious queries, and cases that return noisy results.
These attacks for missing and noisy queries could potentially be used against LOGARITHMIC-SRC by setting a small window size and treating all volumes from large windows as noise.
However, it is not clear how this noise would affect the attack output since the missing queries are not chosen at random as is assumed in [27].
Below, we describe our new attacks tailored to LOGARITHMIC-SRC that could be extended also for LOGARITHMIC-SRC-I.
New attacks on LOGARITHMIC-SRC.
The main idea is that if the attacker observes the volumes of all queries, then she could potentially reconstruct the tree and map encrypted database tuples to plaintext values.
For simplicity, let us focus on a LOGARITHMIC-SRC tree with Dom = {0, 1, 2, 3} (and therefore 8 nodes, including the one "extra" internal node-see Figure 2).
Assume the adversary observes the following sizes of results (he actually sees the respective encrypted tuples as well): 20, 1, 26, 18, 8, 5, 7 and 13.
His goal is to map these sizes (and the respective encrypted tuples) to the nodes N 0 , N 1 , N 2 , N 3 , N 01 , N 12 , N 23 and N 03 of the tree.
The tuples that map to leaf i will therefore have value i!
To do the mapping the adversary exploits the fact that the size of a parent is equal to the sum of the sizes of its children and therefore sets up 4 linear equations with 8 unknowns |N 0 |, |N 1 |, |N 2 |, |N 3 |, |N 01 |, |N 12 |, |N 23 | and |N 03 |.
Of course these equations have an infinite number of solutions but the one we are interested in is a permutation of the observed sizes 20, 1, 26, 18, 8, 5, 7 and 13.
In our example, due the fact that all pairwise sums are different, there is a unique assignment (up to a mirror arrangement), in particular the assignment |N 0 | = 1, |N 1 | = 7, |N 2 | = 13, |N 3 | = 5, |N 01 | = 8, N 12 = 20, N 23 = 18 and N 03 = 26.
We note here that the described attack would not work in the case where pairwise-sums are not unique (e.g., when all leaves have size 1) but other information could be potentially used in that case.
To conclude, this simple attack shows that concealing the overlapping pattern (as LOGARITHMIC-SRC is doing) is not enough for fully defending against range attacks.N 1 N 0 N 2 N 3 N 4 N 5 N 6 N 7 N 0,1 N 2,3 N 4,5 N 6,7 N 0,3 N 4,7 N 0,7 N 1,2 N 3,4 N 5Generalization of attack to LOGARITHMIC-SRC-i.
Recall that in LOGARITHMIC-SRC-I we maintain two LOGARITHMIC-SRC-type trees: one for the metadata (T 1 ) and one for the actual data (T 2 ).
Every leaf in T 1 has size at most one since a specific domain value may not be present at all in the database.
Thus the above attack that exploits distinct sizes of leaves might not work very well.However there are still ways to launch an attack.
Coming back to Figure 2, consider the tree T 1 on the domain {0, 1, 2, 3}, with the difference that all leaf nodes have size either zero or one.
Suppose after all queries have been issued on T 1 the adversary observes only three nodes of size one (and all other nodes have size zero).
Looking into this information carefully, one can tell that these nodes have to be either N 0 , N 0,1 and N 0,3 or N 3 , N 2,3 and N 0,3 which implies that all database tuples have the same value and this value is either 0 or 3.
Note that at that point, it will be easy to recover the topology of T 2 since for each range query one node of T 1 and one for T 2 will be accessed together.The above attacks are not analyzed in full detail since we want to use them mainly as a way to manifest the weaknesses of the Logarithmic-SRC and Logarithmic-SRC-i schemes [15].
We also use them as a motivation to introduce our new RANGE-SRC-SE-(a, x) scheme (see Section 4.5).
Exploring these attacks against Logarithmic-SRC and Logarithmic-SRC-i in more detail is left as future work.
Most of the attacks on SE-based encrypted databases that were presented in section 3 exploit the leakage of SE such as the search, overlapping and volume pattern.
In this section we propose SEAL, a family of new SE schemes with adjustable leakage with the hope that these can be used to implement more secure (yet efficient) encrypted databases that withstand leakage-abuse attacks.
Our main building blocks are an adjustable ORAM, an ORAM that allows one to define the bits of leakage of the index being accessed in a tunable manner, as well a an adjustable padding algorithm that adds noise to the actual size of the list being accessed.bit ← Real ADJ-ORAM-α (λ):1: M 0 ← Adv(1 λ ).
2: (σ 0 , EM 0 ) ↔ ADJ-ORAMINITIALIZE((1 λ , M 0 , α), ⊥).3: for k = 1 to q do q: polynomial #queries 4: With m 0 , m 1 , . . . , we denote the messages exchanged at Line 5 of both experiments.i k ← Adv(1 κ , EM 0 , m 1 , m 2 , . . . , m k−1 ).
5: ((v i k , σ k ), EM k ) ↔ ADJ-ORAMACCESS((op, i k , v i k , σ k−1 ), EM k−1 ).
6: return bit ← Adv(1 k , EM 0 , m 1 , m 2 , . . . , m q ).
bit ← Ideal ADJ-ORAM-α L α 1 ,L α 2 (λ): 1: M 0 ← Adv(1 λ ).
2: (st S , EM 0 ) ← ADJ-SIMORAMINITIALIZE(1 λ , L α 1 ).
3: for k = 1 to q do 4: i k ← Adv(1 κ , EM 0 , m 1 , m 2 , . . . , m k−1 ).
5: (st S , EM k ) ↔ ADJ-SIMORAMACCESS( st S , EM k−1 , L α 2 (i k )).
6: return bit ← Adv(1 k , EM 0 , m 1 , m 2 , . . . , m q ).
An adjustable ORAM (ADJ-ORAM-α) is parameterized by a parameter α that defines the number of leaked bits of the accessed memory location (α = 0 for a traditional ORAM).
We define the ADJ-ORAMINITIALIZE and ADJ-ORAMACCESS protocols of our ADJ-ORAM-α scheme:• (σ, EM) ↔ ADJ-ORAMINITIALIZE((1 λ , M, α), ⊥),takes as input a security parameter λ, a memory array M of n values (without loss of generality lets assume n is a power of 2) (1, v 1 ), . . . , (n, v n ), a parameter α ∈ {0, 1, . . . , log n} and outputs secret state σ (for client), and encrypted memory EM (for server).
•((v i , σ), EM) ↔ ADJ-ORAMACCESS((op, i, v i , σ, α), EM)is a protocol between the client and the server, where the client's input is the type of operation op (read/write), an index i and the value v i -for op = read client sets v i = ⊥.
Server's input is the encrypted memory EM.
Client's output consists of the updated secret state σ and the value v i assigned to the i-th value of M if op = read (for op = write the returned value is ⊥).
Server's output is the updated encrypted memory EM.Next, we define the security of ADJ-ORAM-α in the real/ideal game of Figure 3 parametrized by leakage functionsL α 1 , L α 2 .
Definition 2 ADJ-ORAM-α is (L α 1 , L α 2 )-secure if for any PPT adversary Adv, there ex- ists a PPT simulator containing algorithms (σ, EM) ↔ ADJ-ORAMINITIALIZE((1 λ , M, α), ⊥)1: Let M be in the form (1, v 1 ), . . . , (n, v n ) and µ = 2 α .
2: Sample a secret key k ← $ {0, 1} λ .
3: Let π k be a PRP: {0, 1} λ × {0, 1} log 2 n → {0, 1} log 2 n .
4: Create S 1 , . . . , S µ empty arrays of size n µ .
5: for i = 1, . . . , n do 6:Let be the integer representation of the α most significant bits of π k [i] and φ be the integer representation of the remaining bits of π k [i].
S +1 [φ + 1] = v i .
8: for i = 1, . . . , µ do 9: (σ i , EM i ) ↔ ORAMINITIALIZE((1 λ , S i ), ⊥).10: Let EM to be EM 1 , . . . , EM µ and σ to (σ 1 , . . . , σ µ ).
11: return (σ, EM).
(ADJ-SIMORAMINITIALIZE, ADJ-SIMORAMACCESS):((v i , σ), EM) ↔ ADJ-ORAMACCESS((op, i, v i , σ, α), EM)= φ + 1.
4: ((v i , σ ), EM ) ↔ ORAMACCESS((op, φ, v i , σ ), EM ).
5: return (v i , σ, EM).
| Pr[Real ADJ-ORAM-α (λ) = 1]−Pr[Ideal ADJ-ORAM-α L α 1 ,L α 2 (λ) = 1]|is at most neg(λ), where the above experiments are defined in Figure 3 and where the randomness is taken over the random bits used by the algorithms of the ADJ-ORAM-α scheme, the algorithms of the simulator and Adv.The leakages L α 1 , L α 2 are defined in a manner similar tothose of SE, i.e., L α 1 (M) = (n, α) and L α 2 (i) = id α (i),where id α (i) returns the α most significant bits of a random log n-bit alias assigned to tuple (i, v i ).
Intuitively, if two queries for index i are made on an ADJ-ORAM-α, the adversary should only figure out that the α most significant bits of the queried index are the same-but nothing else.Construction of ADJ-ORAM-α.
The main idea behind our approach is that the memory array will not be stored in one ORAM, but it will be partitioned into multiple disjoint subsets, each of which will then be stored in a separate smaller ORAM.
We use as a black box any secure ORAM= (ORAMINITIALIZE, ORAMACCESS) to store each subset.
Our construction works by building 2 α different ORAMs ORAM 1 ,. . . ,ORAM 2 α , each of which will store a part of M of size n/2 α .
One possible way to partition M into these ORAMs would be to deterministically assign (i, v i ) based on their location in M, i.e., the first 2 α entries will be stored in ORAM 1 , the next 2 α entries will be stored in ORAM 2 and so on.
However, this might reveal sensitive information for certain application settings, e.g., if the server knows that M stores v i in a sorted manner, then accessing ORAM 1 reveals that one of the smallest values in M was accessed.
Hence, before performing the partitioning, we randomly permute M using a PRP P over [1, n] (implemented with a small-domain PRP [23,40,45]), for which the key k is chosen and stored by the client.
Let π k be the corresponding mapping after k has been chosen.
Then, the partitioning of M is performed using the integer representation of the α most significant bits of the permuted index and the remaining bits of π k (i) correspond to the index π k (i) of tuple (i, v i ) inside the small ORAM.
Our construction is given in Figure 4.
Theorem 1 Assuming (ORAMINITIALIZE, ORAMACCESS) is a secure ORAM and π k is a secure PRP, then ADJ-ORAM- α presented above is (L α 1 , L α 2 )-secure, according to Def.
2.
The ORAM scheme used is secure and therefore we use its algorithms SIMORAMINITIALIZE and SIMORAMACCESS.
In particular, the ADJ-SIMORAMINITIALIZE takes as an input L α 1 = (n, α) and the security parameter λ, and it creates EM 1 , . . . EM µ and σ 1 , . . . , σ µ using SIMORAMINITIALIZE(1 λ , n µ ) for µ = n 2 α .
The ADJ-SIMORAMACCESS takes as an input id α (i), from L 2 leakage, which determines in which encrypted memory EM i must be accessed, and performs a random access using SIMORAMACCESS(σ i , EM i ).
Then, the simulator properly updates EM i and σ i .
Performance and leakage of ADJ-ORAM-α.
The higher the value of α is, the more efficient ADJ-ORAM is (ORAM is applied on a smaller parts of the array) and the larger the leakage becomes (more accesses will be made on the same small parts of the array).
Concretely, if we assume that the ORAM used as a building block has T (n) access overhead (e.g., T (n) = O(log n) for the most efficient ORAM [42]), then ADJ-ORAM-α has an improved T (n/2 α ) overhead.
In Section 4.3 we discuss how ADJ-ORAM-α can be instantiated using [46] and oblivious data structures [50] and we provide a more concrete performance analysis.
In this section we propose adjustable padding, another primitive that will help us build more secure SE schemes.
Recall that existing SE schemes leak the query result size, i.e., |D(w)|.
Find the smallest i: x i−1 < |D(w)| ≤ x i .
Pad D(w) with x i − |D(w)| dummy values.
5: Pad D with dummy records so that the total size is x · N. 6: return the padded dataset.
(worst-case padding).
However, this would introduce a prohibitive storage/search overhead.
To avoid this overhead, one could pad to the closest power of two, forcing the adversary to observe at most log N + 1 sizes-leaking log log N + 1 bits, at most doubling the search and storage overhead.Our proposal is a generalization of the above idea.
Our padding can be parameterized by a value x that defines the number of different sizes (which are exactly log x N + 1) that the adversary can observe.
Our padding algorithm works as follows (see Figure 5).
Given a keyword list D(w) of size, we find the integer i such that x i−1 < |D(w)| ≤ x i .
Then we pad the list D(w) with x i − |D(w)| dummy entries.
Note that this padding strategy can increase the space and search overhead by a factor of x and yields leakage of log log x N + 1 bits!
In other words the larger x is, the less efficient the scheme becomes and the less leakage the adversary observes.
We note here that for simulation purposes, after all lists are padded, our algorithm pads the dataset to a total of x · N entries so that to avoid leaking any information about the dataset.We note here that padding techniques have been used before for concealing the size of the accessed result (e.g., see Cash et al. [11] and Bost and Fouque [9], as well as Lacharite et al. [37] and Liberatore et al. [38]).
However, these approaches depend on the distribution of the input dataset, which leads to more leakage, even prior to query execution.
Instead our padding algorithm is distribution-agnostic and can thus be simulated only by knowing the size of the dataset N and the padding parameter x.
We now present SEAL(α, x), our adjustable SE construction that uses ADJ-ORAM-α, ADJ-PADDING-x and an oblivious dictionary ODICT described in Section 2 as a black boxes.
We recall that parameter α is defined in the range [0, log N] and that for α = 0 all the search/overlapping pattern bits are protected, and for α = log N all bits are leaked.
Also for larger x values, less volume pattern bits are leaked-e.g., for value x = N no volume pattern bits are leaked.Construction of SEAL(α, x).
SEAL(α, x) is defined similarly with SE (see Section 2) and has algorithms/protocols Setup and Search.
Our construction is described in Figure 6.
(st C , I ) ← SETUP(1 λ , D)1: Let D be the input dataset and let W be the set of keywords in D.2: D ← ADJ-PADDING(x, D).
Parameter x is public.3: Let M be an array of N entries storing (w, id) pairs of D in lexicographic order and i w be the index of w's first occurrence in M. 4: (T, σ odict ) ← ODICTSETUP(1 λ , N).
5: for all w ∈ W do 6:Let cnt w = |D(w)|.
(σ odict , T ) ↔ ODICTINSERT((w, i w ||cnt w , σ odict ), T ).8: (σ oram , EM) ← ADJ-ORAMINITIALIZE(1 λ , M, α).
Parameter α is public.9: st C = (σ oram , σ odict ) and I = (EM, T ).10: return (st C , I ).
((X , st C ), I ) ↔ SEARCH((st C , w), I )1: Parse I as (EM, T ) and st C as (σ odict , σ oram ) and let X be empty.
((v i , σ oram ), EM) ↔ ADJ-ORAMACCESS((read, i, ⊥, σ oram , α), EM).
Parameter α is public.6: X ← X ∪ v i .
7: return (X , st C , I ).
x are considered public and we do not provide them as input explicitly.
First, it uses ADJ-PADDING(x, D) in order to transform D to a new dataset with at most log x N + 1 distinct results sizes (see Line 2 of setup).
Then, it sorts all the (w, id) pairs in lexicographical order (see Line 3 of setup) and places them sequentially in a memory array M which is then given as input to the ADJ-ORAMINITIALIZE algorithm (see Line 8 of setup).
The sorting guarantees that all (w, id) for the same keyword w will be placed in consecutive memory locations.
All entries for w can then be retrieved if one knows the index of the first appearance of w and the size of the padded list |D(w)|.
For every keyword w, this information is stored in an oblivious dictionary T (see Line 7 of setup).
SEAL's search takes as input the queried keyword w, client's secret state st C and the encrypted index I , which contains the small oblivious memories EM 1 , . . . as well as the oblivious dictionary T .
For a given queried keyword w, the client first performs an access to the oblivious dictionary to retrieve the index of the first appearance of w in M and the padded result size (cnt w ) (see Lines 2-3 of search).
Then, it performs cnt w accesses in the ADJ-ORAM-α in order to retrieve the result X (see Lines 4-7 of search).
Note that, due to padding, X may contain "dummy" records which will be filtered out by the client afterwards.Leakage definition for SEAL(α, x).
SEAL(α, x) is secure according to the standard SE/OSE definition described in Section 2 with the following leakage functionsL α,x 1 (D) = (N, α, x) and L α,x 2 (D, w) = D x α (w) ,where D x α (w) contains the α most significant bits of the aliases of the document identifiers in the padded list D(w) as output by algorithm ADJ-PADDING(x, D).
For the rest of the paper we simply denote these leakages as L 1 and L 2 .
Theorem 2 Assuming that ODICT is a secure oblivious data structure according to [50] (Def.
1) and ADJ-ORAM-α is secure according to Def.
2, then SEAL(α, x) is (L 1 , L 2 )-secure according to Def.
1.ADJ-ORAM-α is secure-our proof uses simulator algorithms ADJ-SIMORAMINITIALIZE and ADJ-SIMORAMACCESS.
The security parameter λ is given.The SimSetup takes as an input L 1 = (N, α, x).
SimSetup initializes (T, σ odict ) ← ODICTSETUP(1 λ , N) and it inserts N random entries of the form (w, i w ||cnt w ) in the oblivious dictionary T using ODICTINSERT.
Then, it computes N = x · N. Finally, it uses ADJ-SIMORAMINITIALIZE(1 λ , N , α) to create the encrypted memory EM and state σ oram .
The SimSearch algorithm takes as an input L 2 and performs one random access in the oblivious dictionary T using ODICTSEARCH, and calls |D x α (w)| times the ADJ-SIMORAMACCESS with input the α-bit identifiers in D x α (w) (D x α (w) has the required leakage for ADJ-SIMORAMACCESS).
Then, the simulator updates EM, T and the states σ odict , and σ oram .
Asymptotic performance.
Let (T (n),C(n), S(n)) be the access complexity, client-space complexity and server-space complexity respectively of the underlying ORAM used and let (t(n), c(n), s(n)) be the access complexity, client-space complexity and server-space complexity respectively of the underlying oblivious dictionary used.
The server space required is always S(x · N) + s(N).
Now, assuming the client keeps, along with the oblivious dictionary state, the ORAM states locally, the search complexity for a keyword w ist(N) + x · |D(w)| · T x · N 2 αand the client space is 2 α ·C(x · N/2 α ) + c(N).
Assuming the client does not keep ORAM states locally and just downloads and re-encrypts to the server, the search complexity for w ist(N) + x · |D(w)| · max T x · N 2 α ,C x · N 2 αand the client space is just c(N).
Whether one chooses to store the local states locally or outsource them depends on the parameter α.
For small values of α it is better to keep them locally, while for larger values of α it might worth outsourcing.
Implementing ADJ-ORAM-α.
We implement each small ORAM in ADJ-ORAM-α with Path-ORAM [46].
Recall that the cost of Path-ORAM for accessing n blocks of size B is B log n for accessing the path and O(log 3 n) for recursively updating the position map.
In our case we apply Path-ORAM on N/2 a blocks of size around 2 log N bits (log N bits for storing keyword w and log N bits for storing the id) and therefore our total cost is O(log N log(N/2 a ) + log 3 (N/2 a )).
Implementing SEAL(α, x).
For SEAL(α, x), apart from ADJ-ORAM-α as described above, we also use an oblivious dictionary ODICT (for storing i w ||cnt w ) implemented with an oblivious AVL tree [50] (this requires b log 2 N additional additive cost where b is the bitsize of i w ||cnt w ).
In case the number of keywords/attributes |W| in small, we choose to keep the dictionary locally-this requires around 3|W| log N bits which in practice is a few megabytes and is a common assumption in Dynamic SE [8,10,21,47].
Our experiments in the next section assume the dictionary is kept locally.
Note that even if we do not keep the dictionary locally, we only require one oblivious access to it per query w.
This is most of the times subsumed by the required |D(w)| ADJ-ORAM-α queries, especially when |D(w)| is large (e.g., Ω(log 2 N)).
In any case we can always reduce the above cost with an adjustable oblivious dictionary at the expense of leaking α bits of the search pattern.
Finally, in case the worst-case overhead of SEAL(α, x) becomes higher than sequential scan (which has no leakage), we perform a sequential scan.
In Section 3 we presented/reviewed three constructions for point and join queries on encrypted databases that use SE as a black box: (i) POINT-SE, a construction for point queries on encrypted data; (ii) JOIN-SE and JOIN-SE-PRECOMPUTE, two constructions for join queries on encrypted data.
Our proposed new constructions reduce the leakage of the above constructions by using SEAL (α, x), instead of simple SE.
By doing this replacement we have the following constructions, for various parameters of α and x,1.
POINT-ADJ-SE, and 2) JOIN-ADJ-SE.
Note that JOIN-ADJ-SE can be instantiated either by using JOIN-SE or JOIN-SE-PRECOMPUTE as basis.
The first adjustable construction that we propose for range queries, RANGE-ADJ-SE-(a, x), is based on the "naive" construction RANGE-SE from Section 3.3, where instead of simple SE we use SEAL(a, x).
Our second construction, RANGE-SRC-SE-(a, x) comprises two modifications of LOGARITHMIC-SRC-I [15] so that the potential attack presented in Section 3.3 is mitigated.
Recall the attack works by exploiting volumes exposed by tree T 1 (the tree T 1 stores metadata required to search tree T 2 ).
Our first modification of LOGARITHMIC-SRC-I is a simple one: Instead of outsourcing tree T 1 using SE, keep tree T 1 locally unencrypted and therefore previously exposed volume information will not be available.
The only downside is the O(|W|) client storage that is required to store T 1 , where W is the set of values of the range attribute.
In practice this storage is minimal, e.g., none of the ranges of the attributes shown in Table 1 of our evaluation exceed 1MB.
(Of course, if strictly necessary, we can outsource tree T 1 to the server via an oblivious dictionary without any leakage, increasing the search time by a polylog factor.)
RANGE-SRC-SE-(α, x).
However, the above modification addresses the leakage only in T 1 .
But T 2 can also leak information.
For example, (a) if the same tree node is accessed twice, there is nonzero probability that the same range is being queried, and (b) the result size (or an upper bound of it) is leaked from accessing T 2 .
To reduce the effect of leakages (a) and (b), one could reduce the number of sizes observed by the adversary by implementing the encrypted index for T 2 using SEAL(α, x) instead of simple SE.Our second modification that yields our final scheme RANGE-SRC-SE-(α, x) does almost that, but it does not use ADJ-PADDING for reducing the volume pattern leakage-this would blow up the space to O (xN log(xN)).
Instead RANGE-SRC-SE-(α, x) reduces the number of sizes that are being observed to log x N + 1 by storing only as many equally distributed levels from T 2 .
E.g., for x = 2 all levels are stored, for x = 4 half of the levels are stored, while for x = 16 one fourth of the levels are stored.
Note that by this approach the search complexity is O(x · r) and the space is O (N log x N).
To benchmark the effectiveness of our proposed adjustable constructions POINT-ADJ-SE, JOIN-ADJ-SE and RANGE-SRC-SE, we could use existing state-of-the-art leakage-abuse attacks [11,13,25,28,32,36].
However, these attacks are very sensitive to the exact overlapping or volume pattern (e.g., for ordering the records in range queries), which is not available in our adjustable constructions.We introduce instead a new class of attacks where the adversary tries to work with only the available bits of leakage, and at a high level, tries to guess the rest of the bits.
Also, our adversary is quite powerful, having plaintext access to the input dataset.
We stress that this is a "heavy" benchmark that already covers known attacks [11,13,25,28,32,36].
This is because if our adjustable constructions reduce the success rate of such a powerful attacker, a more realistic attacker with partial knowledge of the dataset would perform even worse (assuming the same attack strategy is followed).
We now describe the attacker model in detail.
Our model considers a single-client setting (we do not support a multi-client scenario with multiple parties accessing the data).
We assume that our adversary: (i) is the system provider that hosts the encrypted database (including the encrypted index) and performs the encrypted query execution; (ii) is honest-but-curious (i.e., tries to infer information during the execution of the protocol, but does not deviate from the protocol, e.g., to give a "tampered" answer); (iii) has full visibility of the server-side execution and memory; (iv) acquires all the possible leaked information from query executionobserving all possible queries at least once; (v) has access to 100% of the plaintext database.
Our adversary has two goals:1.
First, to perform a query recovery attack, namely decrypting the client encrypted queries;2.
Second, to perform a database recovery attack, that requires to map plaintext values (for the queried attribute) to the tuples of the encrypted database.We stress that this a strong attacker model, one that we believe is beyond most real-world adversaries' capabilities.
This was a deliberate design decision as our main goal is to evaluate our proposed mitigation techniques against a strong adversary.
On the other hand, our analysis does not capture cases where the attacker has information about the query distribution.Note here that a database recovery attack in the case of SE (α = log N) is trivial, since the identifiers of the encrypted records reveal the desired mapping to the plaintext records directly.
This task becomes more challenging for smaller values of α where this information is not given in its entirety.QR SR ← QueryRecoveryAttack(T , {t q , |q|} q∈Q )Input: Plaintext tuples T and tokens t q along with their volumes |q|.
Output: The success rate QR SR of the attack.1: Set T ← ADJ-Padding(x, T ).2: Set CORRECT = 0.
3: for each token t q do 4:Choose q at random from the set {q : |T (q )| = |q|}.
Remove q from T .
if q is the correct decryption for t q then 7:CORRECT++.8: return CORRECT/|Q|.
In addition, note that the database recovery attack becomes also trivial if SEAL does not re-randomize or assign new tuple ids to encrypted tuples; which is not the case in SEAL (see Line 6 of the used ADJ-ORAM-α).
For our experiments, we define the query recovery success rate QR SR as the ratio of the number of correctly decrypted queries over the total number of considered queries.
We also define the database recovery success rate DR SR as the ratio of the number of encrypted tuples that have been correctly mapped to the plaintext tuples.
Our experiments were conducted on a 64-bit machine with an Intel Xeon E5-2676v3 and 64 GB RAM.
We utilized the JavaX.crypto and the bouncy castle library [2] for the cryptographic operations.
Our java implementation does not use hardware supported cryptographic operations.
However, this does not affect our conclusions.
The use of hardware supported cryptographic operations can further improve the absolute time for construction and search, but it will not affect the comparison for different parameters α and x.We consider the following two datasets in our experimental evaluation.
For attacking POINT-ADJ-SE-(α, x), we use a real dataset consisting of 6,123,276 tuples with 22 attributes of reported incidents of crime in Chicago [3].
For attacking POINT-ADJ-SE-(α, x), JOIN-ADJ-SE-(α, x), and RANGE-SRC-SE-(α, x), we used the TPC-H benchmark [4] with scaling factor 0.1 which is widely used by the database community 5 .
TPC-H consists of eight separate tables (PART, SUPPLIER, PARTSUPP, CUSTOMER, NA-TION, LINEITEM, REGION, ORDERS).
Our attacks take as input the leakage of all possible queries (worst-case leakage).
The same attacks can be run with less queries, leading to lower success rate.
When evaluating the performance ofDR SR ← DatabaseRecoveryAttack(T , enc(T ), {t q , S q } q∈Q )Input: Plaintext tuples T , encrypted tuples enc(T ) and tokens t q along with respective set S q of encrypted tuples (and their α-bit identifiers).
Output: The success rate DR SR of the attack.1: Set T ← ADJ-Padding(x, T ).2: Set CORRECT = 0.
3: for each pair (t q , S q ) do 4:Choose q at random from the set {q : |T (q )| = |S q |}.
for each encrypted tuple e ∈ S q do 6:Let id be the α-bit identifier of e. Choose at random a tuple t from enc(T ) that has id as the first α bits of its identifier.
Remove t from enc(T ).
if encrypted tuple t has value q at the queried attribute then 10:CORRECT++.
Remove q from T .
SEAL(α, x) we store the oblivious dictionary locally.We denote with x = ⊥ the lack of padding, where the attacker can observe up to N distinct result sizes.
We evaluate the effectiveness of POINT-ADJ-SE-(α, x) against our new query/database recovery attacks.
In both attacks we consider one attribute of one table at a time.Our query recovery attack (see Figure 7) is very simple and uses only volume pattern leakage.
Having access to the plaintext table T , the adversary computes the new padded table for the queried attribute (Line 1 in Figure 7) using the padding parameter x. Now, for a given encrypted query q with size |q| the adversary uses T to find the candidate plaintext values which have size |q|, and chooses one of them at random (see Line 4 in Figure 7).
Note that the higher the value of x is, the larger the set of possible values in Line 4 is therefore reducing the success rate of the attack.The database recovery (see Figure 8) works as follows.
First the adversary decrypts which keyword we are querying, as before-say this keyword is q .
Now, the goal is to map the value q to the correct encrypted tuples in enc(T ), where enc(T ) is the encrypted database produced by the SETUP algorithm of SEAL.
The adversary knowing from L 2 leakage the α-bits of each returned encrypted tuple, chooses at random for each of them one tuple from enc(T ) with same α bits as prefix and maps q to this tuple.
Finally, the adversary removes the chosen tuples t from enc(T ).
The adversary is successful if after this process the encrypted tuple t has value q at the queried attribute.
Clearly, the smaller α is, the more bits the adversary will have to guess (the larger the set of tuples with same α bits as prefix is) and therefore the less successful the attack is going to be.
In all figures, we report the attacker's query recovery success rate if she just maps encrypted queries to plaintext values at random, i.e., 1/|W|-ideally, the success rate of our attack should be as close as possible to this "Random" approach.In Figure 9(a), for x = 2 (only a 2× overhead in search time and storage), we see that our scheme forces the attacker to perform very close to "Random" for 14 out of 16 attributes.
We observe that QR SR for attribute 8 is close to Random for x = 16, while for attribute 4 greater values of x are needed.
Let us look why this is the case for, say, attribute 8: There are only three values that can be queried with highly-skewed result sizes |q 1 | =1, |q 2 | =1,000 and |q 3 | =100,000.
Therefore the larger the number of padded sizes is, the more likely it is that each q i will be mapped to a distinct padded size, allowing the attacker to still distinguish them.
We observe similar patterns for the tables of TPC-H and we report the results for tables ORDERS and PART in Figure 10.
In Figure 9(b) we repeat the same experiment for the 22 attributes of the crime dataset, and we observe that in 17 out of 22 attributes for x = 4 (up to 4× performance degradation) the attacker's QR SR significantly drops and is close to the Random approach.
For attributes 6, 8, 10, 12, 15 greater values of x are needed again due to the small number of values that these attributes have.
Finally, we observe that in attributes 15 and 18, QR SR is higher for x = 64 than for x = 4, which is counterintuitive.
This is because the query sizes of the values in these attributes are distributed in a way that for x = 4 there are less distinct sizes than for x = 64.
Database recovery attack evaluation.
The database recovery attack is based on the query recovery one.
Thus, due to lack of space we focus on the 22 attributes of the crime dataset in which QR SR is higher than the one in the TPC-H dataset.
Figure 11 shows the attacker's success rate for the database recovery attack (DR SR ) for α = (17, 19, 21, 23) (α = 23 corresponds to SEAL(log N, x)) and for x = ⊥ and x = 2.
Recall that in our threat model the attacker has plaintext access to the input dataset, so for the database recovery attacks we report as a reference point a greedy strategy that the adversary may follow, in which she maps all encrypted tuples to the most frequent plaintext value (guessing heuristically).
E.g., for a binary attribute if the most frequent value appears in the 70% of the tuples/tuple-ids then the adversary achieves DR SR = 70% by following the greedy strategy.
Ideally, the goal is to find α as close as possible to log N and the smallest possible value of x, while DR SR is below the greedy strategy.
As is shown in Figure 11 for α = log N − 2 = 21 and x = 2 the attacker's success rate is always below the success rate of the greedy strategy.
In Figure 12, we provide a more detailed evaluation for 4 specific attributes of the crime dataset for α ∈ [0, log N] and x = ⊥, 2, 3, 4.
We evaluate the effectiveness of JOIN-ADJ-SE-(α, x) using the database recovery attack proposed for point queries (see Figures 8).
Since the database schema and the size of each table are usually not considered private information, we do not consider join query recovery attacks.
, but for α = log N − 1 and x = 2, DR SR drops below 6%.
We conducted all the possible foreign-key joins and we observe the same pattern.
We evaluate the effectiveness of RANGE-SRC-SE-(α, x) scheme for various x against slightly modified versions of the attacks for point queries (Figures 7 and 8).
In particular in Line 2 of both Figure 7 and 8, we do not perform padding but we recreate T 2 in plaintext with only log x N + 1 evenly distributes levels.
We report as a baseline a scheme that does not perform padding but hides the entire overlapping pattern leakage.
For the case of query recovery attack we set α = log N for RANGE-SRC-SE-(α, x), since varying α does not affect the effectiveness of the attack.
Table 1 presents for each attribute the number of all possible range queries and the number of the correctly decrypted ones using the baseline (Column 3 of Table 1), and RANGE-SRC-SE for x = 2, x = 4 and x = 8 (Columns 4, 5, 6 of Table 1).
We observe that x = 8 drastically reduces the number of correctly decrypted queries.
We omit the presentation of the database recovery attacks for ranges, since DR SR is primarily based on the result of the query recovery attack, and we see in Table 1 that even for x = 2 QR SR is small.
In Figure 14(a), we fix a database with size 2 22 records, and we show the largest slowdown (across all the possible result sizes-1, 2, 3 . . . N) of SEAL(α, x) compared to a SE scheme which has the maximum leakage.
Similarly, in Figure 15(a), we show the smallest speedup achieved by our construction SEAL(α, x) (for various values of α and x) compared to an approach that performs sequential scan and has no leakage.
Because, we consider the worst-case speedup from the most secure solution (α = 0 and x = N), sequential scan provides a more efficient approach than the use of worst-case padding with ORAM which is also achieves the same security.
We do an analysis of these plots in the next section.
We highlight again that neither SE nor sequential scan are competitors of SEAL, since (i) SEAL encapsulates those schemes (e.g., for α = 0 and x = N becomes sequential scan and for α = log N and x = ⊥ becomes SE scheme), and (ii) for non-trivial α and x they provide different security level.
We provide those experiments only as reference points of SEAL's performance compared with the most and least secure solutions.
In addition, Figures 14(a Figure 14(b) and 15(b) evaluate RANGE-ADJ-SE-(0, x) and RANGE-SRC-SE-(log N, x).
Note that both schemes hide the overlapping pattern, the first by using ORAM, the second by construction.
Also both schemes are using the same x, allowing the adversary to observe the same number of different sizes (but not necessarily the same sizes).
Note that RANGE-SRC-SE performs much better than RANGE-ADJ-SE.
This is to be expected given RANGE-SRC-SE has more leakage-the search pattern, which however we do not know how to use in an attack here.
6 We provide additional experiments regarding the performance of our SEAL scheme for the crime dataset.
We show experiments for values of α and x that significantly mitigate the proposed attacks and achieve good performance (as we also discuss in the next section).
In Figure 16, we evaluate the required index size and construction time of SEAL for x = ⊥, 2, 3, 4.
Finally, in Figures 17 and 18 we evaluate the end-to-end search time of our SEAL scheme for two attributes of the crime dataset for α = 20, 21, 22, 23 and x = ⊥, 2, 3, 4.
From the above findings, it should be evident that finding appropriate parameter values is heavily data-dependent.
In particular, it depends on the size of the database, number of distinct values, and the distribution of a given searchable attribute.
One way for users to tune these parameters is to use our attacks as an estimator, e.g., provide their databases as input and try different values of α and x in order to set their desirable success rate thresholds against our attacks (before outsourcing the database).
Below, we provide more general guidelines on how one can set these parameters based on our evaluation.Setting parameter x. Parameter x solely controls the success rate of the query recovery attack for point, range (RANGE-SRC scheme) and group-by queries.
The query recovery attack tries to map the encrypted queries to plaintext ones based on the volume leakage.
For instance, if a database contains only two values a and b and the volume of the former value is greater than the latter, i.e., |q(a)| > |q(b)|, the adversary can correctly map with certainty the encrypted query with the greater volume to a and the other one to b. Now, assuming that both values have the same volume, the adversary cannot distinguish the encrypted queries and is forced to guess.
Increasing the parameter x, we try to have more queries with the same size in order to increase the adversary's uncertainty, but finding a good value of x also depends on the distribution of the searchable value.
For instance, attribute 9 of the crime dataset is a binary attribute (it has 2 distinct values), in which |q(a)| = 4374175 and |q(b)| = 1749100.
We observe that for x = 2 these queries still will have different volumes, but for x = 3 they obtain the same volume (i.e., |q (a)| = |q (b)| = 4782969) and they will be indistinguishable.
Attribute 10 of the crime dataset, which is also a binary attribute, has |q(a)| = 5337429 and |q(b)| = 785846 and in order to make these sizes indistinguishable higher values of x are needed, i.e., x = 14.
Again, this kind of analysis can be performed locally, prior to outsourcing the dataset.Setting parameter α.
Parameter α affects the success rate of the database recovery attacks for point, range (RANGE-SRC scheme), join and group-by queries.
The success of this attack firstly depends on the outcome of the query recovery attack.
Thus, tuning the parameter x in order to increase the uncertainty of the adversary is very important.
Nevertheless, parameter α controls how many tuples are indistinguishable from each other.
For example, setting α = log N − 1 our scheme creates N/2 ORAMs of size 2-thus every tuple is indistinguishable from another one (all the tuples that are in the same ORAM are indistinguishable from each other).
Therefore, even if the query recovery attack has 100% success rate and we are trying to find the correct mapping of plaintext tuples to encrypted ones, the success rate of this attack will be at most 50% for α = log N − 1.
However, in our proposed database recovery attack, we treat the case when encrypted and plaintext tuples have the same searchable value but differ in the rest of the attributes as a success.
Due to this, the distribution of an attribute will also affect the success of the database recovery attacks.
For instance, for point queries attribute 9 of the crime dataset (which has 2 values-|q(a)| = 4374175 and |q(b)| = 1749100) for x = ⊥ and α = log N − 1 = 22, our attack has success rate around 87%, because the success rate of the query recovery attack is 100% and the adversary has uncertainty only when the same ORAM contains both tuples with value a and b. Finally, we provide some general conclusions from the analysis that we performed on our chosen datasets.
We observe that for point and join queries setting α = log N − 3 and x = 4 significantly reduces both QR SR and DR SR (e.g., attributes 4,5 of LINEITEM and attributes 13,14 of crime dataset for point queries; SUPPLIERNATION and CUSTOMERNATION for join queries), while for these values the smallest speedup from sequential scan is more than 262, 000× and the maximum slow-down from SE is 32×.
There are rare cases that attributes with skewed distribution and small number of distinct values, e.g., binary attributes, require higher values of x, such as x = 16 or x = 64 (e.g., attribute 9 of LINEITEM and attributes 9,10 of the crime dataset for point queries).
In the cases of range queries, we observe that our RANGE-SRC-SE-(log N, x) for x = 8 significantly mitigates our all-powerful query recovery attack (e.g., L_Tax and L_Discount attributethe success rate of the attack drops from 100% below 7% and 2% respectively) and achieves a maximum 48× slowdown from plain RANGE-SE.
Our work only focuses on static databases.
We believe that a very interesting problem for future work is to extend this work for dynamic databases, an approach that introduces more leakage and makes the problem more challenging.
Towards this goal, we know from the literature of SE how we can support dynamic point queries (there is an extensive literature on dynamic schemes that achieve forward/backward privacy [10,14,19,21,33,44]-the state-of-the-art security definitions for dynamic SE.
A first challenge towards dynamic databases is to study if these security definitions for point queries are suitable for other query types (such as range, joins and group-by queries), as well as to find schemes that achieve those definitions.
A second challenge is that prior ORAM and our ADJ-ORAM schemes require initializing at setup the worst-case memory size-modifying them for the dynamic case (without having to set a-priori a large upper bound) is a non-trivial problem.
A third challenge is how we could efficiently use our ADJ-Padding technique, since new updates will continuously change the distribution of the searchable attribute.
Predicting the required padding size (without extra costly bookkeeping) for a certain keyword without knowing future updates would be very challenging.One approach for handling dynamic point queries would be to explore whether our ADJ-ORAM can be used as a drop-in replacement in existing dynamic ORAM-based SE schemes (e.g., ORION from [21]), obtaining a good efficiency/security trade-off.
However, this would require addressing the aforementioned second and third challenges.
An alternative direction that avoids these challenges is to use existing techniques that transform static SE to dynamic ones (e.g., SD a from [14]).
At a high level, this requires storing the result of N updates in a sequence of log N + 1 separate indexes (with size 2 0 , . . . , 2 log N ), where each update is first stored in the smallest index and whenever two indexes of the same size exist they are downloaded and merged to a larger new index by the client.
Search queries are executed at all encrypted indexes independently.
Such techniques that periodically rebuild the encrypted indexes do not require defining a maximum capacity during setup.
Moreover, they allow the client to update the parameters α and x depending on how the database has evolved.
However, the main drawback of this approach is updates, since it has a (amortized) O(log N) update cost.
While de-amortization is possible, it is not trivial, especially in our adjustable setting, and we believe that it is a very interesting problem for future work.
In this work we show the necessity of new defense mechanisms (beyond SE) for encrypted databases.
We propose SEAL, a family of new SE schemes with adjustable leakage which can be used for building efficient encrypted databases (for point, range, group-by and joins queries).
In our evaluation we show that for our tested datasets SEAL is robust against all-powerful attacks with a reasonable performance overhead.
Finally, we believe SEAL can serve as a benchmark for measuring the effectiveness of existing and future leakage-abuse attacks.
This work was supported in part by NSF awards #1514261 and #1652259, the National Institute of Standards and Technology, Hong Kong RGC grant ECS-26208318, and by a Symantec Research Lab Graduate Fellowship.
We thank NortonLifeLock Inc. for its support, Niels Provos for shepherding the paper and the anonymous reviewers for their valuable suggestions and comments.
