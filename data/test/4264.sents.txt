In federated learning, multiple client devices jointly learn a machine learning model: each client device maintains a local model for its local training dataset, while a master device maintains a global model via aggregating the local models from the client devices.
The machine learning community recently proposed several federated learning methods that were claimed to be robust against Byzantine failures (e.g., system failures, adversarial manipulations) of certain client devices.
In this work, we perform the first systematic study on local model poisoning attacks to federated learning.
We assume an attacker has compromised some client devices, and the attacker manipulates the local model parameters on the compromised client devices during the learning process such that the global model has a large testing error rate.
We formulate our attacks as optimization problems and apply our attacks to four recent Byzantine-robust federated learning methods.
Our empirical results on four real-world datasets show that our attacks can substantially increase the error rates of the models learnt by the federated learning methods that were claimed to be robust against Byzantine failures of some client devices.
We generalize two defenses for data poisoning attacks to defend against our local model poisoning attacks.
Our evaluation results show that one defense can effectively defend against our attacks in some cases, but the defenses are not effective enough in other cases, highlighting the need for new defenses against our local model poisoning attacks to federated learning.
Byzantine-robust federated learning: In federated learning (also known as collaborative learning) [32,39], the training dataset is decentralized among multiple client devices (e.g., desktops, mobile phones, IoT devices), which could belong to different users or organizations.
These users/organizations do not want to share their local training * Equal contribution.
Minghong Fang performed this research when he was under the supervision of Neil Zhenqiang Gong.
datasets, but still desire to jointly learn a model.
For instance, multiple hospitals may desire to learn a healthcare model without sharing their sensitive data to each other.
Each client device (called worker device) maintains a local model for its local training dataset.
Moreover, the service provider has a master device (e.g., cloud server), which maintains a global model.
Roughly speaking, federated learning repeatedly performs three steps: the master device sends the current global model to worker devices; worker devices update their local models using their local training datasets and the global model, and send the local models to the master device; and the master device computes a new global model via aggregating the local models according to a certain aggregation rule.For instance, the mean aggregation rule that takes the average of the local model parameters as the global model is widely used under non-adversarial settings.
However, the global model can be arbitrarily manipulated for mean even if just one worker device is compromised [9,66].
Therefore, the machine learning community recently proposed multiple aggregation rules (e.g., Krum [9], Bulyan [42], trimmed mean [66], and median [66]), which aimed to be robust against Byzantine failures of certain worker devices.Existing data poisoning attacks are insufficient: We consider attacks that aim to manipulate the training phase of machine learning such that the learnt model (we consider the model to be a classifier) has a high testing error rate indiscriminately for testing examples, which makes the model unusable and eventually leads to denial-of-service attacks.
Figure 1 shows the training phase, which includes two components, i.e., training dataset collection and learning process.
The training dataset collection component is to collect a training dataset, while the learning process component produces a model from a given training dataset.
Existing attacks mainly inject malicious data into the training dataset before the learning process starts, while the learning process is assumed to maintain integrity.
Therefore, these attacks are often called data poisoning attacks [8,30,33,50,56,62].
In federated learning, an attacker could only inject the malicious data into the worker devices that are under the attacker's control.
As a result, these data poisoning attacks have limited success to attack Byzantine-robust federated learning (see our experimental results in Section 4.4).
Our work: We perform the first study on local model poisoning attacks to Byzantine-robust federated learning.
Existing studies [9,66] only showed local model poisoning attacks to federated learning with the non-robust mean aggregation rule.
Threat model.
Unlike existing data poisoning attacks that compromise the integrity of training dataset collection, we aim to compromise the integrity of the learning process in the training phase (see Figure 1).
We assume the attacker has control of some worker devices and manipulates the local model parameters sent from these devices to the master device during the learning process.
The attacker may or may not know the aggregation rule used by the master device.
To contrast with data poisoning attacks, we call our attacks local model poisoning attacks as they directly manipulate the local model parameters.Local model poisoning attacks.
A key challenge of local model poisoning attacks is how to craft the local models sent from the compromised worker devices to the master device.
To address this challenge, we formulate crafting local models as solving an optimization problem in each iteration of federated learning.
Specifically, the master device could compute a global model in an iteration if there are no attacks, which we call before-attack global model.
Our goal is to craft the local models on the compromised worker devices such that the global model deviates the most towards the inverse of the direction along which the before-attack global model would change.
Our intuition is that the deviations accumulated over multiple iterations would make the learnt global model differ from the before-attack one significantly.
We apply our attacks to four recent Byzantine-robust federated learning methods including Krum, Bulyan, trimmed mean, and median.Our evaluation results on the MNIST, Fashion-MNIST, CH-MNIST, and Breast Cancer Wisconsin (Diagnostic) datasets show that our attacks can substantially increase the error rates of the global models under various settings of federated learning.
For instance, when learning a deep neural network classifier for MNIST using Krum, our attack can increase the error rate from 0.11 to 0.75.
Moreover, we compare with data poisoning attacks including label flipping attacks and backgradient optimization based attacks [43] (state-of-the-art untargeted data poisoning attacks for multi-class classifiers), which poison the local training datasets on the compromised worker devices.
We find that these data poisoning attacks have limited success to attack the Byzantine-robust federated learning methods.Defenses.
Existing defenses against data poisoning attacks essentially aim to sanitize the training dataset.
One category of defenses [4,15,56,59] detects malicious data based on their negative impact on the error rate of the learnt model.
For instance, Reject on Negative Impact (RONI) [4] measures the impact of each training example on the error rate of the learnt model and removes the training examples that have large negative impact.
Another category of defenses [20,30,35] leverages new loss functions, solving which detects malicious data and learns a model simultaneously.
For instance, Jagielski et al. [30] proposed TRIM, which aims to jointly find a subset of training dataset with a given size and model parameters that minimize the loss function.
The training examples that are not in the selected subset are treated as malicious data.
However, these defenses are not directly applicable for our local model poisoning attacks because our attacks do not inject malicious data into the training dataset.To address the challenge, we generalize RONI and TRIM to defend against our local model poisoning attacks.
Both defenses remove the local models that are potentially malicious before computing the global model using a Byzantine-robust aggregation rule in each iteration.
One defense removes the local models that have large negative impact on the error rate of the global model (inspired by RONI that removes training examples that have large negative impact on the error rate of the model), while the other defense removes the local models that result in large loss (inspired by TRIM that removes the training examples that have large negative impact on the loss), where the error rate and loss are evaluated on a validation dataset.
We call the two defenses Error Rate based Rejection (ERR) and Loss Function based Rejection (LFR), respectively.
Moreover, we combine ERR and LFR, i.e., we remove the local models that are removed by either ERR or LFR.
Our empirical evaluation results show that LFR outperforms ERR; and the combined defense is comparable to LFR in most cases.
Moreover, LFR can defend against our attacks in certain cases, but LFR is not effective enough in other cases.
For instance, LFR can effectively defend against our attacks that craft local models based on the trimmed mean aggregation rule, but LFR is not effective against our attacks that are based on the Krum aggregation rule.
Our results show that we need new defense mechanisms to defend against our local model poisoning attacks.Our key contributions can be summarized as follows:• We perform the first systematic study on attacking Byzantine-robust federated learning.
• We propose local model poisoning attacks to Byzantinerobust federated learning.
Our attacks manipulate the local model parameters on compromised worker devices during the learning process.
• We generalize two defenses for data poisoning attacks to defend against local model poisoning attacks.
Our results show that, although one of them is effective in some cases, they have limited success in other cases.
Suppose we have m worker devices and the ith worker device has a local training dataset D i .
The worker devices aim to collaboratively learn a classifier.
Specifically, the model parameters w of the classifier are often obtained via solving the following optimization problem: F(w, D i ) is the objective function for the local training dataset on the ith device and characterizes how well the parameters w model the local training dataset on the ith device.
Different classifiers (e.g., logistic regression, deep neural networks) use different objective functions.
In federated learning, each worker device maintains a local model for its local training dataset.
Moreover, we have a master device to maintain a global model via aggregating local models from the m worker devices.
Specifically, federated learning performs the following three steps in each iteration:min w ∑ m i=1 F(w, D i ), whereStep I.
The master device sends the current global model parameters to all worker devices.Step II.
The worker devices update their local model parameters using the current global model parameters and their local training datasets in parallel.
In particular, the ith worker device essentially aims to solve the optimization problem min w i F(w i , D i ) with the global model parameters w as an initialization of the local model parameters w i .
A worker device could use any method to solve the optimization problem, though stochastic gradient descent is the most popular one.
Specifically, the ith worker device updates its local model parameters w i as w i = w − α · ∂F(w,B i ) ∂w , where α is the learning rate and B i is a randomly sampled batch from the local training dataset D i .
Note that a worker device could apply stochastic gradient descent multiple rounds to update its local model.
After updating the local models, the worker devices send them to the master device.Step III.
The master device aggregates the local models from the worker devices to obtain a new global model according to a certain aggregation rule.
Formally, we havew = A(w 1 , w 2 , · · · , w m ).
The master device could also randomly pick a subset of worker devices and send the global model to them; the picked worker devices update their local models and send them to the master device; and the master device aggregates the local models to obtain the new global model [39].
We note that, for the aggregation rules we study in this paper, sending local models to the master device is equivalent to sending gradients to the master device, who aggregates the gradients and uses them to update the global model.
A naive aggregation rule is to average the local model parameters as the global model parameters.
This mean aggregation rule is widely used under non-adversarial settings [16,32,39].
However, mean is not robust under adversarial settings.
In particular, an attacker can manipulate the global model parameters arbitrarily for this mean aggregation rule when compromising only one worker device [9,66].
Therefore, the machine learning community has recently developed multiple aggregation rules that aim to be robust even if certain worker devices exhibit Byzantine failures.
Next, we review several such aggregation rules.
Krum [9] and Bulyan [42]: Krum selects one of the m local models that is similar to other models as the global model.
The intuition is that even if the selected local model is from a compromised worker device, its impact may be constrained since it is similar to other local models possibly from benign worker devices.
Suppose at most c worker devices are compromised.
For each local model w i , the master device computes the m − c − 2 local models that are the closest to w i with respect to Euclidean distance.
Moreover, the master device computes the sum of the distances between w i and its closest m − c − 2 local models.
Krum selects the local model with the smallest sum of distance as the global model.
When c < m−2 2 , Krum has theoretical guarantees for the convergence for certain objective functions.Euclidean distance between two local models could be substantially influenced by a single model parameter.
Therefore, Krum could be influenced by some abnormal model parameters [42].
To address this issue, Mhamdi et al. [42] proposed Bulyan, which essentially combines Krum and a variant of trimmed mean (trimmed mean will be discussed next).
Specifically, Bulyan first iteratively applies Krum to select θ (θ ≤ m − 2c) local models.
Then, Bulyan uses a variant of trimmed mean to aggregate the θ local models.
In particular, for each jth model parameter, Bulyan sorts the jth parameters of the θ local models, finds the γ (γ ≤ θ − 2c) parameters that are the closest to the median, and computes their mean as the jth parameter of the global model.
When c ≤ m−3 4 , Bulyan has theoretical guarantees for the convergence under certain assumptions of the objective function.Since Bulyan is based on Krum, our attacks for Krum can transfer to Bulyan (see Appendix A).
Moreover, Bulyan is not scalable because it executes Krum many times in each iteration and Krum computes pairwise distances between local models.
Therefore, we will focus on Krum in the paper.
Trimmed mean [66]: This aggregation rule aggregates each model parameter independently.
Specifically, for each jth model parameter, the master device sorts the jth parameters of the m local models, i.e., w 1 j , w 2 j , · · · , w m j , where w i j is the jth parameter of the ith local model, removes the largest and smallest β of them, and computes the mean of the remaining m − 2β parameters as the jth parameter of the global model.
Suppose at most c worker devices are compromised.
This trimmed mean aggregation rule achieves order-optimal error rate when c ≤ β < m 2 and the objective function to be minimized is strongly convex.
Specifically, the order-optimal errorrate is˜Ois˜ is˜O( c m √ n + 1 √ mn ), 1where n is the number of training data points on a worker device (worker devices are assumed to have the same number of training data points).
Median [66]: In this median aggregation rule, for each jth model parameter, the master device sorts the jth parameters of the m local models and takes the median as the jth parameter of the global model.
Note that when m is an even number, median is the mean of the middle two parameters.
Like the trimmed mean aggregation rule, the median aggregation rule also achieves an order-optimal error rate when the objective function is strongly convex.
Attacker's goal: Like many studies on poisoning attacks [7,8,30,33,50,62,65], we consider an attacker's goal is to manipulate the learnt global model such that it has a high error rate indiscriminately for testing examples.
Such attacks are known as untargeted poisoning attacks, which make the learnt model unusable and eventually lead to denial-of-service attacks.
For instance, an attacker may perform such attacks to its competitor's federated learning system.
Some studies also considered other types of poisoning attacks (e.g., targeted poisoning attacks [56]), which we will review in Section 6.
We note that the Byzantine-robust aggregation rules discussed above can asymptotically bound the error rates of the learnt global model under certain assumptions of the objective functions, and some of them (i.e., trimmed mean and median) even achieve order-optimal error rates.
These theoretical guarantees seem to imply the difficulty of manipulating the error rates.
However, the asymptotic guarantees do not precisely characterize the practical performance of the learnt models.
Specifically, the asymptotic error rates are quantified using the˜Othe˜ the˜O notation.
The˜OThe˜ The˜O notation ignores any constant, e.g., ˜O( 1 √ n )= ˜ O( 100 √ n ).
However, such constant significantly influences a model's error rate in practice.
As we will show, although these asymptotic error rates still hold for our local model poisoning attacks since they hold for Byzantine failures, our attacks can still significantly increase the testing error rates of the learnt models in practice.Attacker's capability: We assume the attacker has control of c worker devices.
Specifically, like Sybil attacks [17] to distributed systems, the attacker could inject c fake worker devices into the federated learning system or compromise c benign worker devices.
However, we assume the number of worker devices under the attacker's control is less than 50% (otherwise, it would be easy to manipulate the global models).
We assume the attacker can arbitrarily manipulate the local models sent from these worker devices to the master device.
For simplicity, we call these worker devices compromised worker devices no matter whether they are fake devices or compromised benign ones.
O is a variant of the O notation, which ignores the logarithmic terms.Attacker's background knowledge: The attacker knows the code, local training datasets, and local models on the compromised worker devices.
We characterize the attacker's background knowledge along the following two dimensions:Aggregation rule.
We consider two scenarios depending on whether the attacker knows the aggregation rule or not.
In particular, the attacker could know the aggregation rule in various scenarios.
For instance, the service provider may make the aggregation rule public in order to increase transparency and trust of the federated learning system [39].
When the attacker does not know the aggregation rule, we will craft local model parameters for the compromised worker devices based on a certain aggregation rule.
Our empirical results show that such crafted local models could also attack other aggregation rules.
In particular, we observe different levels of transferability of our local model poisoning attacks between different aggregation rules.Training data.
We consider two cases (full knowledge and partial knowledge) depending on whether the attacker knows the local training datasets and local models on the benign worker devices.
In the full knowledge scenario, the attacker knows the local training dataset and local model on every worker device.
We note that the full knowledge scenario has limited applicability in practice for federated learning as the training dataset is decentralized on many worker devices, and we use it to estimate the upper bound of our attacks' threats for a given setting of federated learning.
In the partial knowledge scenario, the attacker only knows the local training datasets and local models on the compromised worker devices.Our threat model is inspired by multiple existing studies [30,47,48,56] on adversarial machine learning.
For instance, Suciu et al. [56] recently proposed to characterize an attacker's background knowledge and capability for data poisoning attacks with respect to multiple dimensions such as Feature, Algorithm, and Instance.
Our aggregation rule and training data dimensions are essentially the Algorithm and Instance dimensions, respectively.
We do not consider the Feature dimension because the attacker controls some worker devices and already knows the features in our setting.Some Byzantine-robust aggregation rules (e.g., Krum [9] and trimmed mean [66]) need to know the upper bound of the number of compromised worker devices in order to set parameters appropriately.
For instance, trimmed mean removes the largest and smallest β local model parameters, where β is at least the number of compromised worker devices (otherwise trimmed mean can be easily manipulated).
To calculate a lower bound for our attack's threat, we consider a hypothetical, strong service provider who knows the number of compromised worker devices and sets parameters in the aggregation rule accordingly.
We focus on the case where the aggregation rule is known.
When the aggregation rule is unknown, we craft local models based on an assumed one.
Our empirical results in Section 4.3 show that our attacks have different levels of transferability between aggregation rules.
Our idea is to manipulate the global model via carefully crafting the local models sent from the compromised worker devices to the master device in each iteration of federated learning.
We denote by s j the changing direction of the jth global model parameter in the current iteration when there are no attacks, where s j = 1 or −1.
s j = 1 (or s j = −1) means that the jth global model parameter increases (or decreases) upon the previous iteration.
We consider the attacker's goal (we call it directed deviation goal) is to deviate a global model parameter the most towards the inverse of the direction along which the global model parameter would change without attacks.
Suppose in an iteration, w i is the local model that the ith worker device intends to send to the master device when there are no attacks.
Without loss of generality, we assume the first c worker devices are compromised.
Our directed deviation goal is to craft local models w 񮽙 1 , w 񮽙 2 , · · · , w 񮽙 c for the compromised worker devices via solving the following optimization problem in each iteration:max w 񮽙 1 ,··· ,w 񮽙 c s T (w − w 񮽙 ), subject to w = A(w 1 , · · · , w c , w c+1 , · · · , w m ), w 񮽙 = A(w 񮽙 1 , · · · , w 񮽙 c , w c+1 , · · · , w m ),(1)where s is a column vector of the changing directions of all global model parameters, w is the before-attack global model, and w 񮽙 is the after-attack global model.
Note that s, w, and w 񮽙 all depend on the iteration number.
Since our attacks manipulate the local models in each iteration, we omit the explicit dependency on the iteration number for simplicity.In our preliminary exploration of formulating poisoning attacks, we also considered a deviation goal, which does not consider the global model parameters' changing directions.
We empirically find that our attacks based on both the directed deviation goal and the deviation goal achieve high testing error rates for Krum.
However, the directed deviation goal substantially outperforms the deviation goal for trimmed mean and median aggregation rules.
Appendix B shows our deviation goal and the empirical comparisons between deviation goal and directed deviation goal.
Recall that Krum selects one local model as the global model in each iteration.
Suppose w is the selected local model in the current iteration when there are no attacks.
Our goal is to craft the c compromised local models such that the local model selected by Krum has the largest directed deviation from w.
Our idea is to make Krum select a certain crafted local model (e.g., w 񮽙 1 without loss of generality) via crafting the c compromised local models.
Therefore, we aim to solve the optimization problem in Equation 1 with w 񮽙 = w 񮽙 1 and the aggregation rule is Krum.Full knowledge: The key challenge of solving the optimization problem is that the constraint of the optimization problem is highly nonlinear and the search space of the local modelsw 񮽙 1 , · · · , w 񮽙 c is large.To address the challenge, we make two approximations.
Our approximations represent suboptimal solutions to the optimization problem, which means that the attacks based on the approximations may have suboptimal performance.
However, as we will demonstrate in our experiments, our attacks already substantially increase the error rate of the learnt model.
First, we restrict w 񮽙 1 as follows: w 񮽙 1 = w Re − λs, where w Re is the global model received from the master device in the current iteration (i.e., the global model obtained in the previous iteration) and λ > 0.
This approximation explicitly models the directed deviation between the crafted local model w 񮽙 1 and the received global model.
We also explored the approximation w 񮽙 1 = w − λs, which means that we explicitly model the directed deviation between the crafted local model and the local model selected by Krum before attack.
However, we found that our attacks are less effective using this approximation.Second, to make w 1 more likely to be selected by Krum, we craft the other c − 1 compromised local models to be close to w 񮽙 1 .
In particular, when the other c − 1 compromised local models are close to w 񮽙 1 , w 񮽙 1 only needs to have a small distance to m − 2c − 1 benign local models in order to be selected by Krum.
In other words, the other c − 1 compromised local models "support" the crafted local model w 񮽙 1 .
In implementing our attack, we first assume the other c − 1 compromised local models are the same as w 񮽙 1 , then we solve w 񮽙 1 , and finally we randomly sample c − 1 vectors, whose distance to w 񮽙 1 is at most ε, as the other c − 1 compromised local models.
With our two approximations, we transform the optimization problem as follows:max λ λ subject to w 񮽙 1 = Krum(w 񮽙 1 , · · · , w 񮽙 c , w (c+1) , · · · , w m ), w 񮽙 1 = w Re − λs, w 񮽙 i = w 񮽙 1 , for i = 2, 3, · · · , c.(2)More precisely, the objective function in the above optimization problem should be s T (w − w Re ) + λs T s. However, s T (w − w Re ) is a constant and s T s = d where d is the number of parameters in the global model.
Therefore, we simplify the objective function to be just λ.
After solving λ in the optimization problem, we can obtain the crafted local model w 񮽙 1 .
Then, we randomly sample c − 1 vectors whose distance to w 񮽙 1 is at most ε as the other c − 1 compromised local models.
We will explore the impact of ε on the effectiveness of our attacks in experiments.Solving λ.
Solving λ in the optimization problem in Equation 2 is key to our attacks.
First, we derive an upper bound of the solution λ to the optimization problem.
Formally, we have the following theorem.
Theorem 1.
Suppose λ is a solution to the optimization problem in Equation 2.
λ is upper bounded as follows:λ ≤ 1 (m − 2c − 1) √ d · min c+1≤i≤m ⎛ ⎝ ∑ l∈˜Γl∈˜ l∈˜Γ m−c−2 w i D(w l , w i ) ⎞ ⎠ + 1 √ d · max c+1≤i≤m D(w i , w Re ),(3)where d is the number of parameters in the global model, D(w l , w i ) is the Euclidean distance between w l and w i ,˜ Γ m−c−2 w iis the set of m − c − 2 benign local models that have the smallest Euclidean distance to w i .
Proof.
See Appendix C.Given the upper bound, we use a binary search to solve λ.
Specifically, we initialize λ as the upper bound and check whether Krum selects w 񮽙 1 as the global model; if not, then we half λ; we repeat this process until Krum selects w 񮽙 1 or λ is smaller than a certain threshold (this indicates that the optimization problem may not have a solution).
In our experiments, we use 1 × 10 −5 as the threshold.Partial knowledge: In the partial knowledge scenario, the attacker does not know the local models on the benign worker devices, i.e., w (c+1) , · · · , w m .
As a result, the attacker does not know the changing directions s and cannot solve the optimization problem in Equation 2.
However, the attacker has access to the before-attack local models on the c compromised worker devices.
Therefore, we propose to craft compromised local models based on these before-attack local models.
First, we compute the mean of the c before-attack local models as˜w as˜ as˜w = 1 c ∑ c i=1 w i .
Second, we estimate the changing directions using the mean local model.
Specifically, if the mean of the jth parameter is larger than the jth global model parameter received from the master device in the current iteration, then we estimate the changing direction for the jth parameter to be 1, otherwise we estimate it to be −1.
For simplicity, we denote by˜sby˜ by˜s the vector of estimated changing directions.Third, we treat the before-attack local models on the compromised worker devices as if they were local models on benign worker devices, and we aim to craft local model w 񮽙 1 such that, among the crafted local model and the c beforeattack local models, Krum selects the crafted local model.
Formally, we have the following optimization problem:max λ λ subject to w 񮽙 1 = Krum(w 񮽙 1 , w 1 , · · · , w c ), w 񮽙 1 = w Re − λ˜sλ˜s.
(4)Similar to Theorem 1, we can also derive an upper bound of λ for the optimization problem in Equation 4.
Moreover, similar to the full knowledge scenario, we use a binary search to solve λ.
However, unlike the full knowledge scenario, if we cannot find a solution λ until λ is smaller than a threshold (i.e., 1 × 10 −5 ), then we add one more crafted local model w 񮽙 2 such that among the crafted local models w 񮽙 1 , w 񮽙 2 , and the c before-attack local models, Krum selects the crafted local model w 񮽙 1 .
Specifically, we solve the optimization problem in Equation 4 with w 񮽙 2 added into the Krum aggregation rule.
Like the full knowledge scenario, we assume w 񮽙 2 = w 񮽙 1 .
If we still cannot find a solution λ until λ is smaller than the threshold, we add another crafted local model.
We repeat this process until finding a solution λ.
We find that such iterative searching process makes our attack more effective for Krum in the partial knowledge scenario.
After solving λ, we obtain the crafted local model w 񮽙 1 .
Then, like the full knowledge scenario, we randomly sample c − 1 vectors whose distance to w 񮽙 1 is at most ε as the other c−1 compromised local models.
Suppose w i j is the jth before-attack local model parameter on the ith worker device and w j is the jth before-attack global model parameter in the current iteration.
We discuss how we craft each local model parameter on the compromised worker devices.
We denote by w max, j and w min, j the maximum and minimum of the jth local model parameters on the benign worker devices, i.e.,w max, j =max{w (c+1) j , w (c+2) j , · · · , w m j } and w min, j =min{w (c+1) j , w (c+2) j , · · · , w m j }.
Full knowledge: Theoretically, we can show that the following attack can maximize the directed deviations of the global model (i.e., an optimal solution to the optimization problem in Equation 1): if s j = −1, then we use any c numbers that are larger than w max, j as the jth local model parameters on the c compromised worker devices, otherwise we use any c numbers that are smaller than w min, j as the jth local model parameters on the c compromised worker devices.
Intuitively, our attack crafts the compromised local models based on the maximum or minimum benign local model parameters, depending on which one deviates the global model towards the inverse of the direction along which the global model would change without attacks.
The sampled c numbers should be close to w max, j or w min, j to avoid being outliers and being detected easily.
Therefore, when implementing the attack, if s j = −1, then we randomly sample the c numbers in the interval [w max, j , b · w max, j ] (when w max, j > 0) or [w max, j , w max, j /b] (when w max, j ≤ 0), otherwise we randomly sample the c numbers in the interval [w min, j /b, w min, j ] (when w min, j > 0) or [b · w min, j , w min, j ] (when w min, j ≤ 0).
Our attack does not depend on b once b > 1.
In our experiments, we set b = 2.
Partial knowledge: An attacker faces two challenges in the partial knowledge scenario.
First, the attacker does not know the changing direction variable s j because the attacker does not know the local models on the benign worker devices.
Second, for the same reason, the attacker does not know the maximum w max, j and minimum w min, j of the benign local model parameters.
Like Krum, to address the first challenge, we estimate the changing direction variables using the local models on the compromised worker devices.One naive strategy to address the second challenge is to use a very large number as w max, j or a very small number as w min, j .
However, if we craft the compromised local models based on w max, j or w min, j that are far away from their true values, the crafted local models may be outliers and the master device may detect the compromised local models easily.
Therefore, we propose to estimate w max, j and w min, j using the beforeattack local model parameters on the compromised worker devices.
In particular, the attacker can compute the mean μ j and standard deviation σ j of each jth parameter on the compromised worker devices.Based on the assumption that each jth parameters of the benign worker devices are samples from a Gaussian distribution with mean μ j and standard deviation σ j , we can estimate that w max, j is smaller than μ j + 3σ j or μ j + 4σ j with large probabilities; and w min, j is larger than μ j − 4σ j or μ j − 3σ j with large probabilities.
Therefore, when s j is estimated to be −1, we sample c numbers from the interval [μ j + 3σ j , μ j + 4σ j ] as the jth parameter of the c compromised local models, which means that the crafted compromised local model parameters are larger than the maximum of the benign local model parameters with a high probability (e.g., 0.898 -0.998 when m = 100 and c = 20 under the Gaussian distribution assumption).
When s j is estimated to be 1, we sample c numbers from the interval [μ j − 4σ j , μ j − 3σ j ] as the jth parameter of the c compromised local models, which means that the crafted compromised local model parameters are smaller than the minimum of the benign local model parameters with a high probability.
The jth model parameters on the benign worker devices may not accurately follow a Gaussian distribution.
However, our attacks are still effective empirically.
We evaluate the effectiveness of our attacks using multiple datasets in different scenarios, e.g., the impact of different parameters and known vs. unknown aggregation rules.
Moreover, we compare our attacks with existing attacks.
Datasets: We consider four datasets: MNIST, Fashion-MNIST, CH-MNIST [31] 2 and Breast Cancer Wisconsin (Diagnostic) [18].
MNIST and Fashion-MNIST each includes 60,000 training examples and 10,000 testing examples, where each example is an 28×28 grayscale image.
Both datasets are 10-class classification problems.
The CH-MNIST dataset consists of 5000 images of histology tiles from patients with colorectal cancer.
The dataset is an 8-class classification problem.
Each image has 64×64 grayscale pixels.
We randomly select 4000 images as the training examples and use the remaining 1000 as the testing examples.
The Breast Cancer Wisconsin (Diagnostic) dataset is a binary classification problem to diagnose whether a person has breast cancer.
The dataset contains 569 examples, each of which has 30 features describing the characteristics of a person's cell nuclei.
We randomly select 455 (80%) examples as the training examples, and use the remaining 114 examples as the testing examples.Machine learning classifiers: We consider the following classifiers.Multi-class logistic regression (LR).
The considered aggregation rules have theoretical guarantees for the error rate of LR classifier.Deep neural networks (DNN).
For MNIST, Fashion-MNIST, and Breast Cancer Wisconsin (Diagnostic), we use a DNN with the architecture described in Table 7a in Appendix.
We use ResNet20 [28] for CH-MNIST.
Our DNN architecture does not necessarily achieve the smallest error rates for the considered datasets, as our goal is not to search for the best DNN architecture.
Our goal is to show that our attacks can increase the testing error rates of the learnt DNN classifiers.Compared attacks: We compare the following attacks.Gaussian attack.
This attack randomly crafts the local models on the compromised worker devices.
Specifically, for each jth model parameter, we estimate a Gaussian distribution using the before-attack local models on all worker devices.
Then, for each compromised worker device, we sample a number from the Gaussian distribution and treat it as the jth parameter of the local model on the compromised worker device.
We use this Gaussian attack to show that crafting compromised local models randomly can not effectively attack the Byzantine-robust aggregation rules.
Label flipping attack.
This is a data poisoning attack that does not require knowledge of the training data distribution.
On each compromised worker device, this attack flips the label of each training instance.
Specifically, we flip a label l as L − l − 1, where L is the number of classes in the classification problem and l = 0, 1, · · · , L − 1.Back-gradient optimization based attack [43].
This is the state-of-the-art untargeted data poisoning attack for multiclass classifiers.
We note that this attack is not scalable and thus we compare our attacks with this attack on a subset of MNIST separately.
The results are shown in Section 4.4.
Full knowledge attack or partial knowledge attack.
Our attack when the attacker knows the local models on all worker devices or the compromised ones.Parameter setting: We describe parameter setting for the federated learning algorithms and our attacks.
Table 1 summarizes the default setting for key parameters.
We use MXNet [12] to implement federated learning and attacks.
We repeat each experiment for 50 trials and report the average results.
We observed that the variances are very small, so we omit them for simplicity.Federated learning algorithms.
By default, we assume m = 100 worker devices; each worker device applies one round of stochastic gradient descent to update its local model; and the master device aggregates local models from all worker devices.
One unique characteristic of federated learning is that the local training datasets on different devices may not be independently and identically distributed (i.e., non-IID) [39].
We simulate federated learning with different non-IID training data distributions.
Suppose we have L classes in the classification problem, e.g., L = 10 for the MNIST and Fashion-MNIST datasets, and L = 8 for the CH-MNIST dataset.
We evenly split the worker devices into L groups.
We model non-IID federated learning by assigning a training instance with label l to the lth group with probability p, where p > 0.
A higher p indicates a higher degree of non-IID.
For convenience, we call the probability p degree of non-IID.
Unless otherwise mentioned, we set p = 0.5.
We set 500 iterations for the LR classifier on MNIST; we set 2,000 iterations for the DNN classifiers on all four datasets; and we set the batch size to be 32 in stochastic gradient descent, except that we set the batch size to be 64 for Fashion-MNIST as such setting leads to a more accurate model.
The trimmed mean aggregation rule prunes the largest and smallest β parameters, where c ≤ β < m 2 .
Pruning more parameters leads to larger testing error rates without attacks.
By default, we consider β = c as the authors of trimmed mean did [66].
Our attacks.
Unless otherwise mentioned, we consider 20 worker devices are compromised.
Our attacks to Krum have a parameter ε, which is related to the distance between the crafted compromised local models.
We set ε = 0.01 (we will study the impact of ε on our attack).
We do not set ε = 0 because ε = 0 makes the c compromised local models exactly the same, making the compromised local models easily detected by the master device.
Our attacks to trimmed mean and median have a parameter b in the full knowledge scenario, where b > 1.
Our attacks do not depend on b once b > 1.
We set b = 2.
Unless otherwise mentioned, we assume that attacker manipulates the local models on the compromised worker devices in each iteration.
Our attacks are effective: Table 2 shows the testing error rates of the compared attacks on the four datasets.
First, these results show that our attacks are effective and substantially outperform existing attacks, i.e., our attacks result in higher er- ror rates.
For instance, when dataset is MNIST, classifier is LR, and aggregation rule is Krum, our partial knowledge attack increases the error rate from 0.14 to 0.72 (around 400% relative increase).
Gaussian attacks only increase the error rates in several cases, e.g., median aggregation rule for Fashion-MNIST, and trimmed mean and median for CH-MNIST.
Label flipping attacks can increase the error rates for DNN classifiers in some cases but have limited success for LR classifiers.Second, Krum is less robust to our attacks than trimmed mean and median, except on Breast Cancer Wisconsin (Diagnostic) where Krum is comparable to median.
A possible reason why trimmed mean and median outperform Krum is that Krum picks one local model as the global model, while trimmed mean and median aggregate multiple local models to update the global model (the median selects one local model parameter for each model parameter, but the selected parameters may be from different local models).
Trimmed mean is more robust to our attacks in some cases while median is more robust in other cases.
Third, we observe that the error rates may depend on the data dimension.
For instance, MNIST and Fashion-MNIST have 784 dimensions, CH-MNIST has 4096 dimensions, and Breast Cancer Wisconsin (Diagnostic) has 30 dimensions.
For the DNN classifiers, the error rates are higher on CH-MNIST than on other datasets in most cases, while the error rates are lower on Breast Cancer Wisconsin (Diagnostic) than on other datasets in most cases.We note that federated learning may have higher error rate than centralized learning, even if robustness feature is not considered (i.e., mean aggregation rule is used).
For instance, the DNN classifiers respectively achieve testing error rates 0.01, 0.08, 0.07, and 0.01 in centralized learning on the four datasets, while they respectively achieve testing error rates 0.04, 0.09, 0.09, and 0.01 in federated learning with the mean aggregation rule on the four datasets.
However, in the scenarios where users' training data can only be stored on their edge/mobile devices, e.g., for privacy purposes, centralized learning is not applicable and federated learning may be the only option even though its error rate is higher.
Compared to the mean aggregation rule, Byzantine-robust aggregation rule increases the error rate without attacks.
However, if Byzantinerobust aggregation rule is not used, a single malicious device can make the learnt global model totally useless [9,66].
To summarize, in the scenarios where users' training data can only be stored on their edge/mobile devices and there may exist attacks, Byzantine-robust federated learning may be the best option, even if its error rate is higher.Impact of the percentage of compromised worker devices: Figure 2 shows the error rates of different attacks as the percentage of compromised worker devices increases on MNIST.
Our attacks increase the error rates significantly as we compromise more worker devices; label flipping only slightly increases the error rates; and Gaussian attacks have no notable impact on the error rates.
Two exceptions are that Krum's error rates decrease when the percentage of compromised worker devices increases from 5% to 10% in Figure 2a and from 10% to 15% in Figure 2d.
We suspect the reason is that Krum selects one local model as a global model in each iteration.
We have similar observations on the other datasets.
Therefore, we omit the corresponding results for simplicity.
Impact of the degree of non-IID in federated learning: Figure 3 shows the error rates for the compared attacks for different degrees of non-IID on MNIST.
Error rates of all attacks including no attacks increase as we increase the degree of non-IID, except that the error rates of our attacks to Krum fluctuate as the degree of non-IID increases.
A possible reason is that as the local training datasets on different worker devices are more non-IID, the local models are more diverse, leaving more room for attacks.
For instance, an extreme example is that if the local models on the benign worker devices are the same, it would be harder to attack the aggregation rules, because their aggregated model would be more likely to depend on the benign local models.
Impact of different parameter settings of federated learning algorithms: We study the impact of various parameters in federated learning including the number of rounds of stochastic gradient descent each worker device performs, number of worker devices, number of worker devices selected to update the global model in each iteration, and β in trimmed mean.
In these experiments, we use MNIST and the LR classifier for simplicity.
Unless otherwise mentioned, we consider median, as median is more robust than Krum and does not require configuring extra parameters (trimmed mean requires configuring β).
Moreover, for simplicity, we consider partial knowledge attacks as they are more practical.Worker devices can perform multiple rounds of stochastic gradient descent to update their local models.
Figure 4a shows the impact of the number of rounds on the testing error rates of our attack.
The testing error rates decrease as we use more rounds of stochastic gradient descent for both no attack and our partial knowledge attack.
This is because more rounds of stochastic gradient descent lead to more accurate local models, and the local models on different worker devices are less diverse, leaving a smaller attack space.
However, our attack still increases the error rates substantially even if we use more rounds.
For instance, our attack still increases the error rate by more than 30% when using 10 rounds of stochastic gradient descent.
We note that a large number of rounds result in large computational cost for worker devices, which may be unacceptable for resource-constrained devices such as mobile phones and IoT devices.
Figure 4b shows the testing error rates of our attack as the number of worker devices increases, where 20% of worker devices are compromised.
Our attack is more effective (i.e., testing error rate is larger) as the federated learning system involves more worker devices.
We found a possible reason is that our partial knowledge attacks can more accurately estimate the changing directions with more worker devices.
For instance, for trimmed mean of the DNN classifier on MNIST, our partial knowledge attacks can correctly estimate the changing directions of 72% of the global model parameters on average when there are 50 worker devices, and this fraction increases to 76% when there are 100 worker devices.
In federated learning [39], the master device could randomly sample some worker devices and send the global model to them; the sampled worker devices update their local models and send the updated local models to the master device; and the master device updates the global model using the local models from the sampled worker devices.
Figure 4c shows the impact of the number of worker devices selected in each iteration on the testing error rates of our attack, where the total number of worker devices is 100.
Since the master device randomly selects a subset of worker devices in each iteration, a smaller number of compromised worker devices are selected in some iterations, while a larger number of compromised worker devices are selected in other iterations.
On average, among the selected worker devices, c m of them are compromised ones, where c is the total number of compromised worker devices and m is the total number of worker devices.
Our Figure 2 shows that our attacks become effective when c m is larger than 10%-15%.
Note that an attacker can inject a large number of fake devices to a federated learning system, so c m can be large.
The trimmed mean aggregation rule has a parameter β, which should be at least the number of compromised worker devices.
Figure 5a shows the testing error rates of no attack and our partial knowledge attack as β increases.
Roughly speaking, our attack is less effective (i.e., testing error rates are smaller) as more local model parameters are trimmed.
This is because our crafted local model parameters on the compromised worker devices are more likely to be trimmed when the master device trims more local model parameters.
However, the testing error of no attack also slightly increases as β increases.
The reason is that more benign local model parameters are trimmed and the mean of the remaining local model parameters becomes less accurate.
The master device may be motivated to use a smaller β to guarantee performance when there are no attacks.
Impact of the parameter ε in our attacks to Krum: Fig- ure 5b shows the error rates of the Krum aggregation rule when our attacks use different ε, where MNIST dataset and LR classifier are considered.
We observe that our attacks can effectively increase the error rates using a wide range of ε.
Moreover, our attacks achieve larger error rates when ε is smaller.
This is because when ε is smaller, the distances between the compromised local models are smaller, which makes it more likely for Krum to select the local model crafted by our attack as the global model.
Impact of the number of poisoned iterations: Figure 5c shows the error rates of the median aggregation rule when our attacks poison the local models on the compromised worker devices in a certain fraction of randomly selected iterations of federated learning.
Unsurprisingly, the error rate increases when poisoning more iterations.Alternative training strategy: Each iteration results in a global model.
Instead of selecting the last global model as the final model, an alternative training strategy is to select the global model that has the lowest testing error rate.
3 Ta- ble 3 shows the testing error rates of various attacks on the DNN classifier for MNIST, when such alternative training strategy is adopted.
In these experiments, our attacks attack each iteration of federated learning, and the column "NoAttack" corresponds to the scenarios where no iterations are attacked.
Compared to Table 2b, this alternative training strategy is slightly more secure against our attacks.
However, our attacks are still effective.
For instance, for the Krum, trimmed mean, and median aggregation rules, our partial knowledge attacks still increase the testing error rates by 590%, 100%, and 83%, respectively.
Another training strategy is to roll back to a few iterations ago if the master device detects an unusual increase of training error rate.
However, such training strategy is not applicable because the training error rates of the global models still decrease until convergence when we perform our attacks in each iteration.
In other words, there are no unusual increases of training error rates.
We craft local models based on one aggregation rule and show the attack effectiveness for other aggregation rules.
Table 4 shows the transferability between aggregation rules, where MNIST and LR classifier are considered.
We observe different levels of transferability between aggregation rules.
Specifically, Krum based attack can well transfer to trimmed mean and median, e.g., Krum based attack increases the error rate from 0.12 to 0.15 (25% relative increase) for trimmed mean, and from 0.13 to 0.18 (38% relative increase) for median.Trimmed mean based attack does not transfer to Krum but transfers to median well.
For instance, trimmed mean based attack increases the error rates from 0.13 to 0.20 (54% relative increase) for median.
Back-gradient optimization based attack (BGA) [43] is stateof-the-art untargeted data poisoning attack for multi-class classifiers such as multi-class LR and DNN.
BGA formulates a bilevel optimization problem, where the inner optimization is to minimize the training loss on the poisoned training data and the outer optimization is to find poisoning examples that maximize the minimal training loss in the inner optimization.
BGA iteratively finds the poisoned examples by alternately solving the inner minimization and outer maximization problems.
We implemented BGA and verified that our implementation can reproduce the results reported by the authors.
However, BGA is not scalable to the entire MNIST dataset.
Therefore, we uniformly sample 6,000 training examples in MNIST, and we learn a 10-class LR classifier.
Moreover, we assume 100 worker devices, randomly distribute the 6,000 examples to them, and assume 20 worker devices are compromised.Generating poisoned data: We assume an attacker has full knowledge about the training datasets on all worker devices.
Therefore, the attacker can use BGA to generate poisoned data based on the 6,000 examples.
In particular, we run the attack for 10 days on a GTX 1080Ti GPU, which generates 240 (240/6000 = 4%) poisoned examples.
We verified that these poisoned data can effectively increase the testing error rate if the LR classifier is learnt in a centralized environment.In particular, the poisoned data can increase the testing error rate of the LR classifier from 0.10 to 0.16 (60% relative increase) in centralized learning.
However, in federated learning, the attacker can only inject the poisoned data to the compromised worker devices.
We consider two scenarios on how the attacker distributes the poisoned data to the compromised worker devices: Single worker.
In this scenario, the attacker distributes the poisoned data on a single compromised worker device.Uniform distribution.
In this scenario, the attacker distributes the poisoned data to the compromised worker devices uniformly at random.We consider the two scenarios because they represent two extremes for distributing data (concentrated or evenly distributed) and we expect one extreme to maximize attack effectiveness.
Table 5 compares BGA with our attacks.
We observe that BGA has limited success at attacking Byzantine-robust aggregation rules, while our attacks can substantially increase the testing error rates.
We note that if the federated learning uses the mean aggregation rule BGA is still successful.
For instance, when the mean aggregation rule is used, BGA can increase the testing error rate by 50% when distributing the poisoned data to the compromised worker devices uniformly at random.
However, when applying our attacks for trimmed mean to attack the mean aggregation rule, we can increase the testing error rates substantially more (see the last two cells in the second row of Table 5).
We generalize RONI [4] and TRIM [30], which were designed to defend against data poisoning attacks, to defend against our local model poisoning attacks.
Both generalized defenses remove the local models that are potentially malicious before computing the global model in each iteration of federated learning.
One generalized defense removes the local models that have large negative impact on the error rate of the global model (inspired by RONI that removes training examples that have large negative impact on the error rate of the model), while the other defense removes the local models that result in large loss (inspired by TRIM that removes the training examples that have large negative impact on the loss).
In both defenses, we assume the master device has a small validation dataset.
Like existing aggregation rules such as Krum and trimmed mean, we assume the master device knows the upper bound c of the number of compromised worker devices.
We note that our defenses make the global model slower to learn and adapt to new data as that data may be identified as from potentially malicious local models.Error Rate based Rejection (ERR): In this defense, we compute the impact of each local model on the error rate for the validation dataset and remove the local models that have large negative impact on the error rate.
Specifically, suppose we have an aggregation rule.
For each local model, we use the aggregation rule to compute a global model A when the local model is included and a global model B when the local model is excluded.
We compute the error rates of the global models A and B on the validation dataset, which we denote as E A and E B , respectively.
We define E A − E B as the error rate impact of a local model.
A larger error rate impact indicates Defense results: Table 6 shows the defense results of ERR, FLR, and Union, where partial knowledge attacks are considered.
We use the default parameter setting discussed in Section 4.1, e.g., 100 worker devices, 20% of compromised worker devices, MNIST dataset, and LR classifier.
Moreover, we sample 100 testing examples uniformly at random as the validation dataset.
Each row of the table corresponds to a defense, e.g., Krum + ERR means that the master device uses ERR to remove the potentially malicious local models and uses Krum as the aggregation rule.
Each column indicates the attacker's assumed aggregation rule when performing attacks, e.g., the column "Krum" corresponds to attacks that are based on Krum.
We have several observations.
First, LFR is comparable to ERR or much more effective than ERR, i.e., LFR achieves similar or much smaller testing error rates than ERR.
For instance, Trimmed mean + ERR and Trimmed mean + LFR achieve similar testing error rates (0.17 vs. 0.18) when the attacker crafts the compromised local models based on Krum.
However, Trimmed mean + LFR achieves a much smaller testing error rate than Trimmed mean + ERR (0.12 vs. 0.21), when the attacker crafts the compromised local models based on trimmed mean.
Second, Union is comparable to LFR in most cases, except one case (Krum + LFR vs. Krum and Krum + Union vs. Krum) where Union is more effective.Third, LFR and Union can effectively defend against our attacks in some cases.
For instance, Trimmed mean + LFR (or Trimmed mean + Union) achieves the same testing error rate for both no attack and attack based on trimmed mean.
However, our attacks are still effective in other cases even if LFR or Union is adopted.
For instance, an attack, which crafts compromised local models based on Krum, still effectively increases the error rate from 0.14 (no attack) to 0.58 (314% relative increase) for Krum + LFR.
Fourth, the testing error rate grows in some cases when a defense is deployed.
This is because the defenses may remove benign local models, which increases the testing error rate of the global model.
Security and privacy of federated/collaborative learning are much less explored, compared to centralized machine learning.
Recent studies [29,40,44] explored privacy risks in federated learning, which are orthogonal to our study.Poisoning attacks: Poisoning attacks aim to compromise the integrity of the training phase of a machine learning system [5].
The training phase consists of two components, i.e., training dataset collection and learning process.
Most existing poisoning attacks compromise the training dataset collection component, e.g., inject malicious data into the training dataset.
These attacks are also known as data poisoning attacks) [3,8,13,19,27,30,33,43,45,50,51,56,61,62,65].
Different from data poisoning attacks, our local model poisoning attacks compromise the learning process.Depending on the goal of a poisoning attack, we can classify poisoning attacks into two categories, i.e., untargeted poisoning attacks [8,30,33,50,62,65] and targeted poisoning attacks [3,6,13,27,37,45,51,56].
Untargeted poisoning attacks aim to make the learnt model have a high testing error indiscriminately for testing examples, which eventually result in a denial-of-service attack.
In targeted poisoning attacks, the learnt model produces attacker-desired predictions for particular testing examples, e.g., predicting spams as non-spams and predicting attacker-desired labels for testing examples with a particular trojan trigger (these attacks are also known as backdoor/trojan attacks [27]).
However, the testing error for other testing examples is unaffected.
Our local model poisoning attacks are untargeted poisoning attacks.
Different from existing untargeted poisoning attacks that focus on centralized machine learning, our attacks are optimized for Byzantine-robust federated learning.
We note that Xie et al. [63] proposed inner product manipulation based untargeted poisoning attacks to Byzantine-robust federated learning including Krum and median, which is concurrent to our work.
Defenses: Existing defenses were mainly designed for data poisoning attacks to centralized machine learning.
They essentially aim to detect the injected malicious data in the training dataset.
One category of defenses [4,15,56,59] detects malicious data based on their (negative) impact on the performance of the learnt model.
For instance, Barreno et al. [4] proposed Reject on Negative Impact (RONI), which measures the impact of each training example on the performance of the learnt model and removes the training examples that have large negative impact.
Suciu et al. [56] proposed a variant of RONI (called tRONI) for targeted poisoning attacks.
In particular, tRONI measures the impact of a training example on only the target classification and excludes training examples that have large impact.Another category of defenses [20,30,35,55] proposed new loss functions, optimizing which obtains model parameters and detects the injected malicious data simultaneously.
For instance, Jagielski et al. [30] proposed TRIM, which aims to jointly find a subset of training dataset with a given size and model parameters that minimize the loss function.
The training examples that are not in the selected subset are treated as malicious data.
These defenses are not directly applicable for our local model poisoning attacks because our attacks do not inject malicious data into the training dataset.For federated learning, the machine learning community recently proposed several aggregation rules (e.g., Krum [9], Bulyan [42], trimmed mean [66], median [66], and others [14]) that were claimed to be robust against Byzantine failures of certain worker devices.
Our work shows that these defenses are not effective in practice against our optimized local model poisoning attacks that carefully craft local models on the compromised worker devices.
Fung et al. [23] proposed to compute weight for each worker device according to historical local models and take the weighted average of the local models to update the global model.
However, their method can only defend against label flipping attacks, which can already be defended by existing Byzantine-robust aggregation rules.
We propose ERR and LFR, which are respectively generalized from RONI and TRIM, to defend against our local model poisoning attacks.
We find that these defenses are not effective enough in some scenarios, highlighting the needs of new defenses against our attacks.
Other security and privacy threats to machine learning: Adversarial examples [5,57] aim to make a machine learning system predict labels as an attacker desires via adding carefully crafted noise to normal testing examples in the testing phase.
Various methods (e.g., [2,11,25,36,46,47,52,54,57]) were proposed to generate adversarial examples, and many defenses (e.g., [10,25,26,38,41,48,64]) were explored to mitigate them.
Different from poisoning attacks, adversarial examples compromise the testing phase of machine learning.
Both poisoning attacks and adversarial examples compromise the integrity of machine learning.
An attacker could also compromise the confidentiality of machine learning.
Specifically, an attacker could compromise the confidentiality of users' private training or testing data via various attacks such as model inversion attacks [21,22], membership inference attacks [40,49,53], and property inference attacks [1,24].
Moreover, an attacker could also compromise the confidentiality/intellectual property of a model provider via stealing its model parameters and hyperparameters [34,58,60].
We demonstrate that the federated learning methods, which the machine learning community claimed to be robust against Byzantine failures of some worker devices, are vulnerable to our local model poisoning attacks that manipulate the local models sent from the compromised worker devices to the master device during the learning process.
In particular, to increase the error rates of the learnt global models, an attacker can craft the local models on the compromised worker devices such that the aggregated global model deviates the most towards the inverse of the direction along which the global model would change when there are no attacks.
Moreover, finding such crafted local models can be formulated as optimization problems.
We can generalize existing defenses for data poisoning attacks to defend against our local model poisoning attacks.
Such generalized defenses are effective in some cases but are not effective enough in other cases.
Our results highlight that we need new defenses to defend against our local model poisoning attacks.Our work is limited to untargeted poisoning attacks.
It would be interesting to study targeted poisoning attacks to federated learning.
Moreover, it is valuable future work to design new defenses against our local model poisoning attacks, e.g., new methods to detect compromised local models and new adversarially robust aggregation rules.
We thank the anonymous reviewers and our shepherd Nikita Borisov for constructive reviews and comments.
This work was supported by NSF grant No.1937786.
nBulyan is based on Krum.
We apply our attacks for Krum to attack Bulyan.
Table 7b shows results of attacking Bulyan.
The dataset is MNIST, the classifier is logistic regression, m = 100, c = 20, θ = m − 2c (Bulyan selects θ local models using Krum), and γ = θ − 2c (Bulyan takes the mean of γ parameters).
Our results show that our attacks to Krum can transfer to Bulyan.
Specifically, our partial knowledge attack increases the error rate by around 150%, while our full knowledge attack increases the error rate by 165%.
B Deviation GoalThe deviation goal is to craft local models w 񮽙 1 , w 񮽙 2 , · · · , w 񮽙 c for the compromised worker devices via solving the following optimization problem in each iteration:where || · || 1 is L 1 norm.
We can adapt our attacks based on the directed deviation goal to the deviation goal.
For simplicity, we focus on the full knowledge scenario.
Krum: Similar to the directed deviation goal, we make two approximations, i.e., w 񮽙 1 = w Re − λ and the c compromised local models are the same.
Then, we formulate an optimization problem similar to Equation 2, except that w 񮽙 1 = w Re − λs is changed to w 񮽙 1 = w Re − λ.
Like Theorem 1, we can derive an upper bound of λ, given which we use binary search to solve λ.
After solving λ, we obtain w 񮽙 1 .
Then, we randomly sample c − 1 vectors whose Euclidean distances to w 񮽙 1 are smaller than ε as the other c − 1 compromised local models.
Trimmed mean: Theoretically, we can show that the following attack can maximize the deviation of the global model: we use any c numbers that are larger than w max, j or smaller than w min, j , depending on which one makes the deviation larger, as the jth local model parameters on the c compromised worker devices.
Like the directed deviation goal, when implementing the attack, we randomly sample the c numbers in the interval [w max, j , b · w max, j ] (when w max, j > 0) or [w max, j , w max, j /b] (when w max, j ≤ 0), or in the interval [w min, j /b, w min, j ] (when w min, j > 0) or [b · w min, j , w min, j ] (when w min, j ≤ 0), depending on which one makes the deviation larger.
Median: We apply the attack for trimmed mean to median.
Experimental results: Table 8 empirically compares the deviation goal and directed deviation goal, where MNIST and LR classifier are used.
For Krum, both goals achieve high testing error rates.
However, for trimmed mean and median, the directed deviation goal achieves significantly higher testing error rates than the deviation goal.
C Proof of Theorem 1We denote by Γ a w the set of a local models among the crafted c compromised local models and m−c benign local models that are the closest to the local model w with respect to Euclidean distance.
Moreover, we denote by˜Γby˜ by˜Γ a w the set of a benign local models that are the closest to w with respect to Euclidean distance.
Since w 񮽙 1 is chosen by Krum, we have the following:where D(·, ·) represents Euclidean distance.
The distance between w 񮽙 1 and the other c − 1 compromised local models is 0, since we assume they are the same in the optimization problem in Equation 2 when finding w 񮽙 1 .
Therefore, we have:According to the triangle inequality Since D(w 񮽙 1 , w Re ) = 񮽙λ · s񮽙 2 = √ d · λ, we have:The bound only depends on the before-attack local models.
Bulyan is based on Krum.
We apply our attacks for Krum to attack Bulyan.
Table 7b shows results of attacking Bulyan.
The dataset is MNIST, the classifier is logistic regression, m = 100, c = 20, θ = m − 2c (Bulyan selects θ local models using Krum), and γ = θ − 2c (Bulyan takes the mean of γ parameters).
Our results show that our attacks to Krum can transfer to Bulyan.
Specifically, our partial knowledge attack increases the error rate by around 150%, while our full knowledge attack increases the error rate by 165%.
The deviation goal is to craft local models w 񮽙 1 , w 񮽙 2 , · · · , w 񮽙 c for the compromised worker devices via solving the following optimization problem in each iteration:where || · || 1 is L 1 norm.
We can adapt our attacks based on the directed deviation goal to the deviation goal.
For simplicity, we focus on the full knowledge scenario.
Krum: Similar to the directed deviation goal, we make two approximations, i.e., w 񮽙 1 = w Re − λ and the c compromised local models are the same.
Then, we formulate an optimization problem similar to Equation 2, except that w 񮽙 1 = w Re − λs is changed to w 񮽙 1 = w Re − λ.
Like Theorem 1, we can derive an upper bound of λ, given which we use binary search to solve λ.
After solving λ, we obtain w 񮽙 1 .
Then, we randomly sample c − 1 vectors whose Euclidean distances to w 񮽙 1 are smaller than ε as the other c − 1 compromised local models.
Trimmed mean: Theoretically, we can show that the following attack can maximize the deviation of the global model: we use any c numbers that are larger than w max, j or smaller than w min, j , depending on which one makes the deviation larger, as the jth local model parameters on the c compromised worker devices.
Like the directed deviation goal, when implementing the attack, we randomly sample the c numbers in the interval [w max, j , b · w max, j ] (when w max, j > 0) or [w max, j , w max, j /b] (when w max, j ≤ 0), or in the interval [w min, j /b, w min, j ] (when w min, j > 0) or [b · w min, j , w min, j ] (when w min, j ≤ 0), depending on which one makes the deviation larger.
Median: We apply the attack for trimmed mean to median.
Experimental results: Table 8 empirically compares the deviation goal and directed deviation goal, where MNIST and LR classifier are used.
For Krum, both goals achieve high testing error rates.
However, for trimmed mean and median, the directed deviation goal achieves significantly higher testing error rates than the deviation goal.
We denote by Γ a w the set of a local models among the crafted c compromised local models and m−c benign local models that are the closest to the local model w with respect to Euclidean distance.
Moreover, we denote by˜Γby˜ by˜Γ a w the set of a benign local models that are the closest to w with respect to Euclidean distance.
Since w 񮽙 1 is chosen by Krum, we have the following:where D(·, ·) represents Euclidean distance.
The distance between w 񮽙 1 and the other c − 1 compromised local models is 0, since we assume they are the same in the optimization problem in Equation 2 when finding w 񮽙 1 .
Therefore, we have:According to the triangle inequality Since D(w 񮽙 1 , w Re ) = 񮽙λ · s񮽙 2 = √ d · λ, we have:The bound only depends on the before-attack local models.
