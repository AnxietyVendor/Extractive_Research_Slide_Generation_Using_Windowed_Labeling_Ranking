The last few years have witnessed increasing interest in the deployment of zero-knowledge proof systems, in particular ones with succinct proofs and efficient verification (zk-SNARKs).
One of the main challenges facing the wide deployment of zk-SNARKs is the requirement of a trusted key generation phase per different computation to achieve practical proving performance.
Existing zero-knowledge proof systems that do not require trusted setup or have a single trusted preprocess-ing phase suffer from increased proof size and/or additional verification overhead.
On the other other hand, although universal circuit generators for zk-SNARKs (that can eliminate the need for per-computation preprocessing) have been introduced in the literature, the performance of the prover remains far from practical for real-world applications.
In this paper, we first present a new zk-SNARK system that is well-suited for randomized algorithms-in particular it does not encode randomness generation within the arithmetic circuit allowing for more practical prover times.
Then, we design a universal circuit that takes as input any arithmetic circuit of a bounded number of operations as well as a possible value assignment, and performs randomized checks to verify consistency.
Our universal circuit is linear in the number of operations instead of quasi-linear like other universal circuits.
By applying our new zk-SNARK system to our universal circuit, we build MIRAGE, a universal zk-SNARK with very succinct proofs-the proof contains just one additional element compared to the per-circuit preprocessing state-of-the-art zk-SNARK by Groth (Eurocrypt 2016).
Finally , we implement MIRAGE and experimentally evaluate its performance for different circuits and in the context of privacy-preserving smart contracts.
Zero-knowledge proofs are a cryptographic primitive that enable an untrusted prover to prove the knowledge of a secret witness that satisfies certain properties to a skeptical verifier.
This can be quite useful in many applications including authentication, privacy-preserving computations and others.
Although the concept of zero-knowledge proofs was introduced multiple decades ago, it only started to get much attention in practice after recent advances in several aspects [1][2][3][4][5][6][7][8], which led to efficient implementations for a primitive called zk-SNARKs (zero-knowledge succinct non-interactive arguments of knowledge).
zk-SNARKs provide constant-size proofs and verification that is only linear in the size of public statement being proven, regardless of how expensive the computation is.
The promising performance properties of zk-SNARKs led to the development of various tools and improved back ends [5,[9][10][11][12], and enabled different kinds of applications including privacy-preserving transactions, certificate validation, image authentication and others [13][14][15][16][17][18].
However, using zk-SNARKs with constant-size proofs comes at a cost.
For practicality reasons, such constructions typically resort to non-standard cryptographic assumptions and require a trusted key generation phase for each different computation.
A compromised trusted setup process could lead to parties providing proofs for false statements while undetected.
To avoid such problems in practice, distributed protocols are used for CRS generation [19,20], which will be expensive to repeat for every type of computation.
These drawbacks have led to different lines of work on zero-knowledge proofs attempting to solve some or all of these issues, while providing good performance, e.g., [21][22][23][24][25][26][27][28].
While these works manage to alleviate the drawbacks of zk-SNARKs, they are not as efficient as zk-SNARKs with respect to the verification overhead and proof size.
For example, the proof size of these schemes can be tens or hundreds of kilobytes, while a typical zk-SNARK proof is only between 128 and 288 bytes depending on the assumptions [2,7].
These issues led to another line of work on universal zk-SNARK systems [4,[29][30][31], which aim to reach a middle ground to avoid the trusted setup per computation challenge, while maintaining the succinctness and efficient verification guarantees provided by efficient zk-SNARK constructions.
These systems still require a trusted setup, but such setup is done once for computations of a particular class, e.g., computations that have a certain bound on the number of their operations.
In the following section, we provide a brief discussion of the existing universal zk-SNARK systems.Universal zk-SNARK systems.
There are two flavors of universality in the context of zk-SNARK systems presented in literature.
The first is universality with respect to the common reference string (CRS), meaning that a CRS can be adapted without fixing a circuit.
The other is the universality of the circuit itself, in which a circuit receives the computation being verified as part of the input itself, and processes its logic.
While the first approach sounds more flexible and does not require fixing any circuit, the existing approaches under that category have practical limitations.
For example, the technique by Groth et al. [29] requires a quadratic CRS for supporting universal SNARKs.
In a more recent work, Sonic [31] presented a more practical universal zk-SNARK with updatable CRS, however (in "unhelped" mode) it increases the proof size by a factor of 7×, the verification effort by a factor of 4× and the prover's effort by a factor of 50× (assuming Groth's zk-SNARK [7] as a baseline).
Note that Sonic also provides a helped mode that has less proof computation overhead and a shorter proof, but this mode requires adding an untrusted third party to help with the computations.The advantages of the universal circuit approach is maintaining the succinct proof and the small number of pairings in the verification as enabled by zk-SNARKs, however, the most notable universal circuit approach, namely vnTinyRAM [4] is not efficient enough to support applications in practice.
vnTinyRAM's approach was shown to significantly increase the circuit size and prover's effort by multiple orders of magnitude [10].
In this paper, we aim to address such practical limitations by building MIRAGE, a new universal zk-SNARK.
In contrast to common belief, we show that the concept of universal circuits can be brought to practicality, through a modified zk-SNARK protocol and careful design of the universal circuit.
While there is a cost to be paid for being universal, we managed to apply our system to applications that could benefit from our construction, such as privacy-preserving auctions and crowdfunding for a small number of participants.
MIRAGE can be further scaled up using recent systems like DIZK [12].
Technical Highlights.
Next, we provide a brief overview of some technical aspects of MIRAGE.Separated zk-SNARKs.
We first explore how to enable efficient randomized checks in zk-SNARK circuits.
Randomized checks can make the verification logic much faster than regular verification circuits in cases like permutation verification and others.
Informally, while it is possible to ask the prover to generate randomness by committing to the witness, doing this naively would lead to having additional expensive commitment logic in the circuit.
To avoid that, we introduce separated zk-SNARKs that separate the witness values into ones that do not depend on the randomness and ones that do.
Then the randomness is produced by committing to the first set of values out of the circuit and using this randomness to produce the second set of values.
Due to this separation of the witness, our approach only increases the proof by one group element, and the verification effort by one pairing and two hash function calls, when compared to Groth's zk-SNARK [7].
Our protocol is not only useful in a universal-circuit context (as explained below), but also from a complexity theory perspective, comprising an efficient zk-SNARK for the MA complexity class.Linear-Size Universal Circuits.
A universal circuit is a circuit that receives the program to verify as input, besides the input values.
One essential element of the verification of universal circuits is checking permutations to ensure that variables with the same labels have consistent values across the circuit.
Previous approaches, e.g., vnTinyRAM [4], use permutation networks which has O(n log n) overhead.
We build a linear-size universal circuit based on an O(n) permutation verification circuit.
Informally, we use the fact that two vectors v and w of size n are a permutation of each other if and only if the polynomials ∏(x − v i ) and ∏(x − w i ) are equal, which can be verified by checking equality at a random point r. Furthermore, in order to further reduce the prover's effort, we address different circuit design issues, and present a circuit that has better utilization than previous work.
Our final universal zk-SNARK, MIRAGE, is derived by applying our separated zk-SNARK on our randomized, linear-size, universal circuit.Applications in Privacy-Preserving Smart Contracts.
We utilize MIRAGE in applications that require very succinct proofs and efficient verification, such as blockchain applications.
We evaluate MIRAGE in the context of privacy-preserving smart contracts (e.g., HAWK [16]) to address the trusted key generation per contract issue.
Using MIRAGE, a universal verification key will be hardcoded on the blockchain, and for every new computation, an untrusted computation specifier would only provide 32 bytes encoding the computation to be verified to a custom contract.
Verifying MIRAGE's proof on the chain would be very similar to verifying zk-SNARK proofs, which has been already implemented on Ethereum (our verifier would only be 1.4× expensive).
Besides the evaluation of this scenario, we present detailed evaluation for different kinds of circuits.Our contributions.
We now summarize our contributions:• We introduce separated zk-SNARKs, a zk-SNARK protocol that allows using randomized checks efficiently in circuits, which can be useful for both universal and non-universal contexts.
This only adds one group element to the proof in the generic group model, and adds one more pairing operation to the pairing operations done by the verifier in addition to other negligible operations in practice.
• We design a more efficient universal circuit that provides much better performance compared to the state-of-the-art by using random checks.
Given a bound N on the number of operations (additions and multiplications), our universal circuit is linear O(N) instead of O(N log N).
• We build a new universal zk-SNARK, MIRAGE, by combining the above and we evaluate it in the context of privacypreserving smart contracts, e.g., HAWK [16], addressing the trusted setup per contract problem that limits its usage in practice while maintaining verification efficiency.Limitations.
While MIRAGE significantly reduces the universal circuit overhead in comparison with vnTinyRAM and enables a higher scale of applications, the proof computation overhead is notably more expensive than the non-universal SNARK approach (See Section 6).
Additionally, although our system provides a more succinct proof and a more efficient verifier than Sonic, it does not provide updatable CRS.
Here, we discuss the existing zero-knowledge proof systems.
In addition, since our system is evaluated in the context of privacy-preserving smart contracts, we provide a brief background on smart contracts and their challenges.Zero-knowledge proof systems.
Table 1 gives an overview of representative zero knowledge proof constructions in the space.
The constructions can be classified into different categories with respect to the setup requirements:• Trusted setup per computation: This most notably includes the construction proposed by Gennaro et al. using quadratic arithmetic programs [1].
This construction was implemented, improved and extended in several later works [2,4,7,8].
A clear advantage of this approach is that the proof size is succinct/constant-size and the verification overhead depends only on the size of the statement being proven.
This made this kind of zero knowledge proofs more inviting for blockchain applications [13,14,16].
• Transparent setup: Several constructions were proposed to eliminate the trusted setup requirement of the previous constructions.
These include 1) Discrete log-based techniques, such as Bulletproofs [22] and the previous work by Bootle et al. [33].
2) Interactive oracle proofs techniques [34], such as Ligero [21], zk-STARKs [25] Aurora [26] and more recently Virgo [28].
These techniques rely on symmetric cryptography and are plausibly conjectured to have post-quantum security.
3) Interactive proof-based techniques [35].
Such techniques build upon several earlier works [36][37][38].
An example is the Hyrax system by Wahby et al. [24].
4) Latticebased techniques, such as the work by Baum et al. [32].
• Universal trusted setup: This includes other interactive proofbased techniques, such as the techniques proposed by Zhang et al. [23], and Xie et al. [27].
These techniques besides all techniques in the second category increase the verification overhead to an extent that might not be suitable for applications where proof size and verification overhead are a bottleneck.
To avoid the trusted setup per computation problem while maintaining the verification efficiency, vnTinyRAM [4] introduced a universal circuit that accepts the program to be verified besides the statement.
This was shown to increase the proving cost by orders of magnitude compared to the non-universal approach [10].
Groth et al. introduced a universal zk-SNARK with updatable common reference strings [29], however the size of the CRS in their setting is quadratic making it not practical.
Recently, LegoUAC, a zk-SNARK with a linear universal CRS was introduced [30], but it has polylogarithmic proofs.
On the other hand, Sonic provides an updatable zk-SNARK with constant size proofs [31].
Sonic can run in two modes: helped and unhelped.
In the helped mode, an additional untrusted party helps with making both proof computation and verification more efficient.
Table 2 provides a more detailed comparison between systems under the universal trusted setup category with constant proof sizes.
Comparison with vnTinyRAM [4].
MIRAGE's circuit is linear in the number of supported operations, while vnTinyRAM's circuit is quasi-linear.
Note that vnTinyRAM's construction accepts a program and a bound T on the number of execution steps, while our construction assumes that the desired computation is represented as an arithmetic circuit or a set of constraints.
While the model is different, the same bound in the complexity comparison of the circuit sizes is used, assuming T = Θ(N).
In Table 2, the concrete complexity of our prover is measured in terms of the number of additions and multiplications, but for vnTinyRAM, measuring the concrete complexity is different as it depends on the executed branches during runtime.
The cost is estimated conservatively based on the per-cycle gate count in vnTinyRAM [4], assuming the generic group model is used.
More comparison details are in Section 5.3.
Comparison with Sonic [31].
We mainly consider the unhelped mode of Sonic, as the availability of additional helper parties is not applicable in all contexts, especially if the computation being verified is not the same across many parties.
As Table 2 shows, our system is better with respect to the proof size and verification effort, and has competitive prover effort, when compared with Sonic in the unhelped case.
If the universal circuit is highly utilized, i.e., N = n + + n * , the prover in our case could have fewer exponentiations.
Note that the reported prover cost of our system in Table 2 uses a slightly modified version of the naive basic circuit presented in Section 4, that allows adding and multiplying constants cheaply.
This is why the bound N does not consider addition or multiplication of constants.
In Section 5, we also present Table 1: A comparison of the existing zero-knowledge proof systems.
A filled circle indicates no trusted setup, while a half filled circuit indicates a universal setup for a class of computations.
n denotes the total number of gates, n * denotes the number of multiplications, n + denotes the number of additions, u is the size of the statement, w is the witness size, N is an upper bound on the number of additions and multiplications and U is an upper bound on the statement size.
Assuming full circuit utilization for our construction in the naive case, N would be equal to n * + n + , and U would be equal to u. For Hyrax, Libra and Virgo, d is the circuit depth and g is the width of the circuit.
Untrusted Setup Proof Computation Proof Size Verification Comparison between current approaches for universal zk-SNARKs with constant-size proofs with respect to the non-universal scheme of Groth16 [7] as a baseline.
Besides the notation used in Table 1, m refers to the number of wires, d refers to the maximum size of committed polynomials in Sonic [31], EX refers to exponentiations, P refers to pairing operations and T refers to a bound on the number of computation steps in vnTinyRAM (T = Θ(N)).
The second group of rows correspond to schemes with universal CRS, while the last group of rows correspond to systems with universal circuits.
Assuming full circuit utilization for our construction in the naive case, N would be equal to n * + n + , and U would be equal to u.
In all universal schemes, the custom portion of the CRS is not generated by a trusted party.QAP-based [1, 2, 7] O(n * log n * ) O(1) O(u) Ligero [21] O(n * log n * ) O( √ n * ) O(n * ) zk-STARKs [25] O(n * log 2 n * ) O(log 2 n * ) O(log 2 n * ) Bulletproofs [22] O(n * ) O(log n * ) O(n * ) Hyrax [24] O(n + d · g log g) O( √ w + d log g) O( √ w + d log g) Aurora [26] O(n * log n * ) O(log 2 n * ) O(n * ) Baum et al. [32] O(n * log n * ) O( √ n * log n * ) O(n * ) Virgo [28] O(n + w log w) O(d log n + log 2 w) O(d log n + log 2 w) Libra [27] O(n) O(d log n) O(d log n) Groth et al. [29] O(n * log n * ) O(1) O(u) Sonic [31] O(n * log n * ) O(1) O(u) LegoUAC [30] O(n) O(log 2 n) O(u + log 2 n) vnTinyRAM [4] O(N log 2 N) O(1) O(u) This Work O(N log N) O(1) O(u) Uni.
Circ.
Size Prover's Overhead Proof Size Verification Assumptions Updatable?Universal CustomNon-universal [7] N/A O(n * + m) N/A 4n * + m − u EX 128 B 3 P + u EX GG Groth et al. [29] O(n 2 * ) O(n * + m − u) N/A O(n * + m − u) EX 128 B 5 P + u EX GG Sonic [31] O(d ) O(n * ) N/A 273n * EX 1152 B 13 P AGM, RO Sonic (Helped) O(d ) O(n * ) N/A 18n * EX 256 B 10 P AGM, RO vnTinyRAM [4] O(N log N) O(1) O(N log N) 5000T EX 128 B 3 P + u EX GG This work O(N) O(1) O(N) 90N + 25U EX (naive) 160 B 4 P + u EX GG, ROanother circuit design that can reduce the reported prover cost further for many applications.Comparison with concurrent work [39,40]: MARLIN provides a preprocessing zk-SNARK that has a universal and updatable CRS [39].
MARLIN has faster prover and verifier than Sonic, however its proof size is still 1 KB, and the reported experiments showed that its verifier's performance is about 2.6× worse than the Groth16 baseline, despite having fewer pairings.
Another work in the same line, PLONK [40], improves upon Sonic.
PLONK has a proof size of 448 to 512 bytes and a more efficient prover.
The estimated costs reported in PLONK [40] could suggest that its performance is comparable to MARLIN's.
In comparison, our proof size is 160 bytes, and the verifier's performance is only 1.4× worse than the Groth16 baseline, which makes MIRAGE's verifier more suitable for applications that require efficient verification.
On the other hand, MIRAGE's CRS is not updatable.Smart Contracts.
The emerging success of cryptocurrencies, most notably Bitcoin [41], has motivated several other applications to utilize the decentralized blockchain setting for supporting other functionalities.
This further lead to another generation of cryptocurrency systems that aimed at enabling users to customize the decentralized computation, by defining smart contracts.
Smart contracts are executable objects that can run autonomously on top of a blockchain and are automatically enforced.
Systems like Ethereum [42] enable users to program smart contracts using high-level languages and post their contracts to the chain.
Besides simple trans-action verification, the network in a smart contract system executes the user-specified code included in the smart contract.
This clearly leads to a privacy issue, as all values used by the computation will be seen by all miners.
HAWK [16] aims to address the privacy problem by using zero knowledge proofs.
For example, to support a privacypreserving decentralized auction, the involved parties and the auction manager interact through a protocol whose correct execution can be verified by a smart contract that does not learn anything about the users' bids or the winner.
HAWK relies on QAP-based zk-SNARKs in their implementation as they provide succinct proofs and efficient verification.
However, one implication of using this kind of zero-knowledge proofs is the trusted setup needed per computation.
This limits the usage of HAWK's approach in practice.
In our work, we show how to avoid this problem through our universal circuit and efficient zk-SNARK protocol for randomized verification.
In this section, we provide a summary of the definitions and the protocols we use or modify.
Definition 1 Quadratic Arithmetic Program (QAP) [1,2] A QAP Q over field F q contains three sets of m + 1 polynomials V = {v i (x)}, W = {w i (x)},Y = {y i (x)}, for i = 0, . . . , m, and a target polynomial t(x).
Let C be a circuit with m wires (a wire can be an input to the circuit or an output of a multiplication gate) out of which u wires are I/O wires (c 1 , . . . , c u ).
Then we say that Q computes C if: (c 1 , . . . , c u ) ∈ F u q is a valid assignment of C's inputs and outputs, if and only if there exist coefficients (c u+1 , . . . , c m ) such that t(x) divides p(x), where p(x) is the polynomial(v 0 (x)+ m ∑ i=1 c i v i (x))(w 0 (x)+ m ∑ i=1 c i w i (x))−y 0 (x)− m ∑ i=1 c i y i (x) .
zk-SNARKs (zero-knowledge succinct non-interactive arguments of knowledge) have algorithms (Setup, Prove, Verify).
In summary Setup outputs prover and verification keys, on input a a circuit C. Algorithm Prove outputs a zero-knowledge proof of knowledge that circuit C is satisfiable for a fixed public statement (I/Os).
Finally, Verify verifies that proof, given a public statement.
For a zk-SNARK, we want perfect completeness, knowledge soundness and zero-knowledge to hold.
Perfect completeness means that an honest prover that knows the witness to a satisfiable statement can provide a verifying proof.
Knowledge soundness means that, given a verifying proof for a public statement provided by a PPT adversary A, there exists an extractor that can retrieve a valid witness by inspecting A's tape.
Finally, zero-knowledge means that a proof provided by an honest prover leaks nothing more than the validity of the statement.
The formal definitions of the above three properties (and the ones we use in our proofs) can be found in Definition 2 of Groth's zk-SNARK [7].
We summarize the protocol proposed by Groth [7] in the generic group model, using the notation we use in this paper.Protocol 1 The Groth16 Protocol [7] • {vrk C , prk C } ← Setup(C, 1 λ ): Let C be an arithmetic circuit with u public input and output values from F q , i.e., u is the statement size.
Build a QAP Q = (t(x),V,W,Y ) of size m and let n be the degree of t(x).
Let I mid = {u + 1, . . . , m}.
Let e be a bilinear map e :G 1 × G 2 → G T ,and let g 1 be a generator of G 1 and g 2 be a generator ofG 2 .
Choose α, β, γ, δ, s ← F q .
Construct the public proving key prk C as follows:• g α 1 , g β 1 , g δ 1 , g β 2 , g δ 2 • {g s i 1 } n−1 i=0 , {g s i 2 } n−1 i=0• {g(βv i (s)+αw i (s)+y i (s))/δ 1 } i∈I mid• {gs i t(s)/δ 1 } n−2 i=0Construct the verification key vrk C as• g α 1 , g β 2 , g γ 2 , g δ 2 , • {g (βv i (s)+αw i (s)+y i (s))/γ 1 } u i=0• π ← Prove(C, prk C , stmt): Given public statement stmt which includes the values {c i } u i=1 , the prover infers the values of the remaining wires in the circuit {c i } m i=u+1 and samples two random values κ 1 and κ 2 from F q .
The prover then computes h(x) = p(x) t(x) , and computes the proof as• π A = g α+v(s)+κ 1 δ 1 • π B = g β+w(s)+κ 2 δ 2 • π C = g (h(s)t(s)+I mid (s))/δ 1 .
π κ 2 A .
B κ 1 1 .
g −κ 1 κ 2 δ 1 where • v(x) = ∑ m i=0 c i v i (x) • w(x) = ∑ m i=0 c i w i (x) • B 1 = g β+w(s)+κ 2 δ 1 • I mid (x) = ∑ i∈I mid c i (βv i (x) + αw i (x) + y i (x))Proof π contains π A , π B and π C .
• {0, 1} ← Verify(vrk C , stmt, π): Given the proof and the verification key, the verifier does the checke(π A , π B ) = e(g α 1 , g β 2 ).
e(g Ψ io (s)/γ 1 , g γ 2 ).
e(π C , g δ 2 ) ,whereΨ io (x) = ∑ u i=0 c i (βv i (x) + αw i (x) + y i (x)) and where c 0 = 1 and (c 1 , . . . , c u ) is the public statement stmt being proved.
We consider the class of languages that can be efficiently verified given a randomized verifier with public coins.
Concretely, assume the class of MA statements (from Merlin-Arthur) which can be viewed as the randomized analogue of N P.
In particular it contains languages L that come with a probabilistic polynomial-time verification algorithm L(x,w), where x in the statement and w is the witness.
The requirement is that if x ∈ L then there is a witness w such that the probability that L(x, w) accepts is at least 2/3.
If x / ∈ L, for all witnesses w, L(x,w) accepts with probability at most 1/3.
It is crucial that the coins of L(x,w) are chosen independently of wotherwise, a cheating prover can compute a witness w and related randomness that will make L(x,w) accept with probability > 1/3.
The above soundness bound can be replaced with one exponentially small in |x|, |w| (e.g., 2 −λ ) and the correctness bound can be made 1, without changing the class.
Clearly, MA contains N P and P. Interestingly, there are problems both in MA and P whose MA verification procedure is much faster than the P verification procedure.
For example, checking primality has a slow deterministic test [43] but a fast randomized test [44].
Similarly, checking that a vector is a permutation of another vector has an O(n log n) deterministic test but an O(n) randomized test (form polynomials where the elements of the vectors are roots and check equality at a random point).
For practical purposes this is very important.
In particular, our paper defines a language L that contains pairs (C, p) where C is an arbitrary arithmetic circuit of n * multiplication gates and n + addition gates, p is a value assignment on a subset of C's wires and (C, p) ∈ L iff there exist an assignment p on the rest of C's wires such that (p, p ) is a valid assignment for C. Clearly, L is in N P, but we also show that L has a much faster verification procedure.
Given a language L in MA with randomized verification procedure L(x,w), we can write down L(x,w) as a deterministic procedure L(x,w,r), where r ∈ {0, 1} λ are the random coins used in L(x,w).
A baseline way to construct a zeroknowledge argument for MA from any zk-SNARK for NP, is as follows.
First, we ask the prover to commit to witness w using a hiding and binding commitment com w .
Then, the verifier chooses random coins r and sends them to the prover.
Finally, the prover runs the SNARK proving algorithm for the composite statement "w is a valid opening for com w and L(x,w,r) accepts."
Since the commitment scheme is hiding and the SNARK is zero-knowledge, the verifier learns nothing about w from the interaction.
Assuming the commitment scheme has a "knowledge" property (enhancing it with a zeroknowledge proof-of-knowledge, if necessary), the soundness of the protocol can be proven in a straight-forward manner by extracting the pre-image of com w and the witness used in the circuit of L.
If they are different, this can be used to break the commitment binding property.
Else, since com w was computed before seeing r, the probability that the extracted witness is not a valid witness for x, is negligible by the soundness property of the MA argument.If |r| is at most polylogarithmic in |w|, this protocol is a succinct zero-knowledge argument.
The downside of this approach is that it required "opening" com w inside the circuit being argued with the SNARK, which may introduce a significant overhead in practice.
In the rest of this section, we describe a more efficient way to build zero-knowledge arguments for MA by modifying the zk-SNARK of Groth [7].
Recall that in a typical zk-SNARK based on quadratic arithmetic programs, the wire indices of the circuit being verified are divided in two categories.
The ones that correspond to the public statement being proved usually referred to as IOrelated indices and the ones that correspond to the non-IOrelated indices that we call I mid (these contain the witness indices too).
A separated zk-SNARK is a zk-SNARK with the difference that it is parametrized by a set of indices J ⊂ I mid .
More importantly, the proof π of a separated zk-SNARK can be written as [π , π J ] where π J can be computed with access only to the values of the indices in J and the public parameters.
We now give a separated zk-SNARK implemented off Groth's original zk-SNARK [7].
We highlight the changes with blue.
We prove its knowledge soundness in the generic group model and its zero-knowledge (as per [7, Def.
2]).
• {vrk C(J) , prk C(J) } ← Setup(C(J), 1 λ ): Let C be an arithmetic circuit with u public input and output values from F q , i.e., u is the statement size.
Build a QAP Q = (t(x),V,W,Y ) of size m and let n be the degree of t(x).
Let I mid = {u + 1, . . . , m}, J ⊆ I mid and I = I mid − J.Choose α, β, γ, δ, δ , s ← F q .
Construct the public proving key prk C(J) as follows:• g α 1 , g β 1 , g δ 1 , g δ 1 , g β 2 , g δ 2 • {g s i 1 } n−1 i=0 , {g s i 2 } n−1 i=0 • {g (βv i (s)+αw i (s)+y i (s))/δ 1 } i∈I • {g (βv i (s)+αw i (s)+y i (s))/δ 1 } i∈J • {g s i t(s)/δ 1 } n−2 i=0Construct the verification key vrk C(J) as• g α 1 , g β 2 , g γ 2 , g δ 2 , g δ 2 • {g (βv i (s)+αw i (s)+y i (s))/γ 1 } u i=0• π ← Prove(C(J), prk C(J) , stmt): Given public statement stmt which includes the values {c i } u i=1 , the prover infers the values of the remaining wires in the circuit {c i } m i=u+1 and samples three random values κ 1 , κ 2 and κ 3 from F q .
The prover then computes h(x) = p(x) t(x) , and computes the proof as• π A = g α+v(s)+κ 1 δ 1 • π B = g β+w(s)+κ 2 δ 2 • π C = g (h(s)t(s)+I(s))/δ 1 .
π κ 2 A .
B κ 1 1 .
g −κ 1 κ 2 δ−κ 3 δ 1 • π D = g κ 3 δ 1 g J(s)/δ 1 where • v(x) = ∑ m i=0 c i v i (x) • w(x) = ∑ m i=0 c i w i (x) • B 1 = g β+w(s)+κ 2 δ 1 • I(x) = ∑ i∈I c i (βv i (x) + αw i (x) + y i (x)) • J(x) = ∑ i∈J c i (βv i (x) + αw i (x) + y i (x))Write proof π as [π , π J ] where π contains π A , π B and π C and π J contains π D .
• {0, 1} ← Verify(vrk C(J) , stmt, π): Given the proof and the verification key, the verifier checks to see if e(π A , π B ) equalse(g α 1 , g β 2 ).
e(g Ψ io (s)/γ 1 , g γ 2 ).
e(π C , g δ 2 ).
e(π D , g δ 2 ) ,whereΨ io (x) = ∑ u i=0 c i (βv i (x) + αw i (x) + y i (x)) and where c 0 = 1 and (c 1 , . . . , c u ) is the public statement stmt being proved.Proof sketch for knowledge soundness.
Knowledge soundness holds in the generic group model.
1 Following the proof technique in [7], we express π A , π B , π C and π D as g A , g B , g C and g D , where A, B, C and D are 6-variate Laurent polynomials in α, β, γ, δ, δ and s and, due to the generic group model, can be expressed as linear combinations of the elements in vrk C(J) , prk C(J) .
Substituting in the verification equation, we have that two Laurent polynomials should be equal.
This gives rise to equations that relate to the coefficients of distinct monomials on both sides, allowing us to extract the QAP coefficients.
The proof is in the full version of the paper.Proof for zero-knowledge.
The simulator can choose group elements for π A , π B and π C by randomly choosing their exponents and then set π D to be the element satisfying the verification equation.
Since κ 1 , κ 2 , κ 3 are chosen uniformly at random in our construction and π D is the only group element satisfying the verification equation, zero-knowledge follows.
Now we build an efficient zk-SNARK for a language L in MA using the above separated construction.
Let L(x,w,r) be the de-randomized verifier algorithm for L, as introduced before.
We view L as a circuit with IO-related indices being x and r and non-IO-related indices I mid being the rest of the wire indices.
Define J ⊂ I mid to be the set of all wire indices of L(x,w,r) that do not depend on the randomness r-note that J includes the wires corresponding to the witness w. Let us call those wires deterministic wires.To give an intuition about that, consider the MA language that contains pairs of n-sized vectors (a, b) such that(a, b) ∈ L iff b is a sorted version of a.
The MA verificationprocedure involves two checks (note that in this case there is no explicit witness that is given as input):1.
(deterministic comparison check) b i ≤ b i+1 for all i = 1, . . . , n − 1; 2.
(randomized permutation check) ∏ n i=1 (a i + r) = ∏ n i=1 (b i + r).
In this case, the set of deterministic wires J will correspond only to the wires that are used to implement the comparisons (whose values only depend on the statement).
We are now ready to describe the protocol.
The common input of the verifier and the prover is a statement x; the prover additionally has a corresponding witness w.
The goal of the prover is to persuade the verifier, in zero-knowledge, that x ∈ L where L is an MA language with verification procedure L(x,w,r).
Let J be the set of deterministic wires for L(x, w, r) and let {vrk L(J) , prk L(J) } ← Setup(L(J), 1 λ ) be the parameters generated from the Setup of the separated zk-SNARK.
Our protocol is interactive and proceeds as follows.
1.
Given x ∈ L and the respective witness w, the prover computes the values of the deterministic wires J with respect to L(x,w,r) and then computes π J using the public parameters prk L(J) .
The prover sends π J to the verifier;2.
The verifier picks a random r and sends to the prover;3.
The prover computes the values for the wires in I mid −J using randomness r.
At that point he knows all the wire values for L(x,w,r) and runs π ← Prove(L(J), prk L(J) , x||r).
Parse π as [π π J ] and send π to the verifier;4.
The verifier computes π = [π π j ] and runs {0, 1} ← Verify(vrk L , x||r, π), using the π J received in Step 1 and the randomness r sent at Step 2.
As the randomness r is "public" since L is in MA (as opposed to secret randomness used locally by the verifier), the interaction can be removed with the Fiat-Shamir heuristic, assuming a collision-resistant hash function hash modelled as a random oracle.
• Given x and w, the prover computes the values of the deterministic wires J with respect to L and then computes π J using the public parameters prk L(J) .
Then the prover computes r = hash(x||π J ).
Then the prover computes the values for the wires in I mid − J using randomness r.
At that point, the prover knows all the wire values for L(x,w,r) and runs π ← Prove(L, prk L(J) , x||r).
Then the prover sends π to the verifier;• The verifier parses π as [π π J ], computes r = hash(x||π J ) and runs {0, 1} ← Verify(vrk L , x||r, π).
As in Section 3.1, if r is of size only polylogarithmic in |w| (and polynomial in |x| and security parameter λ), then the resulting protocol is a succinct non-interactive argument.
The prover's runtime is asymptotically the same as that of Groth's protocol˜Oprotocol˜ protocol˜O(|L|).
In this section, we adapt the protocol described above in the context of universal circuits.
We will use a simplified version of our universal circuit to make the representation less involved.
(Section 5 presents the circuit design in detail).
The goal is to define a simple universal language L univ that captures the operations of any circuit C that has at most n * multiplications and n + additions, and its statement size is bounded by n s .
We use the following notation: Let l i and l i refer to an index (label) of a variable in our construction.
Let z i and z i refer to the values of the variables with indices l i and l i respectively.
An entry is a pair of label and value, e.g., (l i , z i ).
Let spec be a vector that specifies the functionality of a custom circuit C, i.e., spec C = (l 1 , l 2 , . . . , l n s +3n * +3n + ).
The first n s elements will correspond to the labels of the statement variables, then the following 3n * and 3n + elements will be the labels of the variables used in multiplication and addition constraints, respectively.
Let stmt be a vector that includes the values of the statement variables, i.e., stmt = (z 1 , z 2 , . . . , z n s ).
(Figure 1 illustrates an example) Define the language L univ as follows: An instance (spec C , stmt) ∈ L univ if and only if stmt is a satisfying assignment for the specification of C, i.e.,• There exists a vector (z n s +1 , z n s +2 , . . . , z n s +3n * +3n + ) such that z i+2 = z i × z i+1 for all i ∈ {n s + 1, . . . , n s + 3n * − 2}, and z i+2 = z i +z i+1 for all i ∈ {n s +3n * +1, . . . , n s +3n * + 3n + − 2}.
• There exists a vector of (l i , z i ) entries where i ∈ {1, . . . ,n s + 3n * + 3n + }, such that -It is a permutation of the entries {(l i , z i )} i∈{1,...,n s +3n * +3n + } .
-(Consistency) For all i ∈ {1, . . . , n s + 3n * + 3n + − 1}, l i ≤ l i+1, and if l i = l i+1 , then z i must be equal to z i+1 .
To check membership in L univ , a randomized verifier applies all the correctness and consistency constraints above, and checks the permutation constraint as follows.
Given two uniformly selected random values r 1 and r 2 from F q , the following must hold:n s +3n * +3n + ∏ i=1 ((l i + r 2 z i ) − r 1 ) = n s +3n * +3n + ∏ i=1 ((l i + r 2 z i ) − r 1 )To show that L univ ∈ MA 2 , we argue about the complexity of the verifier and the probability of failure.
Let C univ be a circuit that encodes the verification logic above.
Note that the size of the circuit will be linear in the size of the specification.
A prover would send the circuit C univ to the verifier along with the values of all z i 's and (l i , z i ) entries.
The verifier can then run the circuit given the prover's input, the specification spec C , and two independently generated random values r 1 , r 2 .
It's easy to observe that the verifier runs in a polynomial time.Completeness.
If (spec C , stmt) ∈ L univ , i.e., the prover is honest, it is easy to see that verification will always succeed with probability 1.
Soundness.
If (spec C , stmt) / ∈ L univ , i.e., the prover is dishonest, to calculate the probability of successful verification, we can compute an upper bound based on the probability of the following two events:• The prover could cheat if for any i ∈ {1, 2, . . . , n s + 3n * + 3n + } and j ∈ {1, 2, . . . , n s +3n * +3n + }, the random value r 2 was equal to the root of the polynomialp i j (x) = l i − l j + x(z i − z j ), i.e., r 2 = l j −l i z i −z j when z i = z j .
Let p 1 denote the probability of this event.
It can be shown that p 1 ≤ (n s +3n * +3n + ) 2 |F q | .
• The prover could cheat if the random value r 1 is a root of the polynomial p( witnesses values).
Appendix A illustrates how to apply our Protocol 2 for C univ in detail.
The following points highlight few details about the mapping and the differences:x) = ∏ n s +3n * +3n + i=1 ((l i + r 2 z i ) − x) − ∏ n s +3n * +3n + i=1 ((l i +r 2 z i )−x• The statement of C univ is changed to also include {l i } i∈{1,...,n s +3n + +3n * } besides {l i } i∈{1,...,n s +3n + +3n * } and {z i } i∈{1,...,n s } , as the values of {l i } are known during the specification of the custom circuit.
• The set J in Protocol 2 will include the set of indices corresponding to the wires carrying the witness values of {z i } i∈{n s ,...,n s +3n + +3n * } , {z i } i∈{1,...,n s +3n + +3n * } .
Note that the prover will commit to both the values corresponding to the set J and the statement, which includes {z i } i∈{1,...,n s } .
• To minimize the verifier's effort, we introduce an untrusted derive phase for computing the encoding of {l i } and {l i } (or the circuit specification in the general case).
This happens only once per a custom new circuit, and can be both computed and verified in linear time.
The encoding of the specification is just one group element (32 bytes) in our setting (See vk spec in Appendix A).
• Finally, for efficiency purposes, when computing the hash of the statement and the witness commitment, instead of computing Hash(x||π j ) directly as described in Section 3, we use the encoding of the statement x that is computed during the zk-SNARK verification algorithm.
In this section, we describe the approaches we investigated for designing the universal circuit.
In the rest of the discussion, we use the term opcode to denote the type of an instruction or operation.
The cost of any component is measured in terms of the number of constraints (multiplication gates) needed to implement or verify its logic in the circuit.
Note that the cost of verifying a single instruction equals the cost of verifying the operation itself (based on the logic corresponding to the opcode) plus the cost of verifying the consistency of the values of its entries with respect to the rest of the circuit (the permutation and consistency check logic).
For example, for a multiplication or addition instruction as defined before, the cost of verifying operation correctness is one constraint, while the cost of verifying the consistency of the values of the entries equals 15 constraints (5 per entry).
The circuit design we considered in the previous sections included only two types of operations: addition and multiplication operations.
This version can be slightly modified to be only a single-opcode circuit, with an additional binary input with each instruction to choose which operation should be activated (this additional input will belong to the spec C vector, and will be set during derivation).
This will only add one more constraint to the instruction cost, while enabling more flexible ranges of addition or multiplication operations.
Additionally, to avoid the cost of multiplying or adding constants, this opcode can also be extended using additional input that are specified during the derivation.
More concretely, the spec C vector will also include additional values b j , c j,1 , c j,2 , c j,3 , c j,4 , for each instruction j besides the labels of the variables l i , l i+1 , l i+2 .
For each instruction j, the circuit applies the following logic,• If b j = 1, verify that z i+2 = (c j,1 + c j,2 z i )(c j,3 + c j,4 z i+1 ).
• If b j = 0, verify that z i+2 = c j,1 + c j,2 z i + c j,3 + c j,4 z i+1 .
We call the additional variables b j , c j,1 , c j,2 , c j,3 , c j,4 functionality selectors.
Note that they will also be set at the time of specifying the computation like l i and l i .
Although the single-opcode circuit can represent any set of arithmetic constraints, it would result into high overhead when representing different kinds of basic operations:1) Cost of intermediate variables.
In many circuits/programs, intermediate variables are used only once.
Using the naive single-opcode version described earlier to compute a sum or product of n variables, or compute a dot product of two n-dimensional vectors for example will lead to repeated entries of intermediate variables (See l 9 and l 11 in Figure 1 for an example).
We will reduce the overhead of this by enabling instructions to consider the output of the previous operation that is specified in the circuit as an additional operand.
For example, to compute a dot product of two n-elements vectors, nearly n instructions will be consumed instead of 2n instructions.
Instead of specifying a computation c = a 1 b 1 + a 2 b 2 + a 3 b 3 , as a 1 b 1 = t 1 , a 2 b 2 = t 2 , a 3 b 3 = t 3 ,t 1 + t 2 = d 1 , d 1 + t 3 = c, we enable expressions to optionally include the last operand from the previous operation if needed a 1 b 1 = t 1 , a 2 b 2 + t 1 = t 2 , a 3 b 3 + t 2 = c (See opcode 1 in the next subsection).2) Bit operations and binary constraints.
In many zk-SNARK circuits in practice, unpacking or splitting a variable into bits is a necessary operation.
It's used for range checking, comparisons, division/mod operations, bitwise operations, exponentiations and others.
For example, verifying a bitwise XOR operation would involve decomposing or splitting values into bits.
For a variable x, this would require checking equations of the form b i b i = b i and checking x = ∑ 2 i b i in the universal circuit, which will consume several instructions and several variable entries for each single bit, therefore using the single-opcode version described earlier will lead to a high amplification factor for such frequent checks.
Instead, we combine all similar bit operations within other opcodes (See opcodes 2 and 3).
Opcode 2 does not introduce entries for bits, and handles bit operations and checks within its circuit.
Opcode 3 avoids the repeated entries for bit constraints, and is for explicit extraction of bits in the universal circuit.3) Using randomness.
As our approach enables the usage of random values in the circuit, these random values could be used to verify other functionalities that are cheaper to verify using a randomized check.
In our circuit, we utilized this for implementing the verification of read/write memory accesses when the indices are not known during the specification time (See opcode 4 in the next subsection).
When designing a multi-opcode circuit, there is a trade-off between the circuit utilization and the efficiency of individual basic operations.
Adding an opcode per every possible basic function will lead to many unused constraints if the program being evaluated has a skewed opcode distribution.
On the other hand, using a single opcode version will guarantee high utilization, but will be less effective in practice.
Finding the optimal point is a problem of independent interest, as it will require careful workload characterization (See Section 7), depending on the application set being considered.In our design, we used the following criteria: 1) We add a new opcode whenever any of the basic operations is significantly amplified using the already available opcodes.
By basic operations, we mean the common operators provided by high-level programming languages.
This includes arithmetic operations, bitwise operations (e.g., bitwise xor, shift, rotate, .
.
etc), bit extraction, integer comparison, load and write operations to random memory locations, .
.
etc.
If a certain basic operation can be represented using few constant number of calls to existing opcodes, we do not add a new opcode for that operation.
2) We combine similar basic operations together in one opcode when they share computation, or if they have additional small overhead.
For example, instead of having separate opcodes for basic bitwise operations like bitwise-and, bitwise-xor and bitwise-or as in previous work, we observe that these computations can share many of their intermediate computations using a minimized circuit, and therefore, we use only one opcode for them.Figures 2 and 3 in Appendix B illustrate our design of the multi-opcode circuit.
In the following list, we provide a high-level description for each opcode.
Further details about the functionality that can be verified by each opcode can be found in Table 6 in Appendix B.• Opcode 1: This is an enhanced version of the basic opcode in the single-opcode circuit.
It aims to combine addition, multiplication constraints, individual bit operations (OR, AND, XOR), and equality testing.
It can also include the result from the previous opcode instruction as an additional operand to reduce the cost of intermediate operations.
Using a minimized circuit, our opcode 1 circuit would cost 26 constraints (11 constraints for verifying the operation, and 15 constraints for the consistency of entry values).
• Opcode 2 (Integer Bitwise Operations): Using opcode 1 to encode bitwise operations will have a high cost since each individual bit check and operation will have its own instruction.
Therefore, we introduce another opcode.
Given three n-bit integers a, b and c, this opcode verifies that c is either the bitwise-xor, bitwise-or or bitwise-and of a and b, or any of their bitwise-negations (12 possibilities in total).
In our circuit, we set n to be 32 (Note that in the evaluation section, we will evaluate short and long-integer computations that do not align with 32-bit arithmetic).
This opcode can also be used for range checking, e.g., verify that two operands a and b are bounded without introducing entries for the individual bits, which is useful for comparison, division, etc.To illustrate the savings in the case of a bitwise-OR of two 32-bit values, using opcode 1 only would consume 96 instructions for splitting the first two operands into bits (64 instructions for booleanity checks and 32 for bits weighted sums), and 32 instructions for the OR operations, totalling 26 × (96 + 32) = 3328 constraints.
On the other hand, using a single opcode 2 instruction will cost about 135 constraints.
Note that the bit checks required by the splitting operations within this opcode are done within its circuit and does not rely on other opcodes.
• Opcode 3 (Split/Pack Operations, shift/rotation, weighted sums): This opcode can used to explicitly extract bit or byte values, or pack them into one value.
It can also be used to support shifting/rotation operations, and weighted sums of native field elements.
Note that using opcode 1 or opcode 2 for all bit extractions of a single element will not result into an efficient implementation.
For example, to split a 32-bit value into bits, using opcode 1 will cost 48 instructions (1248 constraints), while using opcode 2 will require masking several times (32 instructions, costing 4320 constraints).
Note that the circuit of opcode 2 does not introduce entries for the bits used within its circuit.
On the other hand, the circuit of opcode 3 requires 330 constraints (while enabling other functionalities, like rotation, weighted sums, etc).
• Opcode 4 (Memory accesses): This opcode is used for accessing arrays during runtime when the index operand has an unknown value.
Previous compilers use different approaches for implementing this functionality [3,4,[9][10][11].
In the general case, a permutation network approach is used to verify permutations in previous work, which costs O(n log n) constraints, where n denotes the number of accesses.
In our circuit, we rely on the randomness values we have in the circuit to get an O(n) circuit instead (this uses a similar idea to the global permutation check).
Representation of other basic operations.
Compared to the universal circuit in vnTinyRAM's implementation [46], we do not have explicit opcodes for other basic operations like comparisons, divisions and others.
These operations can be implemented using few calls to some of the opcodes above.
For example, performing a 32-bit unsigned integer comparison can be implemented using opcodes 1 and 2.
Note that in our evaluation setting, we consider computations that heavily rely on basic operations not explicitly expressed in our opcode system, or operations that do not align with 32-bit arithmetic, such as sorting 16-bit elements, RSA (2048-bit integers) and AES (8-bit integers).
Opcode distribution.
One remaining design decision is how many times an opcode type should appear in the circuit.
Compared to previous work, we have more flexibility in choosing the distribution of the opcodes as instructions are not verified in order (See Figure 1 and Section 5.3).
We noticed that having the same number of instances per each opcode type will lead to high waste if the custom computation heavily relies on the cheapest opcode.
As a heuristic way to balance these factors, we consider the cost of the individual instruction circuit corresponding to each opcode and the number of basic operation categories supported by it.
For a given bound on the total number of constraints of the universal circuit B, an even share is given to each of the first three opcodes, while half of that share is given to the last opcode as it is only specific to a single category (memory operations) while the other opcodes can support different arithmetic and Boolean operations (See Table 6).
More concretely, if the circuit corresponding to each opcode costs x 1 , x 2 , x 3 , x 4 constraints respectively, each will appear around 2B7x 1 , 2B 7x 2 , 2B 7x 3 , B 7x 4times.
We believe that choosing the ideal distribution should be done based on application analysis, and is left to future work (Section 7).
vnTinyRAM follows the von Neumann paradigm, where both the program and the data are stored in the same address space [4].
In vnTinyRAM, the program instructions are loaded and verified in the circuit, and features like runtime code generation is supported.
While we could integrate the techniques of MIRAGE directly to make vnTinyRAM's circuit linear, as improving the permutation check will make checking both instructions and data more efficient, we chose to focus on the circuit representation of computation and not to have explicit support or specific opcodes for loading/generating instructions during runtime.
This is because of two main observations: 1) Loading instructions at runtime implies an ordered processing of instructions in the circuit, which can lead to high overhead and much less utilization of the available gates.
This is because when loading unknown instructions during runtime, the circuit of each step would have to account for all possible operation types.
2) Looking into many applications involving zk-SNARKs, we are not aware of common use cases that heavily rely on runtime code generation.
Furthermore, we believe there is a higher need to universal circuits that provide better performance in practice.Our universal circuit targets the circuit representation of programs and differs in the following ways: 1) It uses a randomized check to verify the consistency across the circuit.
This has a linear cost compared to the quasi-linear cost of vnTinyRAM.
2) It does not require verifying operations in the order they were executed.
This implies a much better utilization of the circuit, as each computation step known at the specification time only pays for the opcode(s) it uses.
3) On the other hand, targeting the circuit representation of programs has implications.
For example, mapping an if-else statement to our construction will consume instructions for both branches.
Note that features like jump instructions and runtime code generation could be supported by specifying a vnTinyRAM-like circuit as input to our circuit.
Although this would rely on more efficient randomized checks, instructions resolved during runtime will have a much higher cost compared to the instructions known at the specification time.
We implemented our protocol on top of libsnark [46], and developed a front-end java library that generates the universal circuit, and allows a programmer to specify a computation.
In the following, we discuss the performance impact of using our construction for universal circuits in different settings.Comparison with non-universal and universal circuits.
First, we start by a comparison with vnTinyRAM in terms of Table 3: Comparison between our work and earlier non-universal and universal circuits with respect to the scale of supported applications when the number of constraints (the total circuit size) is nearly the same the scale of the applications that can be supported given the same circuit size.
We use the results reported in the implementation of the vnTinyRAM specification by [10] as a baseline.For our circuits, we use the multi-opcode circuits, where the opcodes are distributed according to the criteria presented earlier.
We consider two applications: matrix multiplication and merge sort which use different basic operations and random memory accesses.
We also compare with non-universal circuit generation tools [10,11].
As shown in Table 3, our universal circuit supports largerscale problems than vnTinyRAM, while reducing the gap between the universal and the non-universal approaches.
With respect to the number of basic operations supported under the same circuit sizes, our circuit enables orders of magnitude higher scale compared to the vnTinyRAM circuit.
Note that part of our circuit is also still available to be used by other operations, as illustrated by the ratio of available instructions.Cost of universality.
Next, we report the amplification cost of certain primitives that use different kinds of operations and does not necessarily operate in the 32-bit integer space.
For this part of the evaluation, the cost of the used instructions are only counted to calculate the exact amplification cost.Besides matrix multiplication and merge sort, we consider three cryptographic primitives, and compare with the optimized non-universal circuits reported by xJsnark [11].
Note that the chosen primitives span basic operations not directly covered by the opcodes described in Section 5.
For example, the RSA-2048 modular exponentiation circuit performs mod operations in the circuit modulo a long integer.
Also, the AES-128 circuit performs random memory accesses and operates on 8-bit words, while our universal circuit opcodes are for 32-bit words.
This required effort to get a concise mapping from the AES operations to the instructions of our universal circuit.
Note that the optimizations of previous compilers [11] assume a cost model that is only relevant in the custom circuit scenario.
Table 4 provides the comparison.
While there is an amplification factor between 3 and 26× depending on the application, in comparison vnTinyRAM is expected to have 1 to 2 order of magnitude higher overhead as shown earlier.Privacy-preserving Smart Contracts.
Finally, we evaluate our system in the context of a practical application involving smart contracts.
In particular, we address the trusted setup per contract challenge of the HAWK system [16].
In HAWK, the users' circuits do not change depending on the computation, while the manager's circuit does change per computation.
The manager's circuit in the HAWK system verifies the correct execution of a pre-specified contract code, but on private data.
This circuit relies on commitment and symmetric encryption gadgets besides the function being supported.We consider two applications from the HAWK paper in our evaluation, namely privacy-preserving auctions and crowdfunding in the case of six participants (In Section 7, we discuss how to scale the system up to more participants).
For this evaluation, we fix our universal multi-opcode circuit size to 10 million constraints.
We used libsnark's Groth16 implementation as the back end for the baseline.
The experiments were conducted on an EC2 machine (c5d.9xlarge instance), using a single processor, and consuming 36 GB of memory at most during the keygen/prove stage.
Table 5 illustrates the results.
We observe the following:• The untrusted key derivation phase that happens per contract in our construction just adds one group element to the verifier's storage (the contract in our scenario), while the non-universal approach will generate a separate larger verification key per contract in a trusted manner.
• Our universal approach only adds a small overhead to the verification time and the proof size.
Table 5: Comparison between our system and HAWK [16] in the context of privacy-preserving auction and crowdfunding applications.
The number of participants in each application is set to 6 (1 manager, and 5 bidders/participants • There is about 30× amplification factor in the proof generation time.
The reason this factor is larger than the previously reported overhead in Table 4 is because nearly half of the instructions in the universal circuit were not used (mainly the opcode types that were not used heavily by the commitments or the applications being evaluated).
• Comparison with existing work: The proof size of Sonic [31] is 1152 bytes in the unhelped mode (compared to 160 bytes in our case), and the verifier's effort is 3× worse than ours.
For the prover, the amplification factor of the number of exponentiations in Sonic [31] is more than 50× in the unhelped prover's case, compared to 30× in our case, when the circuit is highly utilized.
In the future, we will also evaluate other applications that require trusted setup per user-defined computations.
In this paper, we presented MIRAGE a zk-SNARK protocol that allows the verification of randomized algorithms efficiently.
Compared to baseline zk-SNARKs, our protocol increases the verification overhead by one pairing, and increases the proof size by one group element in the generic group model.
We used our protocol to build an efficient universal circuit, and illustrated savings in different contexts, including privacy-preserving smart contracts.
However, our work leaves several open problems for future work, which we discuss next.
Although we significantly reduced the cost of universal circuits in this paper and illustrated the impact on different applications, there is still a cost that has to be paid for being universal.
In this subsection, we discuss some directions that could be considered to alleviate the scalability challenges.
Distributed systems for ZK proof computation.
As large zk-SNARK circuits lead to high memory consumption at the prover's side, one way to avoid such practical limitation is to use a distributed system to compute the zk-SNARK proof using multiple instances.
A recent system, DIZK [12], was shown to enable computations of zk-SNARK proofs for circuits that have hundreds of millions of constraints, which would fit for very large instantiations of our universal circuit.
This could scale the number of participants in the application we evaluated by two orders of magnitude.
Recursive SNARKs.
Another approach to increase the scalability and efficiency of the prover, while also enabling lightweight clients, would be to divide the circuit into different parts, e.g., based on opcodes, prove the correctness of each separately, and then use one layer of recursive SNARKs [6,47] to compress the proofs into one and verify the global consistency.
This will have the benefit of reducing the memory requirements of the prover, and also letting the prover only pay for the opcodes that are heavily used by the computation.
Cryptographic opcodes.
As most zk-SNARK circuits include cryptographic gadgets for verifying knowledge of secrets, or for computing commitments, etc., it could be useful to include opcodes for well-known cryptographic functions.
For instance, in the context of HAWK privacy-preserving smart contract system [16], most of the manager's circuit does not depend on the computation being verified.
If the universal circuit supports additional commitment opcodes, this would significantly reduce the cost of the cryptographic operations required by the protocol, and the universality cost will only include the cost of representing the custom user-defined logic.
This would allow increasing the number of participants.
The library we developed to specify computations is currently a low-level library, which means that the programmer is expected to have knowledge of the opcodes when representing the computation in order to get an optimized performance and develop a secure representation.
This is in some sense similar to the background requirements needed when developing zk-SNARK circuits using low-level gadget libraries, e.g, [46].
We plan to develop a high-level tool that can compile high-level description of the computation to an optimized specification, given the opcodes.
Some techniques from existing high-level frameworks [5,10,11] could be used, however the cost model in our setting is different.
Additionally, our modified zk-SNARK construction enables the usage of randomness in the circuit to check permutations and potentially many other types of computations more efficiently.
In Section 5.2, we used a nearly uniform way to set the number of each opcode provided in the circuit.
Although the opcodes we provide can represent most basic operations, their distribution might not always be the most optimal for all possible kinds of applications.
A future direction would be to obtain a realistic distribution based on workload characterization of computations in different domains.
If the universal circuit targets an application-specific domain like smart contracts, then studying existing smart contracts and analyzing the distributions of the basic operations could provide better insight.
In this section, we describe the zk-SNARK protocol for the simple universal circuit C univ that was presented in Section 4 in detail.
Before describing the protocol, we introduce additional notations.
Let φ l , φ l , φ z , φ z and φ r be mapping functions that map the variable types and indices in our universal circuit construction to the actual wire indices used in Protocol 2 in Section 3, e.g., φ l (i)gets the index of the wire carrying the value of l i .
Define the following sets:• I L = {φ l (i)} i∈{1,.
.
,n s +3n * +3n + } • I L = {φ l (i)} i∈{1,.
.
,n s +3n * +3n + } • I spec = I L ∪ I L (Note:in the general case of our multiopcode universal circuit (Section 5), this will also include the functionality selectors of the instructions).
• I Z io = {φ z (i)} i∈{1,.
.
,n s }• I Z w = {φ z (i)} i∈{n s +1,.
.
,n s +3n * +3n + }• I Z = {φ z (i)} i∈{1,.
.
,n s +3n * +3n + }• I R = {φ r (i)} i∈{1,2}• I aux represents all other intermediate wire indices in the universal circuit, i.e.,I aux = {k : k ∈ {1, .
.
, m} ∧ k / ∈ I L ∪ I L ∪ I Z io ∪ I Z w ∪ I Z ∪ I R },where m is the total number of wires in the universal circuit.The public statement of the universal circuit C univ itself includes the specification of the custom circuit, the custom statement, r 1 and r 2 .
In other words, the statement of the universal circuit will be the following set of wires (I spec ∪ I Z io ∪ I R ).
The set J in Protocol 2 will be equal to I Z w ∪ I Z .
Protocol 3 A zk-SNARK for C univ • Universal Circuit Setup: PARAMETERS ← PARAMGEN(C , 1 λ )This phase generates a universal circuit C univ that captures the operations of any circuit C ∈ C .
The key generation phase PARAMGEN(C , 1 λ ) will call the setup algorithm in Protocol 2 {vrk C univ , prk C univ } ← Setup(C univ , 1 λ ), while setting J = I Z w ∪ I Z ,I = I aux , i.e., Choose α, β, γ, δ, δ , s ← F q .
Construct the public proving key prk C univ as follows:• g α 1 , g β 1 , g δ 1 , g δ 1 , g β 2 , g δ 2 • {g s i 1 } i∈{0,.
.
,d−1} , {g s i 2 } i∈{0,.
.
,d−1} • {g s i t(s)/δ 1 } i∈{0,.
.
,d−2} • {g (βv k (s)+αw k (s)+y k (s))/δ 1 } k∈I Zw ∪I Z • {g (βv k (s)+αw k (s)+y k (s))/δ 1 } k∈I auxConstruct the verification key vrk C univ as• g α 1 , g β 1 , g β 2 , g γ 2 , g δ 2 , g δ 2 • {g (βv k (s)+αw k (s)+y k (s))/γ 1 } k∈I spec ∪I Z io ∪I R Set PARAMETERS = {vrk C univ , prk C univ }• Derive (Custom circuit Specification):{VRK C , PRK C } ← DERIVE(C, PARAMETERS)A party sets the values of each l i and l i (besides any functionality selectors in the general case) according to the specification of the custom circuit C.
The party then computes vrk C based on the items in vrk C univ .
More specifically, vrk C will include the following, , where c k is the value of the wire k in the universal circuit.The derivation of vrk C does not need to happen in a trusted manner.
It will be straightforward to verify the computation of the first set in linear time.
The proving key of the custom circuit C will be the same as the proving key of the universal circuit besides vk spec , i.e., prk C = prk C univ ∪ {vk spec }.
• Prove π ← PROVE(C, {z i } i∈{1,.
.
,n s +3n * +3n + } , PRK C ):-The prover samples three random values κ 1 , κ 2 and κ 3 from F q .
κ 1 and κ 2 will be later used as in the original version of the protocol for zero-knowledge, and κ 3 will be used to make our commitment zero-knowledge.
-The prover commits to the values of {z i } and its permutation {z i }, via computing:• cm 1 = ∏ • cm = g δκ 3 1 cm 1 cm 2 -The prover computes the random values r 1 and r 2 using the previous commitment, e.g., r 1 = Hash(0||vk spec ||cm) and r 2 = Hash(1||vk spec ||cm), and continues evaluating the circuit.
The prover then computes h(x) = p(x) t(x) , and computes the proof as:• π a = g -The verifier then does the following check:e(π a , π b ) = e(g α 1 , g β 2 )e(vk spec .
ν.ψ, g γ 2 )e(π c , g δ 2 )e(π d , g δ 2 )Note that e(g α 1 , g β 2 ) can be hardcoded in advance.
The total number of pairings done by the verifier for each instance is 4 pairings, and the proof size is 3 elements in G 1 and 1 element in G 2 , i.e. our protocol adds 1 element to the proof and 1 pairing to the verification equation.
Figures 2 and 3 illustrates the detailed design of the multiopcode circuit presented in Section 5.
Table 6 illustrates which basic operations each opcode can be used to verify.
OpCode 3 (Split/Pack Operations) (repeated n 3 times, u 3 = 38)• Operates on the following (for all i ∈ {n s + ∑ j<3 n j u j + 1, n s + ∑ j<3 n j u j + 39, .
.
, n s + ∑ j≤3 n j u j − 37} ):-Element (Bit) vector: e = ((l i , z i ), (l i+1 , z i+1 ), ..., (l i+31 , z i+31 ))-Byte vector: ((l i+32 , z i+32 ), (l i+33 , z i+33 ), ..., (l i+35 , z i+35 ))-Packed elements: ((l i+36 , z i+36 ), (l i+37 , z i+37 ))• Functionality selectors for each instruction (instruction indices omitted for brevity)-Force bit assertions: check b -Coefficient vector 1: s 1 = (c 1,1 , c 1,2 , ..., c 1,32 )-Coefficient vector 2: s 2 = (c 2,1 , c 2,2 , ..., c 2,32 )• Circuit:-Assert z j (1 − z j )check b = 0 for all i ≤ j ≤ i + 31 -Assert z i+36 = e · s 1 , Assert z i+37 = e · s 2-Assert z i+32+ j = ∑ k∈{1+8 j,...,8+8 j} c 1,k .
z i+k−1 for all j ∈ {0, 1, 2, 3}• Usage notes: Packing or splitting into bits can be done by setting s 1 to contain powers of two, and setting check b = 1.
Shifting and rotation (static parameters) can be done by setting s 2 to be a permutation of powers of two.
• Other modes: This opcode can be used to compute weighted sums of native field elements.OpCode 4 (Runtime memory access) (repeated n 4 times, u 4 = 3)• Operates on: ((l i , z i ), (l i+1 , z i+1 ), (l i+2 , z i+2 )) for all i ∈ {n s + ∑ j<4 n j u j + 1, n s + ∑ j<4 n j u j + 4, .
.
, n s + ∑ j≤4 n j u j − 2}• Circuit:-Parse z i , z i+1 , z i+2 as isW rite k , index k , value k , for all k = (i − (n s + ∑ j<4 n j u j + 1))/3 -Add the tuple rec k = (opCounter k = k, isW rite k , index k , value k ) to the memory consistency check circuitMemory consistency check circuit• The subcircuit operates on the tuples rec k for all k = {0, 1, .
.
, n 4 − 1} defined in OpCode 4.
• The subcircuit accepts additional witness inputs from the prover rec k = (opCounter k , isW rite k , index k , value k ) for all k = {0, 1, .
.
, n 4 − 1}.
(Note that the prover will commit to this input in the first stage before knowing the randomness)• Permutation Verification:-Compute p 1 = ∏ k (r 2 − (1, r 1 , r 2 1 , r 3 1 ) · rec k ) -Compute p 2 = ∏ k (r 2 − (1, r 1 , r 2 1 , r 3 1 ) · rec k ) -Assert p 1 = p 2• Consistency Verification: This applies the memory consistency checks similar to TinyRAM [3].
• Permutation Verification:-Compute p 1 = ∏ i (r 2 − (z i + l i r 1 )) for all i ∈ {1, 2, .
.
, n s + ∑ j≤4 n j u j } -Compute p 2 = ∏ i (r 2 − (z i + l i r 1 )) for all i ∈ {1, 2, .
.
, n s + ∑ j≤4 n j u j } -Assert p 1 = p 2• Consistency Verification:-Assert (1 − (l i − l i−1 ))(z i − z i−1 ) = 0 for all i ∈ {2, 3, .
.
, n s + ∑ j≤4 n j u j } (Note since l i are set by the computation specifier, they will be sorted and increasing by steps of 1.)
Figure 3: A detailed description of our universal circuit with multiple opcodes (Part 2).
See Section 5 and Table 6 for an intuition and high-level description for each opcode circuit design.
Note: Functionality selector inputs are added to the spec C vector (Section 4), and set at the computation specification stage.
This work was supported in part by DARPA under grant N66001-15-C-4066 and the Center for Long-Term Cybersecurity (CLTC).
Charalampos Papamanthou was supported by NSF awards #1514261 and #1652259 as well as by NIST.
Dimitrios Papadopoulos was supported by Hong Kong RGC under grant ECS-26208318.
Any opinions, findings, and conclusions or recommendations expressed in this material are those of the authors and do not necessarily reflect the views of NSF, NIST, DARPA, CLTC or Hong Kong RGC.
