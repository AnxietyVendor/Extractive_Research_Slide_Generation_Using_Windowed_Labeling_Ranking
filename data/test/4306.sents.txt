Many companies provide neural network prediction services to users for a wide range of applications.
However, current prediction systems compromise one party's privacy: either the user has to send sensitive inputs to the service provider for classification, or the service provider must store its proprietary neural networks on the user's device.
The former harms the personal privacy of the user, while the latter reveals the service provider's proprietary model.
We design, implement, and evaluate DELPHI, a secure prediction system that allows two parties to execute neural network inference without revealing either party's data.
DELPHI approaches the problem by simultaneously co-designing cryptography and machine learning.
We first design a hybrid cryptographic protocol that improves upon the communication and computation costs over prior work.
Second, we develop a planner that automatically generates neural network architecture configurations that navigate the performance-accuracy trade-offs of our hybrid protocol.
Together, these techniques allow us to achieve a 22× improvement in online prediction latency compared to the state-of-the-art prior work.
Recent advances in machine learning have driven increasing deployment of neural network inference in popular applications like voice assistants [Bar18] and image classification [Liu+17b].
However, the use of inference in many such applications raises privacy concerns.
For example, home monitoring systems (HMS) such as Kuna [Kun] and Wyze [Wyz] use proprietary neural networks to classify objects in video streams of users' homes such as cars parked near the user's house, or faces of visitors to the house.
These models are core to these companies' business and are expensive to train.To make use of these models, either the user has to upload their streams to the servers of the HMS (which then evaluate the model over the stream), or the HMS has to store its model on the user's monitoring device (which then performs the classification).
Both of these approaches are unsatisfactory: the first requires users to upload video streams containing sensitive information about their daily activities to another party, while the second requires the HMS to store its model on every device, thus allowing users and competitors to steal the proprietary model.To alleviate these privacy concerns, a number of recent works have proposed protocols for cryptographic predic- tion over (convolutional) neural networks [Gil+16; Moh+17; Liu+17a; Juv+18] by utilizing specialized secure multi-party computation (MPC) [Yao86; Gol+87].
At a high level, these protocols proceed by encrypting the user's input and the service provider's neural network, and then tailor techniques for computing over encrypted data (like homomorphic encryption or secret sharing) to run inference over the user's input.
At the end of the protocol execution, the intended party(-ies) learn the inference result; neither party learns anything else about the other's input.
Fig. 1 illustrates this protocol flow.
Unfortunately, these cryptographic prediction protocols are still unsuitable for deployment in real world applications as they require the use of heavy cryptographic tools during the online execution.
These tools are computationally intensive and often require a large amount of communication between the user and the service provider.
Furthermore, this cost grows with the complexity of the model, making these protocols unsuitable for use with state-of-the-art neural network architectures used in practice today.
For example, using a state-of-the-art protocol like GAZELLE [Juv+18] to perform inference for state-of-the-art deep neural networks like ResNet-32 [He+16] requires ∼ 82 seconds and results in over 560 MB communication.
Our contribution.
In this paper, we present DELPHI, a cryptographic prediction system for realistic neural network architectures.
DELPHI achieves its performance via a careful co-design of cryptography and machine learning.
DELPHI contributes a novel hybrid cryptographic prediction protocol, as well as a planner that can adjust the machine learning algorithm to take advantage of the performance-accuracy tradeoffs of our protocol.
Our techniques enable us to perform cryptographic prediction on more realistic network architectures than those considered in prior work.
For example, using DEL-PHI for cryptographic prediction on ResNet-32 requires just 3.8 seconds and 60 MB communication in the online phase, improving upon GAZELLE by 22× and 9× respectively.
We now describe at a high level the techniques underlying DELPHI's excellent performance.Performance goals.
Modern convolutional neural networks consist of a number of layers, each of which contains one sublayer for linear operations, and one sub-layer for non-linear operations.
Common linear operations include convolutions, matrix multiplication, and average pooling.
Non-linear operations include activation functions such as the popular ReLU (Rectified Linear Unit) function.Achieving cryptographic prediction for realistic neural networks thus entails (a) constructing efficient subprotocols for evaluating linear and non-linear layers, and (b) linking the results of these subprotocols with each other.Prior work.
Almost all prior protocols for cryptographic prediction utilize heavyweight cryptographic tools to implement these subprotocols, which results in computation and communication costs that are much higher than the equivalent plaintext costs.
Even worse, many protocols utilize these tools during the latency-sensitive online phase of the protocol, i.e., when the user acquires their input and wishes to obtain a classification for it.
(This is opposed to the less latencysensitive preprocessing phase that occurs before the user's input becomes available).
For example, the online phase of the state-of-the-art GAZELLE protocol uses heavy cryptography like linearly homomorphic encryption and garbled circuits.
As we show in Section 7.4, this results in heavy preprocessing and online costs: for the popular network architecture ResNet-32 trained over CIFAR-100, GAZELLE requires ∼ 158 seconds and 8 GB of communication during the preprocessing phase, and ∼ 50 seconds and 5 GB of communication during the preprocessing phase, and ∼ 82 seconds and 600 MB of communication during the online phase.
To achieve good performance on realistic neural networks, DELPHI builds upon techniques from GAZELLE to develop new protocols for evaluating linear and non-linear layers that minimize the use of heavy cryptographic tools, and thus minimizes communication and computation costs in the preprocessing and online phases.
We begin with a short overview of GAZELLE's protocol as it is the basis for DELPHI's protocols.Starting point: GAZELLE.
GAZELLE [Juv+18] is a stateof-the-art cryptographic prediction system for convolutional neural networks.
GAZELLE computes linear layers using an optimized linearly-homomorphic encryption (LHE) scheme [Elg85; Pai99; Reg09; Fan+12] that enables one to perform linear operations directly on ciphertexts.
To compute nonlinear layers, GAZELLE uses garbled circuits [Yao86] to compute the bitwise operations required by ReLU.
Finally, because each layer in a neural network consists of alternating linear and non-linear layers, GAZELLE also describes how to efficiently switch back-and-forth between the two aforementioned primitives via a technique based on additive secret sharing.As noted above, GAZELLE's use of heavy cryptography in the online phase leads to efficiency and communication overheads.
To reduce these overheads, we proceed as follows.Reducing the cost of linear operations.
To reduce the online cost of computing the linear operations, we adapt GAZELLE to move the heavy cryptographic operations over LHE ciphertexts to the preprocessing phase.
Our key insight is that the service provider's input M to the linear layer (i.e. the model weights for that layer) is known before user's input is available, and so we can use LHE to create secret shares of M during preprocessing.
Later, when the user's input becomes available in the online phase, all linear operations can be performed directly over secret-shared data without invoking heavy cryptographic tools like LHE, and without requiring interactions to perform matrix-vector multiplications.The benefits of this technique are two-fold.
First, the online phase only requires transmitting secret shares instead of ciphertexts, which immediately results in an 8× reduction in online communication for linear layers.
Second, since the online phase only performs computations over elements of prime fields, and since our system uses concretely small 32-bit primes for this purpose, our system can take advantage of state-of-the-art CPU and GPU libraries for computing linear layers; see Section 7.2 and Remark 4.2 for details.
Reducing the cost of non-linear operations.
While the above technique already significantly reduces computation time and communication cost, the primary bottleneck for both remains the cost of evaluating garbled circuits for the ReLU activation function.
To minimize this cost, we use an alternate approach [Gil+16; Liu+17a; Moh+17; Cho+18] that is better suited to our setting of computing over finite field elements: computing polynomials.
In more detail, DELPHI replaces ReLU activations with polynomial (specifically, quadratic) approximations.
These can be computed securely and efficiently via standard protocols [Bea95].
Because these protocols only require communicating a small constant number of field elements per multiplication, using quadratic approximations significantly reduces the communication overhead per activation, without introducing additional rounds of communication.
Similarly, since the underlying multiplication protocol only requires a few cheap finite field operations, the computation cost is also reduced by several orders of magnitude.
Concretely, the online communication and computation costs of securely computing quadratic approximations are 192× and 10000× smaller (respectively) than the corresponding costs for garbled circuits.However, this performance improvement comes at the cost of accuracy and trainability of the underlying neural network.
Prior work has already established that quadratic approximations provide good accuracy in some settings [Moh+17; Liu+17a; Gho+17; Cho+18].
At the same time, both prior work [Moh+17] and our own experiments indicate that in many settings simply replacing ReLU activations with quadratic approximations results in severely degraded accuracy, and can increase training time by orders of magnitude (if training converges at all).
To overcome this, we develop a hybrid cryptographic protocol that uses ReLUs and quadratic approximations to achieve good accuracy and good efficiency.Planning an efficient usage of the hybrid cryptographic protocol.
It turns out that it is not straightforward to determine which ReLU activations should be replaced with quadratic approximations.
Indeed, as we explain in Section 5, simply replacing arbitrary ReLU activations with quadratic approximations can degrade the accuracy of the resulting network, and can even cause the network to fail to train.So, to find an appropriate placement or network configuration, we design a planner that automatically discovers which ReLUs to replace with quadratic approximations so as to maximize the number of approximations used while still ensuring that accuracy remains above a specified threshold.The insight behind our planner is to adapt techniques for neural architecture search (NAS) and hyperparameter optimization (see [Els+19; Wis+19] for in-depth surveys of these areas) to our setting.
Namely, we adapt these techniques to discover which layers to approximate within a given neural network architecture, and to optimize the hyperparameters for the discovered network.
See Section 5 for details.The overall system.
DELPHI combines the above insights into a cohesive system that service providers can use to automatically generate cryptographic prediction protocols meeting performance and accuracy criteria specified by the provider.
In more detail, the service provider invokes DELPHI's planner with acceptable accuracy and performance thresholds.
The planner outputs an optimized architecture that meets this goal, which DELPHI then uses to instantiate a concrete cryptographic prediction protocol that utilizes our cryptographic techniques from above.This co-design of cryptography and machine learning enables DELPHI to efficiently provide cryptographic prediction for networks deeper than any considered in prior work.
For example, in Section 7 we show that using DELPHI to provide inference for the popular ResNet-32 architecture requires only 60 MB communication and 3.8 seconds.
There are two parties in the system setup: the client and the service provider (or server).
In the plaintext version of our system, the service provider provides prediction as a service using its internal models via an API.
The client uses this API to run prediction on its own data by transferring its data to the service provider.
The service provider runs prediction using the appropriate neural network, then sends the prediction result back to the client.
In DELPHI, the two parties execute a secure prediction together by providing their own inputs.
The service provider's input is the neural network, while the client's input is its private input used for prediction.
DELPHI's threat model is similar to that of prior secure prediction works such as GAZELLE [Juv+18] and MiniONN [Liu+17a].
More specifically, DELPHI is designed for the two-party semi-honest setting, where only one of the parties is corrupted by an adversary.
Furthermore, this adversary never deviates from the protocol, but it will try to learn information about the other parties' private inputs from the messages it receives.
DELPHI's goal is to enable the client to learn only two pieces of information: the architecture of the neural network, and the result of the inference; all other information about the client's private inputs and the parameters of the server's neural network model should be hidden.
Concretely, we aim to achieve a strong simulation-based definition of security; see Definition 4.1.
Like all prior work, DELPHI does not hide information about the architecture of the network, such as the dimensions and type of each layer in the network.
For prior work, this is usually not an issue because the architecture is independent of the training data.
However, because DELPHI's planner uses training data to optimally place quadratic approximations, revealing the network architecture reveals some information about the data.
Concretely, in optimizing an -layer network, the planner makes binary choices, thus reveals at most bits of information about the training data.
Because is concretely small for actual networks (for example, = 32 for ResNet32), this leakage is negligible.
This leakage can be further mitigated by using differentially private training algorithms [Sho+15; Aba+16] DELPHI, like most prior systems for cryptographic prediction, does not hide information that is revealed by the result of the prediction.
In our opinion, protecting against attacks that exploit this leakage is a complementary problem to that solved by DELPHI.
Indeed, such attacks have been successfully carried out even against systems that "perfectly" hide the model parameters by requiring the client to upload its input to the server [Fre+14; Ate+15; Fre+15; Wu+16b; Tra+16].
Furthermore, popular mitigations for these attacks, such as differential privacy, can be combined with DELPHI's protocol.
We discuss these attacks and possible mitigations in more detail in Section 8.2.
DELPHI's architecture consists of two components: a hybrid cryptographic protocol for evaluating neural networks, and a neural network configuration planner that optimizes a given neural network for use with our protocol.
Below we provide an overview of these components, and then demonstrate how one would use these in practice by describing an end-to-end workflow for cryptographic prediction in home monitoring systems (HMS).
Hybrid cryptographic protocol.
DELPHI's protocol for cryptographic prediction consists of two phases: an offline preprocessing phase, and an online inference phase.
The offline preprocessing phase is independent of the client's input (which regularly changes), but assumes that the server's model is static; if this model changes, then both parties would have to re-run the preprocessing phase.
After preprocesing, during the online inference phase, the client provides its input to our specialized secure two-party computation protocol, and eventually learns the inference result.
We note that our protocol provides two different methods of evaluating non-linear layers: the first offers better accuracy at the cost of worse offline and online efficiency, while the other degrades accuracy, but offers much improved offline and online efficiency.Planner.
To help service providers navigate the trade off between performance and accuracy offered by these two complementary methods to evaluate non-linear layers, DELPHI adopts a principled approach by designing a planner that generates neural networks that mix these two methods to maximize efficiency while still achieving the accuracy desired by the service provider.
Our planner applies neural architecture search (NAS) to the cryptographic setting in a novel way in order to automatically discover the right architectures.Example 2.1 (HMS workflow).
As explained in Section 1, a home monitoring system (HMS) enables users to surveil activity inside and outside their houses.
Recent HMSes [Kun; Wyz] use neural networks to decide whether a given activity is malicious or not.
If it is, they alert the user.
In this setting privacy is important for both the user and the HMS provider, which makes DELPHI an ideal fit.
To use DELPHI to provide strong privacy, the HMS provider proceeds as follows.The HMS provider first invokes DELPHI's planner to optimize its baseline all-ReLU neural network model.
Then, during the HMS device's idle periods, the device and the HMS server run the preprocessing phase for this model.
If the device detects suspicious activity locally, it can run the online inference phase to obtain a classification.
On the basis of this result, it can decide whether to alert the user or not.Remark 2.2 (applications suitable for use with DELPHI).
Example 2.1 indicates that DELPHI is best suited for applications where there is ample computational power available for preprocessing, and where inference is latency-sensitive, but is not performed frequently enough to deplete the reserve of preprocessed material.
Other examples of such applications include image classification in systems like Google Lens [Goo].
In this section, we provide a high-level description of the cryptographic building blocks used in DELPHI; this high-level description suffices to understand our protocols.
We provide formal definitions of security properties in Appendix A, and only provide high level intuitions here.Garbled circuits.
Garbled circuits (GC), introduced in the seminal work of Yao [Yao86], are a method of encoding a boolean circuit C and its input x such that, given the encoded circuit and the encoded input, an evaluator can use a special evaluation procedure to obtain the output C(x) while ensuring that the evaluator learns nothing else about C or x.
We now describe this notion in more detail.A garbling scheme [Yao86; Bel+12] is a tuple of algorithms GS = (Garble, Eval) with the following syntax:• GS.Garble(C) → ( ˜ C, {label i,0 , label i,1 } i∈[n]).
On input a boolean circuit C, Garble outputs a garbled circuit˜Ccircuit˜ circuit˜C and a set of labels {label i,0 , label i,1 } i∈ [n] .
Here label i,b represents assigning the value b ∈ {0, 1} to the i-th input label.
• GS.Eval( ˜ C, {label i,x i }) → y. On input a garbled circuit˜Ccircuit˜ circuit˜C and labels {label i,x i } corresponding to an input x ∈ {0, 1} n , Eval outputs a string y = C(x).
We provide a formal definition in Appendix A, and briefly describe here the key properties satisfied by garbling schemes.
First, GS must be complete: the output of Eval must equal C(x).
Second, it must be private: giveñ C and {label i,x i }, the evaluator should not learn anything about C or x except the size of |C| (denoted by 1 |C| ) and the output C(x).
Linearly homomorphic public-key encryption.
A linearly homomorphic encryption scheme [Elg85; Pai99] is a public key encryption scheme that additionally supports (only) linearly homomorphic operations on the ciphertexts.
To give more details, a linearly homomorphic encryption consists of a tuple of algorithms HE = (KeyGen, Enc, Dec, Eval) with the following syntax:• HE.KeyGen → (pk, sk).
HE.KeyGen is a randomized algorithm that outputs a public key pk and a secret key sk.
• HE.Enc(pk, m) → c. On input the public key pk and a message m, the encryption algorithm HE.Enc outputs a ciphertext c.
The message space is a finite ring R .
• HE.Dec(sk, c) → m. On input the secret key sk and a ciphertext c, the decryption algorithm HE.Dec outputs the message m contained in c.• HE.Eval(pk, c 1 , c 2 , L) → c .
On input the public key pk, two ciphertexts c 1 , c 2 encrypting messages m 1 and m 2 , and a linear function L, 1 HE.Eval outputs a new ciphertext c encrypting L(m 1 , m 2 ).
Informally, we require HE to satisfy the following properties:• Correctness.
HE.Dec, on input sk and a ciphertext c := HE.Enc(pk, m), outputs m.• Homomorphism.
HE.Dec, on input sk and a ciphertext c := HE.Eval(pk, HE.Enc(pk,m 1 ), HE.Enc(pk, m 2 ), L), outputs L(m 1 , m 2 ).
• Semantic security.
Given a ciphertext c and two messages of the same length, no attacker should be able to tell which message was encrypted in c.• Function privacy.
Given a ciphertext c, no attacker can tell what homomorphic operations led to c. Oblivious transfer.
An oblivious transfer protocol [Rab81; Eve+82; Ish+03] is a protocol between two parties, a sender who has as input two messages m 0 , m 1 , and a receiver who has as input a bit b.
At the end of the protocol, the receiver learns m b .
The security requirement states that the sender does not learn anything about bit b and the receiver does not learn anything about the string m 1−b .
Additive secret sharing.
Given a finite ring R and an element x ∈ R , a 2-of-2 additive secret sharing of x is a pair([x] 1 , [x] 2 ) = (x − r, r) ∈ R 2 (so that x = [x] 1 + [x] 2 )where r is a random element from the ring.
Additive secret sharing is perfectly hiding, i.e., given a share [x] 1 or [x] 2 , the value x is perfectly hidden.
Beaver's multiplicative triples.
Beaver's multiplication triples [Bea95] generation procedure is a two-party protocol that securely computes the following function.
Samplea, b ← R and return [a] 1 , [b] 1 , [ab] 1 to the first party and [a] 2 , [b] 2 , [ab] 2to the second party.
In this work, we will generate Beaver's triples using a linearly homomorphic encryption scheme; we provide further details in Appendix A. Beaver's multiplication procedure.
Let P 1 and P 2 be two parties who hold [x] 1 , [y] 1 and [x] 2 , [y] 2respectively where x, y are some ring elements.
Additionally, let us assume that P 1 and P 2 also hold a Beaver's multiplication triple, namely,([a] 1 , [b] 1 , [ab] 1 ) and ([a] 2 , [b] 2 , [ab] 2 )respectively.
Beaver's multiplication procedure is a secure protocol such that at the end of the protocol, parties P 1 and P 2 hold an additive secret sharing of xy.
We provide details of this protocol in Appendix A but note here that this protocol can be used to securely evaluate any polynomial.
In DELPHI, we introduce a hybrid cryptographic protocol for cryptographic prediction (see Fig. 4).
Our protocol makes two 1 L maps (m 1 , m 2 ) to am 1 + m 2 for some a ∈ R .
key improvements to protocols proposed in prior work like MiniONN [Liu+17a] and GAZELLE [Juv+18].
First, DELPHI splits the protocol into a preprocessing phase and an online phase such that most of the heavy cryptographic computation is performed in the preprocessing phase.
Second, DELPHI introduces two different methods of evaluating non-linear functions that provide the users with trade offs between accuracy and performance.
The first method uses garbled circuits to evaluate the ReLU activation function, while the second method uses securely evaluates polynomial approximations of the ReLU.
The former provides maximum accuracy but is inefficient, while the latter is computationally cheap but lowers accuracy.
(We note that below we describe a protocol for evaluating any polynomial approximation, but in the rest of the paper, we restrict ourselves only to quadratic approximations because these are maximally efficient.)
Notation.
Let R be a finite ring.
Let HE = (KeyGen, Enc, Dec, Eval) be a linearly homomorphic encryption over the plaintext space R .
The server holds a model M consisting of layers M 1 , . . . , M .
The client holds an input vectorx ∈ R n .
We now give the formal definition of a cryptographic prediction protocol.
Intuitively, the definition guarantees that after the protocol execution, a semi-honest client (i.e., one that follows the specification of the protocol) only learns the architecture of the neural network and the result of the inference; all other information about the parameters of the server's neural network model are hidden.
Similarly, a semihonest server does not learn any information about the client's input, not even the output of the inference.
Definition 4.1.
A protocol Π between a server having as input model parameters M = (M 1 , . . . , M ) and a client having as input a feature vector x is a cryptographic prediction protocol if it satisfies the following guarantees.
• Correctness.
On every set of model parameters M that the server holds and every input vector x of the client, the output of the client at the end of the protocol is the correct prediction M(x).
• Security:-Corrupted client.
We require that a corrupted, semihonest client does not learn anything about the server's network parameters M. Formally, we require the existence of an efficient simulator Sim C such that View Π C ≈ c Sim C (x, out), where View Π C denotes the view of the client in the execution of Π (the view includes the client's input, randomness, and the transcript of the protocol), and out denotes the output of the inference.
-Corrupted server.
We require that a corrupted, semihonest server does not learn anything about the private input x of the client.
Formally, we require the existence of an efficient simulator Sim S such that View Π S ≈ c Sim S (M), where View Π S denotes the view of the server in the execution of Π.
[a i ] 1 , [b i ] 1 , [a i b i ] 1 [a i ] 2 , [b i ] 2 , [a i b i ] 2 M i OT for i ∈[1,…, ℓ] for i ∈[1,…, ℓ] Figure 3: DELPHI's preprocessing phase.
The DELPHI protocol proceeds in two phases: the preprocessing phase and the online phase, and we give the details of both these phases in the subsequent sections.M i r i − s i M i , s i x, r i x i − r i M i (x i − r i ) + s i ˜ C i Labels for M i (x i − r i ) + s i x i+ 1 − r i+ 1 r i+ 1 F o n lin e Beaver [x i+ 1 ] 1 [x i+ 1 ] 2 [x i+ 1 ] 1 − r i+ 1 [x i+ 1 ] 1 − r i+ 1 + [x i+ 1 ] 2 x i+ 1 − r i+ 1 r i+ 1 During preprocessing, the client and the server pre-compute data that can be used during the online execution.
This phase can be executed independent of the input values, i.e., DELPHI can run this phase before either party's input is known.1.
The client runs HE.KeyGen to obtain a public key pk and a secret key sk.
2.
For every i ∈ [], the client and the server choose random masking vectors r i , s i ← R n respectively.3.
The client sends HE.Enc(pk, r i ) to the server.
The server computes HE.Enc(pk, M i · r i − s i ) using the HE.Eval procedure and sends this ciphertext to the client.
4.
The client decrypts the above ciphertexts and to obtain (M i · r i − s i ) for each layer.
The server holds s i for each layer and thus, the client and the server hold an additive secret sharing of M i r i .
5.
This step depends on the activation type:(a) ReLU: The server constructs C by garbling the circuit C described in Fig. 5.
It sends C to the client and simultaneously, the server and the client exchange labels for the input wires corresponding to r i+1 and M i · r i − s i via an Oblivious Transfer (OT).
(b) Polynomial approximaitons: The client and the server run the Beaver's triples generation protocol to generate a number of Beaver's multiplication triples.
2 2 The exact number of triples generated depends on the number of layers that have to be approximated using a polynomial.
The online phase is divided into a two stages: the setup and the layer evaluation.
The client on input x, sends x − r 1 to the server.
The server and the client now hold an additive secret sharing of x.
At the beginning of the i-th layer, the client holds r i and the server holds x i − r i where x i is the vector obtained by evaluating the first (i − 1) layers of the neural network on input x (with x 1 set to x).
This invariant will be maintained for each layer.
We now describe the protocol for evaluating the i-th layer, which consists of linear functions and activation functions.Linear layer.
The server computes M i (x i − r i ) + s i , which ensures that the client and the server an additive secret sharing of M i x i .
Non-linear layer.
After the linear functions, the server holds M i (x i − r i ) + s i and the client holds M i · r i − s i .
There are two ways of evaluating non-linear layers: garbled circuits for ReLU, or Beaver's multiplication for polynomial approximation:• Garbled circuits1.
The server sends the garbled labels corresponding to M i (x i − r i ) + s i to the client.
2.
The client evaluates the garbled circuit C using the above labels as well as the labels obtained via OT (in the offline phase) to obtain a one-time pad ciphertext OTP(x i+1 − r i+1 ).
It then sends this output to the server.3.
The server uses the one time pad key to obtain x i+1 − r i+1 .
• Polynomial approximation Output layer.
The server sends x − r to the client who adds this with r to learn x .
Hardwired: A random one time pad key.Input: M i (x i − r i ) + s i , r i+1 , M i · r i − s i .
1.
Compute M i · x i = M i (x i − r i ) + s i + (M i · r i − s i ).
2.
Compute ReLU(M i · x i ) to obtain x i+1 .3.
Compute x i+1 − r i+1 and output OTP(x i+1 − r i+1 ).
Concretely, our implementation works over the 32-bit prime finite field defined by the prime 2138816513, and uses a 15-bit fixed-point representation.
This choice of parameters enables a single multiplication of two fixed-point numbers before the result overflows capacity of the prime field.
To prevent values from growing exponentially with the number of multiplications (and thus overflowing), we use a trick from [Moh+17] that allows us to simply truncate the extra LSBs of fixed-point values.
This trick works even when the result is secret-shared, albeit at the cost of a 1-bit error.Similarly to Slalom [Tra+19], our choice of prime field also enables us to losslessly embed our field arithmetic in 64-bit floating point arithmetic.
In more detail, 64-bit floating point numbers can represent all integers in the range 2 −53 , . . . , 2 53 .
Because the online phase of our protocol for linear layers requires multiplication of a fixed-point matrix by a secret shared vector, the result is a ∼ 45-bit integer, and hence can be represented with full precision in a 64-bit floating point number.
This enables our implementation to use state-of-theart CPU and GPU libraries for linear algebra.
Theorem 4.3.
Assuming the existence of garbled circuits, linearly homomorphic encryption and secure protocols for Beaver's triples generation and multiplication procedure, the protocol described above is a cryptographic prediction protocol (see Definition 4.1).
Proof.
Below we describe simulators first for the case where the client is corrupted, and then for the case where the server is corrupted.
We provide a hybrid argument that relies on these simulators in Appendix B.
The simulator Sim, when provided with the client's input x, proceeds as follows:1.
Sim chooses an uniform random tape for the client.
2.
In the offline phase:(a) Sim receives the public key and the ciphertext HE.Enc(pk, r i ) from the client.
In return, it sends HE.Enc(pk, −s i ) for a randomly chosen s i from R n .
(b) Sim uses the simulator for garbled circuits Sim GS and runs it on 1 λ , 1 |C| and sets the output of the circuit to be a random value.
Sim GS outputs C, {label i }.
For the i-th OT execution, Sim gives the label i in both slots as input.
It sends C to the client.
(c) For the secure protocol to generate the Beaver's triples, Sim runs the corresponding simulator for this procedure.3.
Online phase.
In the preamble phase, Sim receives x − r 1 .
It sends x to the ideal functionality (a semi-honest client uses the same x as its input) and receives the output y. Sim performs the layer evaluation as follows:(a) Garbled circuits layer.
Sim sends the simulated labels.
(b) Polynomial approximation layer.
Sim uses the simulator for the Beaver's multiplication procedure to evaluate the polynomial.4.
Output layer.
Sim sends y − r to the client.In Appendix B, we show that the simulated distribution is computationally indistinguishable to the real world distribution using the security of the underlying cryptographic building blocks.
The simulator Sim, when provided with the server's input M 1 , . . . , M −1 , proceeds as follows.1.
Sim chooses an uniform random tape for the server.2.
In the offline phase:(a) Sim chooses a public key pk for a linearly homomorphic encryption scheme.
It then sends HE.Enc(pk, 0) to the server.
In return, it receives the homomorphically evaluated ciphertext from the server.
(b) For every oblivious transfer execution where Sim acts as the receiver, it uses junk input, say 0 as the receiver's choice bit.
It receives C from the server.
(c) For the secure protocol for generating the Beaver's triples, Sim runs the corresponding simulator for this procedure.3.
Online phase.
In the preamble phase, Sim sends r 1 for an uniformly chosen r 1 .
Sim performs the layer evaluation step as follows:(a) Garbled circuits layer.
Sim sends a random value back to the server.
(b) Polynomial approximation layer.
Sim uses the simulator for the Beaver's multiplication procedure to evaluate the polynomial.
At the last round of this step, it sends a random value back to the server.In Appendix B, we show that the simulated distribution is indistinguishable from the real world distribution using the security of the underlying cryptographic primitives.
.
The goal of NAS is to automatically discover neural network architectures that best satisfy a set of user-specified constraints.
Most NAS algorithms do so by (partially) training a number of different neural networks, evaluating their accuracy, and picking the best-performing ones.
Overview of our planner.
DELPHI's planner, when given as input the baseline all-ReLU neural network, operates in two modes.
When retraining is either not possible or undesirable (for example if the training data is unavailable or if the provider cannot afford the extra computation required for NAS), the planner operates in the first mode and simply outputs the baseline network.
If retraining (and hence NAS) is feasible, then the planner takes as additional inputs the training data, and a constraint on the minimum acceptable prediction accuracy t, and then uses NAS to discover a network configuration that maximizes the number of quadratic approximations while still achieving accuracy greater than t.
Our planner then further optimizes the hyperparameters of this configuration.
In more detail, in this second mode, our planner uses NAS to optimize the following properties of a candidate network configuration given t: (a) the number of quadratic approximations, (b) the placement of these approximations (that is, the layers where ReLUs are replaced with approximations), and (c) training hyperparameters like learning rate and momentum.The foregoing is a brief description that omits many details.
Below, we describe how we solved the challenges that required solving to adapt NAS to this setting (Section 5.1), our concrete choice of NAS algorithm (Section 5.2), and detailed pseudocode for the final algorithm (Fig. 6).
Challenge 1: Training candidate networks.
Prior work [Moh+17; Gil+16; Gho+17; Cho+18] and our own experiments indicate that networks that use quadratic approximations are challenging to train and deploy: the quadratic activations cause the underlying gradient descent algorithm to diverge, resulting in poor accuracy.
Intuitively, we believe that this behavior is caused by these functions' large and alternating gradients.To solve this issue, we used the following techniques: • Gradient and activation clipping: During training, we modify our optimizer to use gradient value clipping, which helps prevent gradients from exploding [Ben+94].
In particular, we clip the values of all gradients to be less than 2.
We furthermore modify our networks to use the ReLU6 activation function [Kri10] that ensures that post-activation values have magnitude at most 6.
This keeps errors from compounding during both inference and training.
• Gradual activation exchange: Our experiments determined that despite clipping, the gradients were still exploding quickly, especially in deeper networks that contained a higher fraction of approximations.
To overcome this, we made use of the following insight: intuitively, ReLU6 and (clipped) quadratic approximations to ReLU should share relatively similar gradients, and so it should be possible to use ReLU6 to initially guide the descent towards a stable region where gradients are smaller, and then to use the approximation's gradients to make fine-grained adjustments within this region.
We take advantage of this insight by modifying the training process to gradually transform an already-trained allReLU6 network into a network with the required number and placement of quadratic approximations.
In more detail, our training process expresses each activation as a weighted average of quadratic and ReLU6 activations, i.e., act(x) := w q · quad(x) + w r ReLU(x) such that w q + w r = 1.
In the beginning, w q = 0 and w r = 1.
Our training algorithm then gradually increases w q and reduces w r , so that eventually w q = 1 and w r = 0.
This technique also improves running times for the NAS as it no longer has to train each candidate network configuration from scratch.
Challenge 2: Efficiently optimizing configurations.
Recall from above that our planner aims to optimize the number of quadratic approximations, their placement in the network, and the training hyperparameters.
Attempting to optimize all of these variables within a single NAS execution results in a large search space, and finding efficient networks in this search space takes a correspondingly long time.To solve this problem, we divided up the monolithic NAS execution into independent runs that are responsible for optimizing different variables.
For instance, for an architecture with n non-linear layers, for relevant choices of m < n, we first perform NAS to find high-scoring architectures that have m approximation layers, and then perform NAS again to optimize training hyperparameters for these architectures.
At the end of this process, our planner outputs a variety of networks with different performance-accuracy trade-offs.
Challenge 3: Prioritizing efficient configurations.
Our planner's goal is to choose configurations containing the largest number of approximations in order to maximize efficiency.
However, network configurations with large numbers of approximations take longer to train and may be slightly less accurate than networks with fewer approximations.
Since the traditional NAS literature focuses on simply maximizing efficiency, using NAS in this default setting results in selecting slower networks over more efficient networks that are just slightly less accurate than the slower ones.
To overcome this, we changed the way the NAS assigns "scores" to candidate networks by designing a new scoring function score(·) which balances prioritizing accuracy and performance.
Our experiments from Section 7 indicate that this function enables us to select networks that are both efficient and accurate.
1 + #quad.
activations #total activations .
The discussion so far has been agnostic to the choice of NAS algorithm.
In our implementation, we decided to use the popular population-based training algorithm [Jad+17] because it was straightforward to customize it for our use case, and because it enjoys a number of optimized implementations (like the one in [Lia+18]).
Population-based training (PBT) [Jad+17] maintains a population of candidate neural networks that it trains over a series of time steps.
At the end of each time step, it measures the performance of each candidate network via a user-specified scoring function, and replaces the worst-performing candidates with mutated versions of the best-performing ones (the mutation function is specified by the user).
At the end of the optimization process, PBT outputs the best-performing candidate network architectures it has found (along with the hyperparameters for training them).
Remark 6.1 (reimplementing GAZELLE's algorithms).
Riazi et al. [Ria+19] note that GAZELLE's implementation does not provide circuit privacy for HE, which can result in leakage of information about linear layers.
To remedy this, they recommend using larger parameters that ensure circuit privacy.
(The caveat is that these parameters result in worse performance than using GAZELLE's highly optimized parameters.)
Because DELPHI uses GAZELLE's algorithms in our preprocessing phase, we attempted to modify GAZELLE's implementation 4 to use the circuit-private parameters.
However, this proved to be difficult, and so we decided to reimplement these algorithms in SEAL, which does support these parameters.
We divide our evaluation into three sections that answer the following questions.
• Section 7.2: How efficient are DELPHI's building blocks?
• Section 7.3: Does DELPHI's planner provide a good balance between efficiency and accuracy for realistic neural networks, such as ResNet-32?
• Section 7.4: What is the latency and communication cost of using DELPHI for serving predictions with such neural networks?
All cryptographic experiments were carried out on AWS c5.2xlarge instances possessing an Intel Xeon 8000 series machine CPU at 3.0 GHz with 16 GB of RAM.
The client and server were executed on two such instances located in the us-west-1 (Northern California) and us-west-2 (Oregon) regions respectively.
The client and server executions used 4 threads each.
Machine learning experiments were carried out on various machines with NVIDIA Tesla V100 GPUs.
Our machine learning and cryptographic protocol experiments rely on the following datasets and architectures: 1.
CIFAR-10 is a standardized dataset consisting of (32 × 32) RGB images separated into 10 classes.
The training set contains 50, 000 images, while the test set has 10, 000 images.
Our experiments use the 7-layer CNN architecture specified in MiniONN [Liu+17a].
Doing so allows us to compare our protocol with prior work.
2.
CIFAR-100 contains the same number of training and test images as CIFAR-10, but divides them up into 100 classes instead of 10.
This increased complexity requires a deeper network with more parameters, and so our experiments use the popular ResNet-32 architecture introduced in [He+16].
We note that no prior work on secure inference attempts to evaluate their protocols on difficult datasets like CIFAR-100 or on deep network architectures like ResNet-32.
Whenever we compare DELPHI with GAZELLE, we estimate the cost of GAZELLE's protocols by summing the costs of our re-implementation of the relevant subprotocols for linear and non-linear layers.
We do this as there is no end-to-end implementation of GAZELLE's protocol; only the individual subprotocols are implemented.
We provide microbenchmarks of DELPHI's performance on linear and non-linear layers, comparing both with GAZELLE.
Below we focus on the performance of convolution operations because these comprise the majority of the cost of neural networks' linear operations.
The complexity of a convolution is determined by the dimensions of the input and the size and number of convolution kernels, as well as the padding and stride (the latter parameter decides how often the kernel is applied to the input).
In Table 1, we evaluate the cost of convolutions used in ResNet-32.
The key takeaway is that our online time is over 80× smaller than GAZELLE's, and our online communication is over 150× lower.
On the other hand, our preprocessing time and communication are higher than GAZELLE's, but are at most equal to GAZELLE's online time and communication.
Optimized GPU operations.
As explained in Remark 4.2, DELPHI's choice of prime field enables DELPHI to use standard GPU libraries for evaluating convolutional layers in the online phase.
However, doing so requires copying the layer weights and input into GPU memory, and copying the output back into CPU memory for every linear layer.
This copying can have substantial overhead.
To amortize it, one can batch convolutions over different inputs together.
In Table 2, we report the cost of doing so for a batch sizes of 1, 5, and 10.
The key takeaway is that, for single convolutions these costs are over 50-100× lower than the equivalent ones in Table 1, and for batched convolutions, the cost seems to scale sub-linearly with the batch size.
Recall that our protocol for evaluating ReLU activations uses garbled circuits.
Our circuit for ReLU follows the design laid out in [Juv+18] with minor additional optimizations.
To evaluate quadratic activations, our protocol uses Beaver's multiplication procedure [Bea95], which requires sending one field element from the server to the client and vice versa, and then requires some cheap local field operations from each party.
The communication and computation costs for both activations are presented in Table 3.
To demonstrate the effectiveness of our planner we need to show that (a) quadratic activations are an effective replacement for ReLU activations, and that (b) the networks found by the planner offer better performance than all-ReLU networks.In our experiments below, we use 80% of the training data to train networks in the planner, and the remaining 20% as a validation set.
The planner scores candidate networks based on their validation accuracy, but the final reported accuracy is the test set accuracy.
Quadratic activations are effective.
We need to show that not only do networks output by our planner achieve good accuracy, but also that the quadratic activations are not redundant.
That is, we need to show that the network is not learning to "ignore" quadratic activations.
This is a concern because prior work [Mol+17; Liu+18] has shown that modern neural network architectures can be "pruned" to remove extraneous parameters and activations while still maintaining almost the same accuracy.We show this point by running our planner in two modes.
In the first mode, our planner was configured to find performant networks that used quadratic activations, while in the second mode it was configured to find networks that used the identity function instead of quadratic activations, with the intuition that if the quadratic activations were ineffective, then networks that used the identity function instead would perform just as well.
The results of these runs for varying number of non-ReLU layers are displayed in Fig. 7 (for CIFAR-10) and in Fig. 8 (for CIFAR-100).
Together, these results indicate that the networks output by our planner achieve performance that is comparable to that of the all-ReLU baselines.
Furthermore, as the number of non-ReLU layers increase, the best-performing networks that use the identity activation function have much worse accuracy than the equivalent networks that use quadratic activations.
Planned networks perform better.
To evaluate the ability of our planner to find networks that offer good performance, we run the planner to produce networks with a varying number (say k) of quadratic layers.
We then compare the number of ReLU activations in these networks to that in all-ReLU networks (like those supported by GAZELLE).
Fig. 9 this comparison for ResNet32 on CIFAR-100.
We observe that the networks found by our planner consistently have fewer activations than the all-ReLU baseline.
We demonstrate the effectiveness of DELPHI's cryptographic protocol by showing that DELPHI's preprocessing phase and online phase offer significant savings in latency and communication cost over prior work (GAZELLE).
Figs. 10 and 11 summarizes this improvement for networks found by our planner; we provide a detailed evaluation next.
Preprocessing phase.
Figs. 12a and 13a compare the time required to execute the preprocessing phases of DELPHI and GAZELLE on ResNet32 on CIFAR-100 and the MiniONN architecture on CIFAR-10, respectively.
In both cases, we observe that, on networks that have a large number of ReLU activations, DELPHI's preprocessing time is larger than GAZELLE's.
This is because DELPHI needs to additionally perform preprocessing for each linear layer.
However, as the number of approximate activations increases, DELPHI's preprocessing time quickly decreases below that of GAZELLE, because garbling circuits for ReLUs is far more expensive than the preprocessing phase for the approximate activations.
A similar trend can be observed for communication costs in Figs. 12c and 13c.
Overall, for the most efficient networks output by our planner, DELPHI requires 1.5-2 × less preprocessing time, and 6-40 × less communication.
Online phase.
Figs. 12b and 13b compare the time required to execute the online phases of DELPHI and GAZELLE on ResNet32 on CIFAR-100 and the MiniONN architecture on CIFAR-10, respectively.
In both cases, we observe that GAZELLE's use of HE for processing linear layers imposes a significant computational cost.
Furthermore, as the number of approximate activations increases, the gap between DELPHI and GAZELLE grows larger.
A similar trend can be observed for communication costs in Figs. 12d and 13d.
Overall, for the most efficient networks output by our planner, DELPHI requires 22-100 × less time to execute its online phase, and 9-40 × less communication.
We first discuss cryptographic techniques for for secure execution of machine learning algorithms in Section 8.1.
Then, in Section 8.2, we discuss model inference attacks that recover information about the model from predictions, as well as countermeasures for these attacks.
Finally, in Section 8.3, we discuss prior work on neural architecture search.
The problem of secure inference can be solved via generic secure computation techniques like secure two-party (2PC) computation [Yao86; Gol+87], fully homomorphic encryption (FHE) [Gen09], or homomorphic secret sharing (HSS) [Boy+16].
However, the resulting protocols would suffer from terrible communication and computation complexity.
For instance, the cost of using 2PC to compute a function grows with the size of the (arithmetic or boolean) circuit for that function.
In our setting, the function being computed is the neural network itself.
Evaluating the network requires matrix-vector multiplication, and circuits for this operation grow quadratically with the size of the input.
Thus using a generic 2PC protocol for secure inference would result in an immediate quadratic blow up in both computation and communication.Similarly, despite a series of efforts to improve the efficiency of FHE [Bra+11; Gen+11; Fan+12; Hal+18; Hal+19] and HSS [Boy+17], their computational overhead is still large, making them unsuitable for use in our scenario.Hence, it seems that it is necessary to design specialized protocols for secure machine learning, and indeed there is a long line of prior work [Du+04; Lau+06; Bar+09; Nik+13a; Nik+13b; Sam+15; Bos+15; Wu+16a; Aon+16; Sch+19] that does exactly this.
These works generally fall into two categories: those that focus on secure training, and those that focus on secure inference.
Since secure training is not our focus in this paper, we omit discussing it, and instead focus on prior work on secure inference.
Most of these early works focus on simpler machine learning algorithms such as SVMs and linear regression.
Designing cryptographic protocols for these simpler algorithms is often more tractable than our setting of inference for neural networks.Hence, in the rest of this section we discuss prior work that focus on secure inference over neural networks.
This work generally falls into the following categories: (a) 2PC-based protocols; (b) FHE-based protocols; (c) TEE-based protocols; and (d) protocols working in a multi-party model.2PC-based protocols.
SecureML [Moh+17] is one of the first systems to focus on the problem of learning and predicting with neural networks securely.
However, it relies entirely on generic 2PC protocols to do this, resulting in poor performance on realistic networks.
MiniONN [Liu+17a] uses the SPDZ protocol to compute linear layers and polynomial approximation activations.
Unlike DELPHI, MiniONN generates multiplicative triples for each multiplication in a linear layer; for a layer with input size n, MiniONN requires n 2 offline and online communication, compared to n for DELPHI.
GAZELLE [Juv+18] is the system most similar to ours: it uses an efficient HE-based protocol for linear layers, while using garbled circuits to compute non-linear activations.
However, its reliance on heavy cryptographic operations in the online phase results in a protocol that is more expensive than DELPHI's protocol with respect to both computation and communication (see Section 7 for a thorough comparison).
DeepSecure [Rou+18] and XONN [Ria+19] use garbled circuits to provide secure inference for the restricted class of binarized neural networks [Cou+15] whose weights are all boolean.
This restriction enables these protocols to construct a protocol that uses only a constant number of round trips.
DeepSecure additionally prunes the input neural network to reduce the number of activations.
Ball et al. [Bal+19] have also recently constructed a protocol for secure inference that FHE-based protocols.
CryptoNets [Gil+16] is the first work that attempts to optimize and tailor FHE schemes for secure inference.
Despite optimizations, the limitations of FHE mean that CryptoNets is limited to networks only a few layers deep, and even for these networks it only becomes efficient when processing a batch of inputs.
Recent papers [Hes+17; Bru+18; Bou+18; Cho+18; San+18] develop different approaches to optimize the CryptoNets paradigm, but the resulting protocols still require tens of minutes to provide predictions over networks much smaller than the ones we consider here.CHET [Dat+19] compiles high-level specifications of neural network to FHE-based inference protocols.
To efficiently use FHE, CHET must replace all ReLUs with polynomial approximations, which harms accuracy for large networks.TEE-based protocols.
There are two approaches for inference using trusted execution enclaves (TEEs): (a) inference via server-side enclaves, where the client uploads their input to the server's enclave, and (b) inference in client-side enclaves, where the client submits queries to a model stored in the client-side enclave.Slalom and Privado are examples of protocols that rely on server-side enclaves.
Slalom [Tra+19], like DELPHI, splits inference into an offline and online phase, and uses additive secret sharing for the online phase.
Unlike DELPHI, Slalom uses the Intel SGX hardware enclave [McK+13] to securely compute both the offline and online phases.
Privado [Top+18] compiles neural networks into oblivious neural networks, meaning that computing the transformed network does not require branching on secret data.
They use the oblivious network to perform inference inside Intel SGX enclaves.
Slalom's implementation indicates that it does not implement linear or non-linear layers obliviously.MLCapsule [Han+18] describes a system for performing inference via client-side enclaves.
Apple uses a client-side secure enclave to perform fingerprint and face matching to authorize users [App19].
In general, most TEE-based cryptographic inference protocols offer better efficiency than protocols that rely on cryptographic (like DELPHI).
This improved efficiency comes at the cost of a weaker threat model that requires trust in hardware vendors and the implementation of the enclave.
Furthermore, because the protocol execution occurs in an adversarial environment, any side-channel leakage is more dangerous (since the adversary can carefully manipulate the execution to force this leakage).
Indeed, the past few years have seen a number of powerful side-channel attacks [Bra+17; Häh+17; Göt+17; Mog+17; Sch+17; Wan+17; Van+18] against popular enclaves like Intel SGX and ARM TrustZone.Protocols with more parties.
The discussion above focuses on two-party protocols, because in our opinion secure inference maps naturally to this setting.
Nevertheless, a number of works [Ria+18; Wag+18; Tfe; Bar+19] have instead targeted the three-party setting where shares of the model are divided amongst two non-colluding servers, and a client must interact with these servers to obtain their prediction.
Prediction API attacks [Ate+15; Fre+15; Wu+16b; Tra+16; Sho+17; Jag+19] aim to learn private information about the server's model or training data given access only to the results of predictions on arbitrary queries.
There is no general defense against prediction API attacks beyond rate limiting and query auditing [Jag+19].
However, there are defenses against specific classes of attacks.
For example, one can use differentially private training [Sho+15; Aba+16] to train neural networks that that do not leak sensitive information about the underlying training data.The guarantees of DELPHI are complementary to those provided by any such mitigations.
Indeed, with sufficient effort, these techniques can be integrated into DELPHI to provide even stronger privacy guarantees; we leave this to future work.
Recently, machine learning research has seen rapid advancement in the area of neural architecture search (NAS) (see [Els+19; Wis+19] for surveys).
The aim of this field is to develop methods to automatically optimize properties of a neural network like accuracy and efficiency by optimizing the hyperparameters of the network.
Examples of commonly optimized hyperparameters include the size of convolutional kernels, the number of layers, and parameters of the gradient descent algorithm like learning rate and momentum.
In this work, we rely on NAS algorithms only for optimizing the placement of quadratic approximation layers within a network, as ReLU activations were the bottleneck in our system.Common approaches to neural architecture search include those based on reinforcement-learning [Zop+17], evolutionary algorithms [Yao99; Ber+13], and random search [Ber+12; Jad+17].
DELPHI's planner uses the Population-Based Training algorithm [Jad+17] to perform NAS.
PBT can be seen as a hybrid of the evolutionary algorithm and random search approaches.Security for linearly homomorphic encryption schemes requires the scheme to satisfy the following properties:• Semantic security.
For any two messages m, m , we require {pk, HE.Enc(pk, m)} ≈ c {pk, HE.Enc(pk, m )}, where the two distributions are over the random choice of pk and the random coins of the encryption algorithm.
• Function privacy.
There exists a simulator Sim FP such that for every efficient adversary A, every linear function L, and every pair of messages m 1 , m 2 , we have that the following distributions are computationally indistinguishable:          (r, r 1 , r 2 , c ) :(r, r 1 , r 2 ) ← {0, 1} λ (pk, sk) ← HE.KeyGen(1 λ ; r) c 1 ← HE.Enc(pk, m 1 ; r 1 ) c 2 ← HE.Enc(pk, m 2 ; r 2 ) c ← HE.Eval(pk, c 1 , c 2 , L)           ≈ c Sim FP (1 λ , m 1 , m 2 , L(m 1 , m 2 )) Proof of indistinguishability with corrupted client.
We show that the real world distribution is computationally indistinguishable to the simulated distribution via a hybrid argument.
In the final simulated distribution, the simulator does not use the weights for the server's model, and so a corrupted client learns nothing beyond the output prediction and the model architecture in the real world.
• Hyb 0 : This corresponds to the real world distribution where the server uses its input matrices M 1 , . . . , M −1 .
• Hyb 1 : This hybrid involves only a syntactic change.
In the output phase, the simulator sends y − r to the client, where y is the output of the neural network on input x. Additionally, the simulator uses the knowledge of the client's random tape to begin the evaluation of the i-th layer with x i − r i .
Since this is a syntactic change, Hyb 1 is distributed identically to Hyb 0 .
• Hyb 2 : We change the inputs that the server provides to each OT execution where it acts as the sender.
Instead of providing the labels corresponding to 0 and 1 in each OT execution, the server provides label i,b where b is the input used by the client in that OT execution.
Note that in the semi-honest setting, we know b as a result of setting the random tape as well learning the input of the corrupted client.
It follows from the sender security of OT that Hyb 2 is indistinguishable from Hyb 1 .
• Hyb 3 : In this hybrid, for every layer of the neural network that uses garbled circuits, we generate C using Sim GS on input 1 λ , 1 |C| and C(z) where z is the input that the client uses to evaluate this circuit (this is again known in the semihonest setting as a result of setting the random tape and knowing the input).
Note that C(z) is an OTP encryption and hence is distributed identically to a random string.
It follows from the security of the garbled circuits that Hyb 3 is indistinguishable from Hyb 2 .
• Hyb 4 : In this hybrid, we generate the multiplication triples in the offline phase using the corresponding simulator for Beaver's protocol.
It follows from the simulation security of this protocol that Hyb 4 is indistinguishable from Hyb 3 .
• Hyb 5 : In this hybrid, for every quadratic approximation layer, we use the simulator for Beaver's multiplication procedure.
It again follows from the simulation security that this hybrid is indistinguishable to the previous hybrid.
Notice that in this hybrid, the server is no longer using x i − r i , s i as well as the matrix M i to evaluate the i-th layer.
• Hyb 6 : For every homomorphic evaluation in the offline phase, we use the simulator Sim FP for the function privacy of HE.
Note that Sim FP only requires the output M i · r i − s i to generate the homomorphically evaluated ciphertext.
It follows from the function privacy of HE that Hyb 6 is computationally indistinguishable from Hyb 5 .
• Hyb 7 : In this hybrid, we replace the input −s i given to Sim FP with randomly sampled s i from R n (instead of the true value M i · r i − s i ).
Thus Hyb 7 is distributed identically to Hyb 6 as s i is chosen uniformly at random.
Finally, we note that Hyb 7 is identically distributed to the simulator's output, completing the proof.
Proof of indistinguishability with corrupted server.
We show that the real world distribution is computationally indistinguishable to the simulated distribution via a hybrid argument.
In the final simulated distribution, the simulator does not use the user's input, and so a corrupted server learns nothing in the real world.
• Hyb 0 : This corresponds to the real world distribution where the client uses its actual input x.• Hyb 1 : This hybrid involves only a syntactic change.
For every layer that is evaluated by garbled circuits, instead of evaluating the circuits, we instead send OT P(x i+1 − r i+1 ) by using our knowledge of x, the matrices M i , and the random tape of the server.
Similarly, in every quadratic approximation layer, we send a share in the final round such that when the server adds it with its own share it gets x i+1 − r i+1 .
Because this change is only syntactic, Hyb 1 is identical to Hyb 0 .
• Hyb 2 : In this hybrid, we change the inputs that the client provides to each OT execution where it is acting as the receiver.
Instead of providing the actual inputs, it provides some junk inputs, say 0.
It follows from the receiver security of the underlying oblivious transfer protocol that Hyb 2 is computationally indistinguishable from Hyb 1 .
• Hyb 3 : In this hybrid, we generate the multiplication triples in the offline phase using the simulator for Beaver's multiplication protocol.
It follows from the simulation security of this protocol that Hyb 4 is indistinguishable from Hyb 2 .
• Hyb 4 : In this hybrid, for every quadratic approximation layer of the neural network, we use the simulator for the Beaver's multiplication procedure.
It follows from simulation security that Hyb 4 is indistinguishable from Hyb 3 .
• Hyb 5 : In this hybrid, we change the ciphertexts sent by the client in the offline phase.
Instead of sending encryptions of r i , the client sends HE.Enc(pk, 0).
It follows from the semantic security of the encryption scheme that Hyb 5 is computationally indistinguishable from Hyb 4 .
• Hyb 6 : In this hybrid, we make the following changes.
For every layer that is evaluated by garbled circuits, we send OT P(r i+1 ) for a randomly chosen r i+1 .
Similarly, in every quadratic approximation layer, we send a share in the final round that is chosen uniformly at random.
Additionally, in the preamble phase, we send an uniformly chosen value r 1 .
Hyb 6 is distributed identically to Hyb 5 .
Finally, note that Hyb 6 is identically distributed to the simulator's output, completing the proof.
We thank Liam Li for the suggestion to use the PBT algorithm to perform NAS, Joey Gonzalez for answering questions about PBT, Robert Nishihara for the suggestion to use ReLU's gradients to guide gradient descent, Chiraag Juvekar for providing the code for GAZELLE, and our shepherd Siddharth Garg and the anonymous reviewers for their invaluable feedback.
This work was supported by the NSF CISE Expeditions Award CCF-1730628, as well as gifts from the Sloan Foundation, Bakar and Hellman Fellows Fund, Alibaba, Amazon Web Services, Ant Financial, Arm, Capital One, Ericsson, Facebook, Google, Intel, Microsoft, Scotiabank, Splunk and VMware.
