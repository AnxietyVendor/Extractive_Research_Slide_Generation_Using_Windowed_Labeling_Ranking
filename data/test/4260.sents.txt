In Proof-of-Stake (PoS) and permissioned blockchains, a committee of verifiers agrees and sign every new block of transactions.
These blocks are validated, propagated, and stored by all users in the network.
However, posterior corruptions pose a common threat to these designs, because the adversary can corrupt committee verifiers after they certified a block and use their signing keys to certify a different block.
Designing efficient and secure digital signatures for use in PoS blockchains can substantially reduce bandwidth, storage and computing requirements from nodes, thereby enabling more efficient applications.
We present Pixel, a pairing-based forward-secure multi-signature scheme optimized for use in blockchains, that achieves substantial savings in bandwidth, storage requirements , and verification effort.
Pixel signatures consist of two group elements, regardless of the number of signers, can be verified using three pairings and one exponentiation, and support non-interactive aggregation of individual signatures into a multi-signature.
Pixel signatures are also forward-secure and let signers evolve their keys over time, such that new keys cannot be used to sign on old blocks, protecting against posterior corruptions attacks on blockchains.
We show how to integrate Pixel into any PoS blockchain.
Next, we evaluate Pixel in a real-world PoS blockchain implementation, showing that it yields notable savings in storage, bandwidth, and block verification time.
In particular, Pixel signatures reduce the size of blocks with 1500 transactions by 35% and reduce block verification time by 38%.
Blockchain technologies are quickly gaining popularity for payments, financial applications, and other distributed applications.
A blockchain is an append-only public ledger that is maintained and verified by distributed nodes.
At the core of the blockchain is a consensus mechanism that allows nodes * Authors are listed alphabetically.to agree on changes to the ledger, while ensuring that changes once confirmed cannot be altered.In the first generation of blockchain implementations, such as Bitcoin, Ethereum, Litecoin, the nodes with the largest computational resources choose the next block.
These implementations suffer from many known inefficiencies, low throughput, and high transaction latency [17,27,49].
To overcome these problems, the current generation of blockchain implementations such as Algorand, Cardano, Ethereum Casper, and Dfinity turn to proofs of stake (PoS), where nodes with larger stakes in the system -as measured, for instance, by the amount of money in their account-are more likely to participate in choosing the next block [21,24,29,32,34,39,47].
Permissioned blockchains such as Ripple [54] and Hyperledger Fabric [4] take yet another approach, sacrificing openness for efficiency by limiting participation in the network to a selected set of nodes.All PoS-based blockchains, as well as permissioned ones, have a common structure where the nodes run a consensus sub-protocol to agree on the next block to be added to the ledger.
Such a consensus protocol usually requires nodes to inspect block proposals and express their agreement by digitally signing acceptable proposals.
When a node sees sufficiently many signatures from other nodes on a particular block, it appends the block to its view of the ledger.Because the consensus protocol often involves thousands of nodes working together to reach consensus, efficiency of the signature scheme is of paramount importance.
Moreover, to enable outsiders to efficiently verify the validity of the chain, signatures should be compact to transmit and fast to verify.
Multi-signatures [35] have been found particularly useful for this task, as they enable many signers to create a compact and efficiently verifiable signature on a common message [15,40,58,59].
The Problem of Posterior Corruptions.
Chain integrity in a PoS blockchain relies on the assumption that the adversary controls less than a certain threshold (e.g., a third) of the total stake; an adversary controlling more than that fraction may be able to fork the chain, i.e., present two different but equally valid versions of the ledger.
Because the distribution of stake changes over time, however, the real assumption behind chain integrity is not just that the adversary currently controls less than a threshold of the stake, but that he never did so at any time in the past.This assumption becomes particularly problematic if stake control is demonstrated through possession of signature keys, as is the case in many PoS and permissioned blockchains.
Indeed, one could expect current stakeholders to properly protect their stake-holding keys, but they may not continue to do so forever, especially after selling their stake.
Nevertheless, without additional precautions, an adversary who obtains keys that represent a substantial fraction of stake at some point in the past can compromise the ledger at any point in the future.
The problem is further aggravated in efficient blockchains that delegate signing rights to a small committee of stakeholders, because the adversary can gain control of the chain after corrupting a majority of the committee members.Referred to by different authors as long-range attacks [20], costless simulation [52], and posterior corruptions [12], this problem is best addressed through the use of forward-secure signatures [3,9,41,46].
Here, each signature is associated with the current time period, and a user's secret key can be updated in such a way that it can only be used to sign messages for future time periods, not previous ones.
An adversary that corrupts an honest node can therefore not use the compromised key material to create forks in the past of the chain.
We present the Pixel signature scheme, which is a pairingbased forward-secure multi-signature scheme for use in PoSbased blockchains that achieves substantial savings in bandwidth and storage requirements.
To support a total of T time periods and a committee of size N, the multi-signature comprises just two group elements and verification requires only three pairings, one exponentiation, and N − 1 multiplications.
Pixel signatures are almost as efficient as BLS multisignatures, as depicted in Figure 1, but also satisfy forwardsecurity; moreover, like in BLS multi-signatures, anybody can non-interactively aggregate individual signatures into a multi-signature.
Our construction builds on prior forward-secure signatures based on hierarchical identity-based encryption (HIBE) [14,18,22,26] and adds the ability to securely aggregate signatures on the same message as well as to generate public parameters without trusted set-up.
We achieve security in the random oracle model under a variant of the bilinear Diffie-Hellman inversion assumption [11,14].
At a very high level, the use of HIBE techniques allows us to compress O(log T ) group elements in a treebased forward-secure signature into two group elements, and secure aggregation allows us to compress N signatures under N public keys into a single multi-signature of the same size as a single signature.To validate Pixel's design, we compared the performance of a Rust implementation [1] of Pixel with previous forwardsecure tree-based solutions.
We show how to integrate Pixel into any PoS blockchain.
Next, we evaluate Pixel on the Algorand blockchain, showing that it yields notable savings in storage, bandwidth, and block verification time.
Our experimental results show that Pixel is efficient as a stand-alone primitive and in use in blockchains.
For instance, compared to a set of N = 1500 tree-based forward-secure signatures (for T = 2 32 ) at 128-bit security level, a single Pixel signature that can authenticate the entire set is 2667x smaller and can be verified 40x faster (c.f. Tables 1 and 3).
Pixel signatures reduce the size of Algorand blocks with 1500 transactions by ≈ 35% and reduce block verification time by ≈ 38% (c.f. Figures 3 and 4).
Multi-signatures can be used to generate a single short signature validates that a message m was signed by N different parties [6,10,13,31,35,43,44,48,50], Multi-signatures based on the BLS signature scheme [13,15,16,53] are particularly well-suited to the distributed setting of PoS blockchains as no communication is required between the signers; anybody can aggregate individual signatures into a multi-signature.
However, these signatures are not forward-secure.
Tree-based forward-secure signatures [9,36,41,46] can be used to meet the security requirements, but they are not very efficient in an N-signer setting because all existing constructions have signature size at least O(N log T ) group elements, where T is an upper bound on the number of time periods.
Some schemes derived from hierarchical identity-based encryption (HIBE) [14,18,22] can bring that down to O(N) group elements, which is still linear in the number of signers.The only forward-secure multi-signature schemes that appeared in the literature so far have public key length linear in the number of time periods T [45] or require interaction between the signers to produce a multi-signature [55], neither of which is desirable in a blockchain scenario.
The forwardsecure multi-signature scheme of Yu et al. [61] has signature length linear in the number of signers, so is not really a multisignature scheme.Combining the generic tree-based forward-secure signature scheme of Bellare-Miner [9] with BLS multi-signatures [13,16] gives some savings, but still requires O(T ) "certificates" to be included in each multi-signature.
Batch verification [8] can be used to speed up verification of the certificates to some extent, but does not give us any space savings.
Compared with existing tree-based forward-secure signatures in [9,36,41,46], our savings are two-fold:• we reduce the size of the signature set for N commit-scheme key update sign verify |σ| |pk| |sk| forward security BLS multi-signatures [13,15,53] -1 exp 2 pair 1 1 O(1) no Pixel multi-signatures (this work) 2 exp 4 exp 3 pair + 1 exp 2 1 O((log T ) 2 ) yes Figure 1: Comparing our scheme with BLS signatures.
Here, "exp" and "pair" refer to number of exponentiations and pairings respectively.
T denotes the maximum number of time periods.
We omit additive overheads of O(log T ) multiplications.
The column "key update" refers to amortized cost of updating the key for time t to t + 1.
The columns |σ|, |pk|, and |sk| denote the sizes of signatures, public keys, and secret keys, respectively, in terms of group elements.
Aggregate verification for N signatures requires an additional N − 1 multiplications over basic verification.tee members from O(N log T ) group elements 1 to O(1) group elements; and• we reduce the verification time from O(N) exponentiations to O(1) exponentiation and O(N) multiplications.
The rest of this paper is organized as follows:• In Section 2, we give a high level technical description of our new pairing-based forward-secure multi-signature scheme.
• In Sections 4 and 5, we describe the scheme in details.We prove the security of the construction in the random oracle model under a variant of a bilinear Diffie-Hellman inversion problem.
• In Section 6, we explain how to apply Pixel to PoS blockchains to solve posterior corruptions.
• In Section 7, we evaluate the efficiency savings for storage, bandwidth, and block verification time from using Pixel on the Algorand PoS blockchain.
Our construction builds on prior forward-secure signatures based on hierarchical identity-based encryption (HIBE) [14,18,22,26] and adds the ability to securely aggregate signatures on the same message as well as to generate public parameters without trusted set-up.
Overview of our scheme.
Starting with a bilinear group (G 1 , G 2 , G t ) with e : G 1 × G 2 → G t of prime order q and generators g 1 , g 2 for G 1 , G 2 respectively, a signature on M ∈ Z q at time t under public key g x 2 is of the form:σ = (σ , σ ) = (h x · F(t, M) r , g r 2 ) ∈ G 1 × G 2where the function F(t, M) can be computed with some public parameters (two group elements in G 1 in addition to h ∈ G 1 ) and r is fresh randomness used for signing.
Verification relies on the relation:e(σ , g 2 ) = e(h, y) · e(F(t, M), σ )and completeness follows directly:e(σ , g 2 ) = e(h x · F(t, M) r , g 2 ) = e(h x , g 2 ) · e(F(t, M) r , g 2 ) = e(h, g x 2 ) · e(F(t, M), g r 2 ) = e(h, y) · e(F(t, M), σ ) .
Note that e(h, y) can be precomputed to save verification computation.Given N signatures σ 1 , . . . , σ N ∈ G 1 × G 2 on the same message M at time t under N public keys g x 1 2 , . . . , g x N 2 , we can produce a multi-signature Σ on M by computing the coordinate-wise product of σ 1 , . . . , σ N .
Concretely, if σ i = (h x i · F(t, M) r i , g r i 2 ), thenΣ = (h x 1 +···+x N · F(t, M) r , g r 2 )where r = r 1 + · · · + r N .
To verify Σ, we first compute a single aggregate public key that is a compressed version of all N individual public keysapk ← y 1 · . . . · y N ,and verify Σ against apk using the standard verification equation.How to generate and update keys.
To complete this overview, we describe a simplified version of the secret keys and update mechanism, where the secret keys are of size O(T ) instead of O((log T ) 2 ).
The construction exploits the fact that the function F satisfiesF(t, M) = F(t, 0) · F Mfor some constant F .
This means that in order to sign messages at time t, it suffices to knowsk t = {h x · F(t, 0) r , F r , g r 2 }from which we can compute (h x · F(t, M) r , g r 2 ).
The secret key sk t for time t is given by:sk t , sk t+1 , · · · , sk Tgenerated using independent randomness.
To update from the key sk t to sk t+1 , we simply erase sk t .
Forward security follows from the fact that an adversary who corrupts a signer at time t only learns sk t and, in particular, does not learn sk t for t < t, and is unable to create signatures for past time slots.To compress the secret keys down to O((log T ) 2 ) without increasing the signature size, we combine the tree-based approach in [22] with the compact HIBE in [14].
Roughly speaking, each sk t now contains log T sub-keys, each of which contains O(log T ) group elements and looks like an "expanded" version of sk t .
(In the simplified scheme, each sk t contains T − t + 1 sub-keys, each of which contains three group elements.)
Security against rogue-key attacks.
The design of multisignature schemes must take into account rogue-key attacks, where an adversary forges a multi-signature by providing specially crafted public keys that are correlated with the public keys of the honest parties.
We achieve security against roguekey attacks by having users provide a proof of possession of their secret key [13,53]; it suffices here for each user to provide a standard BLS signature y on its public key y (cf. the proof π in the key generation and verification algorithms in Section 5.2).
Avoiding trusted set-up.
Note that the common parameters contain uniformly random group elements h, h 0 , . . . , h log T in G 2 which are used to define the function F.
These elements can be generated using a indifferentiable hash-to-curve algorithm [19,60] evaluated on some fixed sequence of inputs (e.g. determined by the digits of pi), thereby avoiding any trusted set-up.
Related works.
The use of HIBE schemes for forward secrecy originates in the context of encryption [22] and has been used in signatures [18,26], key exchange [33] and proxy re-encryption [30].
Our signature scheme is quite similar to the forward-secure signatures of Boyen et al. [18] and achieves the same asymptotic complexity; their construction is more complex in order to achieve security against untrusted updates.
The way we achieve aggregation is similar to the multi-signatures in [43].
Alternative approaches to posterior security.
There are two variants of the posterior attack: (i) a short-range variant, where an adversary tries to corrupt a committee member prior to completion of the consensus sub-protocol, and (ii) a long-range variant as explained earlier.
Dfinity [34], Ouroboros [39] and Casper [21] cope with the short-range attacks by assuming a delay in attacks that is longer than the running time of the consensus sub-protocol.
For long-range attacks, Casper adopts a fork choice rule to never revert a finalized block, and in addition, assumes that clients log on with sufficient regularity to gain a complete update-to-date view of the chain.
We note that forward-secure signatures provide a clean solution against both attacks, without the need for fork choice rules or additional assumptions about the adversary and the clients.Application to permissioned blockchains.
Consensus protocols, such as PBFT, are also at the core of many permissioned blockchains (e.g. Hyperledger), where only approved parties may join the network.
Our signature scheme can similarly be applied to this setting to achieve forward secrecy, reduce communication bandwidth, and produce compact block certificates.
Let G 1 , G 2 , G t be multiplicative groups of prime order q with a non-degenerate pairing function e :G 1 × G 2 → G t .
Let g 1 and g 2 be generators of G 1 and G 2 , respectively.In analogy with the weak bilinear Diffie-Hellman inversion problem -wBDHI * [14], which was originally defined for Type-1 pairings (i.e., symmetric pairings where we have G 1 = G 2 ), we define the following variant for Type-3 pairings denoted -wBDHI * 3 .
Input:A 1 = g α 1 , A 2 = g (α 2 ) 1 , . . . , A = g (α ) 1 , B 1 = g α 2 , B 2 = g (α 2 ) 2 , . . . , B = g (α ) 2 , C 1 = g γ 1 , C 2 = g γ 2 for α, γ ← $ Z q Compute: e(g 1 , g 2 ) (γ·α +1 )The advantage Adv-wBDHI * 3 G 1 ×G 2(A) of an adversary A is defined as its probability in solving this problem.As shown in [14], the assumption holds in the generic bilinear group model, with a lower bound of Ω( q//) (with a matching attack in [25]).
Concretely, for the BLS12-381 pairing-friendly curve with = 32, the best attack has complexity roughly 2 125 .
Alternatively, our scheme could be proved secure under a variant of the above assumption where the adversary has to output g(α +1 ) 1given as input A 1 , . . . , A , B 1 , . . . , B and given access to an oracle ψ : g x 2 → g x 1 .
Because of the ψ oracle, this assumption is incomparable to the -wBDHI assumption described above.
We begin by describing a forward-secure signature scheme, and then extend the construction to a multi-signature scheme in Section 5.
We use the Bellare-Miner model [9] to define syntax and security of a forward-secure signature scheme.
A forwardsecure signature scheme FS for a message space M consists of the following algorithms:Setup: pp ← $ Setup(T ).
All parties agree on the public parameters pp.
The setup algorithm mainly fixes the distribution of the parameters given the maximum number of time periods T .
The parameters may be generated by a trusted third party, through a distributed protocol, or set to "nothingup-my-sleeve" numbers.
The public parameters are taken to be an implicit input to all of the following algorithms.Key generation: (pk, sk 1 ) ← $ Kg.
The signer runs the key generation algorithm on input the maximum number of time periods T to generate a public verification key pk and an initial secret signing key sk 1 for the first time period.Key update: sk t+1 ← $ Upd(sk t ).
The signer updates its secret key sk t for time period t to sk t+1 for the next period using the key update algorithm.
The scheme could also offer a "fast-forward" update algorithm sk t ← $ Upd (sk t ,t ) for any t > t that is more efficient than repetitively applying Upd.Signing: σ ← $ Sign(sk t , M).
On input the current signing key sk t and message M ∈ M, the signer uses this algorithm to compute a signature σ.Verification.
b ← Vf(pk,t, M, σ).
Anyone can verify a signature σ for on message M for time period t under public key pk by running the verification algorithm, which returns 1 to indicate that the signature is valid and 0 otherwise.
Correctness requires that for all messages M ∈ M and for all time periods t ∈ [T ] it holds thatPr[Vf(pk,t, M, Sign(sk t , M)) = 1] = 1where the coin tosses are over pp ← $ Setup(T ), (pk, sk 1 ) ← $ Kg, and sk i ← Upd(sk i−1 ) for i = 2, . . . ,t. Moreover, if the scheme has a fast-forward update algorithm, then the keys it produces must be distributed identically to those produced by repetitive application of the regular update algorithm.
Meaning, for all t,t ∈ [T ] with t < t ≤ T and for all sk t it holds that sk t ← $ Upd (sk t ,t ) follows the same distribution as sk t produced as sk i ← $ Upd(sk i−1 ) for i = t + 1, . . . ,t .
Unforgeability under chosen-message attack for forwardsecure signatures is defined through the following game.
The experiment generates a fresh key pair (pk, sk 1 ) and hands the public key pk to the adversary A.
The adversary is given access to the following oracles:Key update.
If the current time period t (initially set to t = 1) is less than T , then this oracle updates the key sk t to sk t+1 and increases t.Signing.
On input a message M, this oracle runs the signing oracle with the current secret key sk t and message M, and returns the resulting signature σ.Break in.
The experiment records the break-in time ¯ t ← t and hands the current signing key sk¯ t to the adversary.
This oracle can only be queried once, and after it has been queried, the adversary can make no further queries to the key update or signing oracles.At the end of the game, the adversary outputs its forgery (t * , M * , σ * ).
It wins the game if σ * verifies correctly under pk for time period t * and message M * , if it never queried the signing oracle on M * during time period t * , and if it queried the break-in oracle, then it did so in a time period ¯ t > t * .
We define A's advantage Adv fu-cma F S (A) as its probability in winning the above game.We also define a selective variant of the above notion, referred to as sfu-cma, where the adversary first has to commit to ¯ t, t * , and M * .
More specifically, A first outputs (¯ t,t * , M * ), then receives the public key pk, is allowed to make signature and key update queries until time period t = ¯ t is reached, at which point it is given sk¯ t and outputs its forgery σ * .
Following [22], we associate time periods with all nodes of the tree according to a pre-order traversal.
Prior tree-based forward-secure signatures [9,46] associate time periods with the only leaf nodes; using all nodes allows us to reduce the amortized complexity of key updates from O(log T ) exponentiations to O(1) exponentiations.Recall that a tree of depth − 1 has 2 − 1 nodes, which then correspond to time periods in [2 − 1].
We will identify the nodes of the tree of depth − 1 with strings in {1, 2} ≤−1 where 1 denotes taking the left branch and 2 denotes taking the right branch.
We work with {1, 2} instead of {0, 1} for technical reasons: roughly speaking, in the scheme, we need to work with strings of length exactly − 1, which we obtain by padding strings in {1, 2} ≤−1 with zeroes.We can also describe the association explicitly as a bijection between t = t 1 t 2 . . . ∈ {1, 2} ≤−1 and t ∈ [2 − 1] for any integer given byt(t) = 1 + |t| ∑ i=1 (1 + 2 −i (t i − 1)) .
For instance, for = 3, this maps ε, 1, 11, 12, 2, 21, 22 to 1, 2, 3, 4, 5, 6, 7.
The inverse of the bijection can be described ast(1) = ε t(t) = t(t − 1)1 if |t(t − 1)| < − 1 t(t) = ¯ t2 if |t(t − 1)| = − 1where ¯ t is the longest string such that ¯ t1 is a prefix of t(t − 1).
The bijection induces a natural precedence relation over {1, 2} ≤−1 where t t iff either t is a prefix of t or exists ¯ t s.t. ¯ t1 is a prefix of t and ¯ t2 is a prefix of t .
We also write t, t + 1 corresponding to t,t + 1.
Next, we associate any t ∈ {1, 2} ≤−1 with a set Γ t ⊂ {1, 2} ≤−1 given byΓ t := t ∪ ¯ t2 : ¯ t1 prefix of tthat corresponds to the set containing t and all the right-hand siblings of nodes on the path from t to the root, which also happens to be the smallest set of nodes that includes a prefix of all t t. For instance, for = 3, we haveΓ 1 = {1, 2}, Γ 11 = {11, 12, 2}, Γ 12 = {12, 2} .
The sets Γ t satisfy the following properties:• t t iff there exists u ∈ Γ t s.t. u is a prefix of t ;• For all t, we haveΓ t+1 = Γ t \ {t} if |t| = − 1 or Γ t+1 = (Γ t \ {t}) ∪ { t1, t2 } otherwise;• For all t t, we have that for all u ∈ Γ t , there exists u ∈ Γ t such that u is a prefix of u .
The first property is used for verification and for reasoning about security; the second and third properties are used for key updates.
We assume the bound T is of the form 2 − 1.
We use the above bijection so that the algorithms take input t ∈ {1, 2} ≤−1 instead of t ∈ [T ].
The following scheme is roughly the result of applying the Canetti-Halevi-Katz technique to obtain forward security from hierarchical identity-based encryption (HIBE) [23] to the signature scheme determined by the key structure of the Boneh-Boyen-Goh HIBE scheme [14]; we describe the differences at the end of this subsection.Setup.
Let M be the message space of the scheme and let H q : M → {0, 1} κ be a hash function that maps messages to bit strings of length κ such that 2 κ < q. Apart from the description of the groups, the common system parameters also contain the maximum number of time slots T = 2 − 1 and random group elements h, h 0 , . . . , h ← $ G 1 .
These parameters could, for example, be generated as the output of a hash function modeled as a random oracle.Key generation.
Each signer chooses x ← $ Z q and computes y ← g x 2 .
It sets its public to pk = y and computes its initial secret key sk 1 ← { sk ε } wheresk ε = g r 2 , h x h r 0 , h r 1 , . . . , h r for r ← $ Z q .
Key update.
We associate with each w ∈ {1, 2} k with k ≤ − 1 a key sk w of the formsk w = (c, d, e k+1 , . . . , e ) = g r 2 , h x (h 0 k ∏ j=1 h w j j ) r , h r k+1 , . . . , h r(1)for r ← $ Z q .
Given sk w , one can derive a key for any w ∈ {1, 2} k which contains w as a prefix as(c , d , e k +1 , . . . , e ) = c·g r 2 , d · k ∏ j=k+1 e w j j ·(h 0 k ∏ j=1 h w j j ) r , e k +1 · h r k +1 , . . . , e · h r(2)for r ← $ Z q .
The secret key sk t at time period t is given bysk t = { sk w : w ∈ Γ t } ,which, by the first property of Γ t , contains a key sk w for a prefix w of all nodes t t.To perform a regular update of sk t to sk t+1 , the signer users the second property of Γ t .
Namely, if |t| < − 1, then the signer looks upsk t = (c, d, e |t|+1 , . . . , e ) ∈ sk t , computes sk t1 ← (c, d · e |t|+1 , e |t|+2 , . . . , e ) ,and derives sk t2 from sk t using Equation (2).
The signer then sets sk t+1 ← (sk t \ sk t ) ∪ { sk t1 , sk t2 } and securely deletes sk t as well as the re-randomization exponent r used in the derivation of sk t2 .
If |t| = − 1, then the signer simply sets sk t+1 ← sk t \ { sk t } and securely deletes sk t .
To perform a fast-forward update of its key to any time t t, the signer derives keys sk w for all nodes w ∈ Γ t \ Γ t by applying Equation (2) to the key sk w ∈ sk t such that w is a prefix of w , which must exist due to the third property of Γ t .
The signer then sets sk t ← { sk w : w ∈ Γ t } and securely deletes sk t as well as all re-randomization exponents used in the key derivations.Signing.
To generate a signature on message M ∈ M in time period t ∈ {1, 2} ≤−1 , the signer looks up sk t = (c, d, e |t|+1 , . . . , e ) ∈ sk t , chooses r ← $ Z q , and outputs(σ 1 , σ 2 ) = d · e H q (M) · h 0 · |t| ∏ j=1 h t j j · h H q (M) r , c · g r 2 .
Verification.
Anyone can verify a signature (σ 1 , σ 2 ) ∈ G 1 × G 2 on message M under public key pk = y in time period t by checking whethere(σ 1 , g 2 ) = e(h, y) · e h 0 · |t| ∏ j=1 h t j j · h H q (M), σ 2 .
Note that the pairing e(h, y) can be pre-computed from the public key ahead of time, so that verification only requires two pairing computations.Differences from prior works.
We highlight the differences between our scheme and those in [14,18,22], assuming some familiarity with these prior constructions.
• We rely on asymmetric bilinear groups for efficiency, and our signature sits inG 2 × G 1 instead of G 2 2 .
This way, it is sufficient to give out the public parameters h 0 , . . . , h in G 1 (which we can then instantiate using hash-to-curve without trusted set-up) instead of having to generate "consistent" public parameters(h i , h i ) = (g x i 1 , g x i 2 ) ∈ G 1 × G 2 .
• Our key-generation algorithm also deviates from that in the Boneh-Boyen-Goh HIBE, which would setpk = e(g 1 , g 2 ) x , h = g 1 , sk ε = g r 2 , g x 1 h r 0 , h r 1 , . . . , h r .
In our scheme, pk = g x 2 lies in G 2 instead of G t and is therefore smaller.
Setting h to be random instead of g 1 also allows us to achieve security under weaker assumptions.
In fact, setting h = g 1 and pk = g x 2 would yield an insecure scheme in symmetric pairing groups whereg 1 = g 2 , since h x = g x 1 = g x 2 = pk.
We say that a secret key sk t for time period t is well-formed if sk t = { sk w : w ∈ Γ t }, where each sk w is of the form of Equation (1) for an independent uniformly distributed exponent r ← $ Z q .
We first show that all honestly generated and updated secret keys are well-formed, and then proceed to the verification of signatures.The key sk t is trivially well-formed for t = 1, i.e., t = ε, as can be seen from the key generation algorithm.
We now show that sk t is also well-formed after a regular update from time t to t + 1 and after a fast-forward update from t to t t.In a regular update, assume that sk t is well-formed.
If |t| = − 1, then the update procedure sets sk t+1 ← sk t \ { sk t }, which by the second property of Γ t and the induction hypothesis means that sk t+1 is also well-formed.
If |t| < − 1, the update procedure adds keys sk t1 and sk t2 and removes sk t from sk t , which by the second property of Γ t indeed corresponds to {w : w ∈ Γ t+1 }.
Moreover, sk t1 is derived from sk t = sk t1 ← (c, d, e |t|+1 , . . . , e ) as sk t1 ← (c, d · e |t|+1 , e |t|+2 , . . . , e ), which satisfies Equation (1) with randomness r that is independent from all other keys in sk t+1 because sk t ∈ sk t+1 .
Similarly, sk t2 satisfies Equation (1) because it is generated asc = c · g r 2 = g r+r 2 d = d · e k+1 · (h 0 k ∏ j=1 h t j j · h w k+1 k+1 ) r = h x (h 0 k ∏ j=1 h t j j · h 2 k+1 ) r+r e k+2 = e k+2 · h r k+2 = h r+r k+2. . .e = e · h r = h r+rsatisfying Equation (1) with randomness r + r , which is independent of the randomness of other keys in sk t+1 due to the uniform choice of r .
For the fast-forward update procedure, one can see that if sk t is well-formed, then the updated key sk t for t t is wellformed as well.
Indeed, by adding the keys for nodes in Γ t \Γ t and removing those for Γ t \Γ t , we have that sk t contains keys sk w for all w ∈ Γ t .
The randomness independence is guaranteed by the random choice of r in Equation (2).
In the optimized variant, all keys still have independent randomness because one key sk w ∈ sk t will have the same randomness r as some key sk w ∈ sk t where w is a prefix of w .
That randomness is independent from all other keys in sk t , however, because the key sk w does not occur in sk t .
Indeed, by the definition of Γ t , one can see that Γ t cannot have elements w = w with w a prefix of w .
To see why signature verification works, observe that a signature for time period t and message M is computed from a key sk t = (c, d, e |t|+1 , . . . , e ) in a well-formed key sk t .
The left-hand side of the verification equation is thereforee(σ 1 , g 2 ) = e d · e H q (M) · h 0 · |t| ∏ j=1 h t j j · h H q (M) r , g 2 = e h x h 0 · |t| ∏ j=1 h t j j · h H q (M) r+r , g 2 = e(h x , g 2 ) · e h 0 · |t| ∏ j=1 h t j j · h H q (M) , g 2 r+r = e(h, y) · e h 0 · |t| ∏ j=1 h t j j · h H q (M), σ 2 .
Theorem 1.
For any fu-cma adversary A against the above forward-secure signature scheme in the random-oracle model for T = 2 − 1 time periods, there exists an adversary B with essentially the same running time and advantage in solving the -wBDHI * 3 problemAdv -wBDHI * 3 G 1 ×G 2 (B) ≥ 1 T · q H · Adv fu-cma F S (A) − q 2 H 2 κ ,where q H is the number of random-oracle queries made by A.We refer the interested reader to Appendix A for the full proof of security.
To obtain a multi-signature scheme, we observe that the component-wise product(Σ 1 , Σ 2 ) = (∏ n i=1 σ i,1 , ∏ n i=1 σ i,2) of a number of signatures (σ 1,1 , σ 1,2 ), . . . , (σ n,1 , σ n,2 ) satisfies the verification equation with respect of the product of public keys Y = y 1 · . . . · y n .
This method of combining signatures is vulnerable to a rogue-key attack, however, where a malicious signer chooses his public key based on that of an honest signer, so that the malicious signer can compute valid signatures for their aggregated public key.
The scheme below borrows a technique due to Ristenpart and Yilek [53] using proofs of possession (denote by π below) to prevent against these types of attack.
In addition to the algorithms of a forward-secure signature scheme in Section 4.1, a forward-secure multi-signature scheme FMS in the key verification model has a key generation that additionally outputs a proof π for the public key:Key generation: (pk, π, sk 1 ) ← $ Kg.
The key generation algorithm generates a public verification key pk, a proof π, and an initial secret signing key sk 1 for the first time period.
and additionally has the following algorithms:Key verification: b ← KVf(pk, π).
The key verification algorithm returns 1 if the proof pk is valid for pk and returns 0 otherwise.Key aggregation: apk ← $ KAgg(pk 1 , . . . , pk n ).
On input a list of individual public keys (pk 1 , . . . , pk n ), the key aggregation returns an aggregate public key apk, or ⊥ to indicate that key aggregation failed.Signature aggregation.
Σ ← $ SAgg((pk 1 , σ 1 ), . . . , (pk n , σ n ),t, M).
Anyone can aggregate a given list of individual signatures (σ 1 , . . . , σ n ) by different signers with public keys (pk 1 , . . . , pk n ) on the same message M and for the same period t into a single multi-signature Σ.Aggregate verification.
b ← AVf(apk,t, M, Σ).
Given an aggregate public key apk, a message M, a time period t, and a multi-signature Σ, the verification algorithm returns 1 to indicate that all signers in apk signed M in period t, or 0 to indicate that verification failed.Correctness.
Correctness requires that KVf(pk, π) = 1 with probability one if (pk, π, sk 1 ) ← $ Kg and that for all messages M ∈ M, for all n ∈ Z, and for all time periods t ∈ {0, . . . , T − 1}, it holds that AVf(apk,t, M, Σ) = 1 with probability one if (pk i , π i , sk i,1 ) ← $ Kg, apk ← $ KAgg(pk 1 , . . . , pk n ), sk i, j ← $ Upd(sk i, j−1 ) for i = 1, . . . , n and j = 2, . . . ,t, σ i ← $ Sign(sk i,t , M) for i = 1, . . . , n, and Σ ← $ SAgg((pk 1 , σ 1 ), . . . , (pk n , σ n ),t, M).
Security.
Unforgeability (fu-cma) is defined through a game that is similar to that described in Section 4.1.
The adversary is given the public key pk and proof π of an honest signer and access to the same key update, signing, and break-in oracles.
However, at the end of the game, the adversary's forgery consists of a list of public keys and proofs • and A never made a signing query for M * during time period t * .
(pk * 1 , π * 1 , . . . , pk * n , π * n ),Our security model covers rogue-key attacks because the adversary first receives the target public key pk, and only then outputs the list of public keys pk * 1 , ..., pk * n involved in its forgery.
The only condition on these public keys is that they are accompanied by valid proofs π * 1 , ..., π * n .
Let H G 1 : {0, 1} * → G * 1 be a hash function.
The multisignature scheme reuses the key update and signature algorithms from the scheme from Section 4.3, but uses different key generation and verification algorithms, and adds signature and key aggregation.Key generation.
Each signer chooses x ← $ Z q and computes y ← g x 2 and y ← H G 1 (PoP, y), where PoP is a fixed string used as a prefix for domain separation.
It sets its public key to pk = y, the proof to π = y , and computes its initial secret key as sk 1 ← h x .
Key verification.
Given a public key pk = y with proof π = y , the key verification algorithm validates the proof of possession by returning 1 ife(y , g 2 ) = e(H G 1 (PoP, y), y)and returning 0 otherwise.Key aggregation.
Given public keys pk 1 = y 1 , . . . , pk n = y n , the key aggregation algorithm computes Y ← ∏ n i=1 y i and returns the aggregate public key apk = Y .
Signature aggregation.
Given signatures σ 1 = (σ 1,1 , σ 1,2 ), . . . , σ n = (σ n,1 , σ n,2 ) ∈ G 1 × G 2 on the same message M, the signature aggregation algorithm outputsΣ = (Σ 1 , Σ 2 ) = n ∏ i=1 σ i,1 , n ∏ i=1 σ i,2 .
Aggregate verification.
Multi-signatures are verified with respect to aggregate public keys in exactly the same way as individual signatures with respect to individual public keys.
Namely, given a multi-signature (Σ 1 , Σ 2 ) ∈ G 1 × G 2 on message M under aggregate public key apk = Y in time period t, the verifier accepts if and only if apk = ⊥ ande(Σ 1 , g 2 ) = e(h,Y ) · e h 0 · |t| ∏ j=1 h t j j · h H q (M) +1, Σ 2 .
Theorem 2.
For any fu-cma adversary A against the above forward-secure multi-signature scheme for T = 2 − 1 time periods in the random-oracle model, there exists an adversary B with essentially the same running time that solves the -wBDHI * 3 problem with advantageAdv -wBDHI * 3 G 1 ×G 2 (B) ≥ 1 T · q H · Adv fu-cma F MS (A) − q 2 H 2 κ ,where q H is the number of random-oracle queries made by A.We defer the interested reader to Appendix B for proof details.
In this section, we describe how to integrate Pixel into PoSbased blockchains that rely on forward-secure signatures to achieve security against posterior corruptions.
We summarize systems that rely on forward-secure signatures, abstract how signatures are used in these systems, and explain how to apply Pixel.
Ouroboros Genesis and Praos rely on forward-secure signatures to protect against posterior corruptions [5,29,38].
These blockchains require users to rotate key and assume secure erasures.
Thuderella is a blockchain with fast optimistic instant confirmation [51].
The blockchain is secure against posterior corruptions assuming that a majority of the computing power is controlled by honest players.
Similarly, the protocol relies on forward-secure signatures.
Pixel can be applied in all these blockchains to protect against posterior attacks and potentially reduce bandwidth, storage, and computation costs in instances where many users propagate many signatures on the same message (e.g., a block of transactions).
Ouroboros Crypsinous uses forward-secure encryption to protect against the same attack [37].
Snow White shows that under a mild setup assumption, when nodes join the system they can access a set of online nodes the majority of whom are honest, the system can defend against posterior corruption attack [28].
The system does not rely on forward-secure signatures.Background on PoS Blockchains.
A blockchain is an append-only public ledger to which anyone can write and read.
The fundamental problem in blockchains is to agree on a block of transactions between users.
In Proof-of-Stake protocols, users map the stake or tokens they own in the system to "voting power" in the agreement protocol.
Various types of PoS systems exist that use different formulas for determining the weight of each vote.
For instance, in bounded PoS protocols, users must explicitly lock some amount A of their tokens to participate in the agreement.
The weight of each vote is A/Q, where Q is the total number of locked tokens who's users wish to participate in the agreement.
Users that misbehave are punished by a penalty applied to their locked tokens.To tolerate malicious users, all PoS protocols run a Byzantine sub-protocol to agree on a block of transactions.
The system is secure, assuming that that majority (often 2/3) of the tokens participating in the consensus is honest.
Each block is valid if a majority of committee members, weighted by their stake, approved it.Pixel Integration.
In order to vote on a block B, each member of the sub-protocol signs B using Pixel with the current block number.
The consensus is reached when we see a collection of N committee member signatures σ 1 , . . . , σ N on the same block B, where N is some fixed threshold.
Finally, we will aggregate these N signatures into a single multi-signature Σ, and the pair (B, Σ) constitute a so-called block certificate and the block B is appended to the blockchain.Registering public keys.
Each user who wishes to participate in consensus needs to register a participation signing key.
A user first samples a Pixel key pair and generates a corresponding PoP.
The user then issues a special transaction (signed under her spending key) registering the new participation key.
The transaction includes PoP.
PoS verifiers who are selected to run an agreement at round r, check (a) validity of the special transaction, and (b) validity of PoP.
If both checks pass, the user's account is updated with the new participation key.
From this point, if selected, the user signs on blocks using Pixel.Vote generation.
To generate a vote on a block number t, users first update their keys to correspond to the round number.
Subsequently, they sign the block using the correct secret key and propagate the signature to the network.Propagating and aggregating signatures.
Individual committee signatures will be propagated through the network until we see N committee member signatures on the same block B. Note that Pixel supports non-interactive and incremental aggregation: the former means that signatures can be aggregated by any party after broadcast without communicating with the original signers, and the latter means that we can add a new signature to a multi-signature to obtain a new multi-signature.
In practice, this means that propagating nodes can perform intermediate aggregation on any number of committee signatures and propagate the result, until the block certificate is formed.
Alternatively, nodes can aggregate all signatures just before writing a block to the disk.
That is, upon receiving enough certifying votes for a block, a node can aggregate N committee members' signatures into a multisignature and then write the block and the certificate to the disk.
To speed up verification of individual committee member signatures, a node could pre-compute e(h, y) for the y's corresponding to the users with the highest stakes.Key updates.
When using Pixel in block-chains, time corresponds to the block number or sub-steps in consensus protocols.
Naively, when associating time with block numbers, this means that all eligible committee members should update their Pixel secret keys for each time a new block is formed and the round number is updated.
Assume for simplicity that each committee member signs at most one block (if not, simply append a counter to the block number and use that as the time).
If a user is selected to be on the committee at block number t, it should first update its key to sk t (Pixel supports "fast-forward" key updates from sk t to sk t for any t > t), and as soon as it signs a block, updates its key to sk t+1 and then propagates the signature.
In particular, there is no need for key updates when a user is not selected to be on the committee.
In order to measure the concrete efficiency gains of Pixel, we evaluate it on the Algorand blockchain [56,57].
Algorand Overview.
Algorand is a Pure PoS (PPOS) system, where each token is mapped to a single vote in the consensus without any explicit bonding [56,57].
Some users may opt-out from participation, in which case their tokens are excluded from the total number of participating tokens (i.e., the denominator in the weight).
Each user maintains an account state on-chain that specifies her spending key, balance, consensus participation status, participation key, and other auxiliary information.
A user wishing to perform a transaction must sign it with her corresponding secret key.
Users run a Byzantine consensus algorithm to agree on a block of transactions following the high-level structure we outlined in the previous section.
We call a block certificate to denote a collection of votes above a certain threshold approving a block.
All users in the network validate and store block certificate (and the corresponding transactions) on disk.
We refer to a node as a computer system running Algorand client software on the user's behalf.Verifier Vote Structure and Block Certificates.
In Algorand, each valid vote for a block proposal includes (a) a proof that the verifier was indeed selected to participate in the consensus at round r, and (b) a signature on the block proposal.
In more detail, each vote includes the following fields:• Sender identifier which is represented by a unique public key registered on-chain (32 bytes).
• Round and sub-step identifiers (8 bytes).
• Block header proposal (32 bytes).
• A seed used as an input to a VRF function for cryptographic sortition (32 bytes).
• VRF credential that proves that the sender was indeed chosen to sign on the block (96 bytes).
• Forward-secure signature authenticating the vote (256 bytes).
Overall, each vote is about 500 bytes (including some additional auxiliary information), half of which is for the forwardsecure signature.Algorand has two voting sub-steps for each round.
In the first sub-step, a supporting set (of expected size 3000) of verifiers is chosen to vote on a block proposal.
In the second sub-step, a certifying set (of expected size 1500) is chosen to finalize the block proposal.
All verifiers' votes propagate in the network during the agreement, but only the certifying votes are stored long-term and sufficient to validate a block in the future.
Larger recovering set (of expected size 10000) is chosen during a network partition for recovery.Algorand's Existing Solution to Posterior Corruptions.
Algorand solves posterior corruptions using forward-secure signatures instantiated with a d-ary certificate tree [9], which we call BM-Ed25519 for convenience.
The root public key of an Ed25519 signature scheme is registered on-chain, and keys associated with the leaves (and subsequently used to sign at each round) are stored locally by the potential verifiers.
For each block at round r a verifier must (a) produce a valid certificate chain from the root public key to the leaf associated with r, and (b) signature of the vote under the leaf key.
Algorand assumes secure erasures and that users delete old keys from their nodes.
BM-Ed25519 is instantiated with 10000-ary tree and depth 2 (supporting approximately 2 26.6 time periods).
Ed25519-based signatures have public keys of 32 bytes and 64 bytes signatures.
Hence, since a valid certificate chain must include the intermediary public keys, the resulting size of each forward-secure signature is 3 × 64 + 2 × 32 = 256 bytes.
Pixel signatures can serve as a replacement of BM-Ed25519 in Algorand following the same design as outlined Section 6.
Setup.
Our experiments are performed on a MacBook Pro, 3.5 GHz Intel Core i7 with 16 GB DDR3.
We use Alogrand's open-source implentations of Pixel signatures, VRF functions, Ed25519 signing, and verification [1,2].
For blockchain applications, since the public key must live on-chain, we choose to place Pixel public keys in G 1 , obtaining smaller public keys and faster key aggregation during verification.
We set the maximum time epoch to T = 2 32 − 1, which is sufficient to rotate a key every second for 136 years.
Figure 2 shows the runtime of individual Pixel algorithms, aggregation, and object sizes for the BLS12-381 curve [7].
Next, we measure quantities that affect all nodes participating in the system: the size of signature sets, bandwidth, and block We clarify that the savings we obtain from Pixel are complementary to those of Vault [42], which is another system built on top of Algorand to improve storage and catch-up speed.
In particular, Vault can be used in conjunction with Pixel to obtain further storage savings.
Vault creates "jumps" between blocks so that the system can confirm block r knowing only block r − k for some parameter k (e.g., k = 100).
Instead of downloading every block, a catch-up node in Vault only needs to download every kth block.
Even using Vault, users would need to download and store about 10 6 blocks for every ≈ 13 years of blockchain operation.
Block Verification Time Savings.
Since verifying a Pixel multi-signature requires only 3 pairings in addition to multiplying all the public keys in the signature set, they are faster to verify than BM-Ed25519 signatures sets.
Table 3 shows that a set of 3000 signatures can be verified about 65x faster.
In Figure 4, we measure the overall savings on block verification time.
Block verification time is broken into three main intervals: (a) time to verify vote signatures, (b) time to verify vote VRF credentials, and (c) time to verify transactions.
In each interval, signature verification dramatically exceeds the time of any additional checks (e.g., check that the transaction amount is higher than the user's balance).
Blocks with 1500 and 5000 transactions can be verified 38% and 29% faster, respectively.
In this work, we focus on improving the speed and security of PoS consensus mechanisms via optimizing its core building block -digital signature scheme.
We design a new pairing-based forward-secure multi-signature scheme, Pixel.
We prove that Pixel is secure in the random oracle model under a variant of Diffie-Hellman inversion problem over bilinear groups.
Pixel is efficient as a stand-alone primitive and results in significant performance and size reduction compared to the previous forward-secure signatures applied in settings where multiple users sign the same message (block).
For d = h x · h 0 · k ∏ i=1 h w i i r = g γ 1 A α · g γ 0 1 −1 ∏ i=1 A −w * i −i+1 A −M * 1 · k ∏ i=1 g γ i 1 A −i+1 w i r = A γ 1 g (α +1 ) 1 · g γ 0 +∑ k i=1 γ i w i 1 A w k −w * k −k+1 · −1 ∏ i=k+1 A −w * i −i+1 A −M * 1 r ,where the third equality holds because w i = w * i for 1 ≤ i < k and w k = w * k .
(Note that in the product notation ∏ −1 i=k+1 above, we let the result of the product simply be the unity element if k + 1 > − 1.)
Let us denote the four factors between parentheses in the last equation as F 1 , F 2 , F 3 , and F 4 , and denote their product as F.
If we letr ← r + α k w * k − w k mod qfor a random r ← $ Z q , then we have thatd = A γ 1 · g (α +1 ) 1 · F r · F α k w * k −w k .
The first and third factors in this product are easy to compute.
The second factor would allow B to compute the solution its -wBDHI * 3 problem as e(g (α +1 ) 1 ,C), so B cannot simply compute it.
The last factor F α k w * k −w k can be written as the product ofF α k w * k −w k 1 = A γ 0 +∑ k i=1 γ i w i w * k −w k k F α k w * k −w k 2 = A −α k −k+1 = g −(α +1 ) 1 F α k w * k −w k 3 = −1 ∏ i=k+1 A −w * i w * k −w k +k−i+1 = −k−2 ∏ i=0 A −w * k+2+i w * k −w k −i F α k w * k −w k 4 = A −M * w * k −w k k+1.
Because 1 ≤ k ≤ − 1, it is clear that all but the second of these can be computed from B's inputs, and that the second cancels out with the factor g From this key (c, d, e k+1 , . . . , e ) for w , B can derive a key for w and compute a signature as in the real signing algorithm.Case 2: t = t * , M = M * .
For a signing query with t = t * but M = M * , B proceeds in a similar way, but derives the signature (σ 1 , σ 2 ) directly.
Algorithm B can generate a valid signature using a similar approach as above, but using the fact that M = M * instead of w k = w * k .
Namely, letting w = t0 −1−|t| , B computes a signatureσ 1 = h x · h 0 · −1 ∏ i=1 h w i i · h M r = g γ 1 A α · g γ 0 1 · −1 ∏ i=1 A −w * i −i+1 · A −M * 1 · −1 ∏ i=1 g γ i 1 · A −i+1 w i · (g γ 1 · A 1 ) M r = A γ 1 · g (α +1 ) 1 · g γ 0 +∑ −1 i=1 γ i w i +γ M 1 · A M−M * 1 r σ 2 = g r 2 by setting r ← r + α M * − M mod qfor r ← $ Z q , so that B can compute (σ 1 , σ 2 ) from its inputs A 1 , . . . , A , B 1 , . . . , B similarly to the case that t = t * .
Break in.
Here, B needs to simulate sk¯ t where t * ¯ t.
This in turn requires simulating sk w for all w ∈ Γ¯ t .
By the first property of Γ¯ t (described in Section 4.2), all of these w are not prefixes of t * and also not prefixes of w * , and we can therefore simulate sk w exactly as before.Forgery.
When A outputs a forgery (σ * 1 , σ * 2 ) that satisfies the verification equatione(σ * 1 , g 2 ) = e(h, y) · e h 0 · |t * | ∏ j=1 h t * j j · h M * , σ * 2 ,then there exists an r ∈ Z q such thatσ * 1 = h α · h 0 · |t * | ∏ i=1 h t * i i · h M * r σ * 2 = g r 2 .
From the way that B chose the parameters h, h 0 , . . . , h , one can see thatσ * 1 = A γ 1 · g (α +1 ) 1 · (g r 1 ) γ 0 +∑ |t * | i=1 γ i t * i +γ M *Note that we do not know g r 1 , so we cannot directly extract g (α +1 ) 1 from σ * 1 .
Instead, observe that we havee(σ * 1 ,C 2 ) = e(A γ 1 ,C 2 ) · e(g (α +1 ) 1 ,C 2 ) · e(C 1 , σ * 2 ) γ 0 +∑ |t * | i=1 γ i t * i +γ M * , We would like to thank Zhenfei Zhang for implementing Pixel as well as his help with Section 7.
In addition, we thank Jens Groth, Nickolai Zeldovich, our shepherd Ari Juels, and the anonymous reviewers for useful feedback.
sProof.
We prove the theorem in two steps.
First, we show that the scheme is selectively secure when the message space M = {0, 1} κ and H q is the identity function, meaning, interpreting a κ-bit string as an integer in Z q .
Step 1: sfu-cma.
We show that the above scheme with message space M = {0, 1} κ and H q the identity function is sfu-cma-secure under the -wBDHI * 3 assumption by describing an algorithm B that, given a successful sfu-cma forger A , solves the -wBDHI * 3 problem.
On input2 ,C), algorithm B proceeds as follows.It first runs A to obtain ( ¯ t, t * , M * ).
That is, A receives sk¯ t and produces a forgery onIt then sets the public key and public parameters aswhere γ, γ 0 , . . . , γ ← $ Z q .
By setting the parameters as such, B implicitly sets x = α.
The reduction allows us to achieve two goals:• extract the value of h x from a forgery on t * , M * (provided by A ), allowing B to easily compute its -wBDHI * 3 solution e(g 1 ,C) (α +1 ) ;• simulate sk w for all w ∈ {0, 1, 2} ≤−1 which are not a prefix of w * ; this would be useful for simulating both the signing and the break-in oracle.Algorithm B responds to A 's oracle queries as follows.Key update.
There is no need for B to simulate anything beyond keeping track of the current time period t.Signing.
We first describe how to answer a signing query for a message M in time period t = t * , and then describe the case that t = t * and M = M * .
Let w ∈ {0, 1, 2} −1 be such that w = t0 −1−|t| .
(This crucially uses the fact that t, t * ∈ {1, 2} * .)
Then, let w = w 1 · · · w k denote the shortest prefix of w which is not a prefix of w * .
Extending the notation of sk w to w ∈ {0, 1, 2} ≤−1 , we describe how B can derive a valid key sk w , from which it is straight-forward to derive both sk w and a signature for t, M. Recall that sk w has the structurefor a uniformly distributed value of r. Focusing on the second from which B can easily compute its output e(gStep 2: fu-cma.
Full fu-cma security for M = {0, 1} * and with H q : M → {0, 1} κ modeled as a random oracle then follows because, given an fu-cma adversary A in the randomoracle model, one can build a sfu-cma adversary A that guesses the time period t * and the index of A's random-oracle query for H q (M * ), and sets ¯ t ← t * + 1.
If A correctly guesses t * , then it can use sk¯ t to simulate A's signature, key update, and break-in queries after time ¯ t until A's choice of break-in time ¯ t , at which point it can hand over sk ¯ t .
If A moreover correctly guessed the index of H q (M * ), and if A never made colliding queries H q (M) = H q (M ) for M = M , then A's forgery is also a valid forgery for A .
Note that for A to be successful, it must hold that ¯ t > t * , so it must hold that ¯ t ≥ ¯ t.
The advantage of A is given bywhere q H is an upper bound on A's number of random-oracle queries.
Together with Equation (3), we obtain the inequality of the theorem statement.
B Security Proof of Forward-Secure MultisignaturesProof.
We show how to construct a forger A for the multisignature scheme yields a forger A for the single-signer scheme of Section 4.3 such thatThe theorem then follows from Theorem 1.
Step 1: simulating A's view.
On input the parameters (T, h, h 0 , . . . , h ) and a public key y for the single-signer scheme, the single-signer forger A chooses r ← $ Z * q and stores (y, ⊥, g r 1 ) in a list L.
It computes y ← y r and runs A on the same common parameters and target public key pk = y and proof π = y .
Observe that π is indeed a valid proof for pk since e(y , g 2 ) = e(H G 1 (PoP, y), y).
Algorithm A answers all of A's key update, signing, and break-in oracle queries, as well as random-oracle queries for H q , by simply relaying queries and responses to and from A 's own oracles.
Queries to the random oracle for H G 1 are answered as follows.Random oracle H G 1 .
On input (PoP, z), A checks whether there already exists a tuple (z, ·, v) ∈ L.
If so, it returns v.
If not, it chooses r ← $ Z * q , computes v ← h r , adds a tuple (z, r, v) to L and returns v.yStep 2: extracting a forgery.
When A outputs its forgeryalgorithm A first verifies the proofs π * 1 , . . . , π * n for public keys pk * 1 , . . . , pk * n and computes the aggregate public key apk * , creating additional entries in L if necessary.
Letand π * i = y i .
Looking ahead, if pk * i passes key verification, then we have y i = (h x i ) r i and since we know r i , we will be able to "extract" h x i ∈ G 1 .
If all keys are valid, then it holds that y i = H G 1 (PoP, y i ) x i for all i = 1, . . . , n. Let apk * = Y be the aggregate public key.
From the aggregate verification equationFor all y i = y, A looks up the tuple (y i , r i , v i ) in L.
We know that v i = h r i , and hence that y i = h r i x i .
By comparing the last equation above to the verification equation of the single-signer scheme, and by observing that y i = h r i x i , we know that the pairis a valid forgery for the single-signer scheme, so A can output M * , t * , (σ * 1 , σ * 2 ) as its forgery.
Proof.
We prove the theorem in two steps.
First, we show that the scheme is selectively secure when the message space M = {0, 1} κ and H q is the identity function, meaning, interpreting a κ-bit string as an integer in Z q .
Step 1: sfu-cma.
We show that the above scheme with message space M = {0, 1} κ and H q the identity function is sfu-cma-secure under the -wBDHI * 3 assumption by describing an algorithm B that, given a successful sfu-cma forger A , solves the -wBDHI * 3 problem.
On input2 ,C), algorithm B proceeds as follows.It first runs A to obtain ( ¯ t, t * , M * ).
That is, A receives sk¯ t and produces a forgery onIt then sets the public key and public parameters aswhere γ, γ 0 , . . . , γ ← $ Z q .
By setting the parameters as such, B implicitly sets x = α.
The reduction allows us to achieve two goals:• extract the value of h x from a forgery on t * , M * (provided by A ), allowing B to easily compute its -wBDHI * 3 solution e(g 1 ,C) (α +1 ) ;• simulate sk w for all w ∈ {0, 1, 2} ≤−1 which are not a prefix of w * ; this would be useful for simulating both the signing and the break-in oracle.Algorithm B responds to A 's oracle queries as follows.Key update.
There is no need for B to simulate anything beyond keeping track of the current time period t.Signing.
We first describe how to answer a signing query for a message M in time period t = t * , and then describe the case that t = t * and M = M * .
Let w ∈ {0, 1, 2} −1 be such that w = t0 −1−|t| .
(This crucially uses the fact that t, t * ∈ {1, 2} * .)
Then, let w = w 1 · · · w k denote the shortest prefix of w which is not a prefix of w * .
Extending the notation of sk w to w ∈ {0, 1, 2} ≤−1 , we describe how B can derive a valid key sk w , from which it is straight-forward to derive both sk w and a signature for t, M. Recall that sk w has the structurefor a uniformly distributed value of r. Focusing on the second from which B can easily compute its output e(gStep 2: fu-cma.
Full fu-cma security for M = {0, 1} * and with H q : M → {0, 1} κ modeled as a random oracle then follows because, given an fu-cma adversary A in the randomoracle model, one can build a sfu-cma adversary A that guesses the time period t * and the index of A's random-oracle query for H q (M * ), and sets ¯ t ← t * + 1.
If A correctly guesses t * , then it can use sk¯ t to simulate A's signature, key update, and break-in queries after time ¯ t until A's choice of break-in time ¯ t , at which point it can hand over sk ¯ t .
If A moreover correctly guessed the index of H q (M * ), and if A never made colliding queries H q (M) = H q (M ) for M = M , then A's forgery is also a valid forgery for A .
Note that for A to be successful, it must hold that ¯ t > t * , so it must hold that ¯ t ≥ ¯ t.
The advantage of A is given bywhere q H is an upper bound on A's number of random-oracle queries.
Together with Equation (3), we obtain the inequality of the theorem statement.
Proof.
We show how to construct a forger A for the multisignature scheme yields a forger A for the single-signer scheme of Section 4.3 such thatThe theorem then follows from Theorem 1.
Step 1: simulating A's view.
On input the parameters (T, h, h 0 , . . . , h ) and a public key y for the single-signer scheme, the single-signer forger A chooses r ← $ Z * q and stores (y, ⊥, g r 1 ) in a list L.
It computes y ← y r and runs A on the same common parameters and target public key pk = y and proof π = y .
Observe that π is indeed a valid proof for pk since e(y , g 2 ) = e(H G 1 (PoP, y), y).
Algorithm A answers all of A's key update, signing, and break-in oracle queries, as well as random-oracle queries for H q , by simply relaying queries and responses to and from A 's own oracles.
Queries to the random oracle for H G 1 are answered as follows.Random oracle H G 1 .
On input (PoP, z), A checks whether there already exists a tuple (z, ·, v) ∈ L.
If so, it returns v.
If not, it chooses r ← $ Z * q , computes v ← h r , adds a tuple (z, r, v) to L and returns v.yStep 2: extracting a forgery.
When A outputs its forgeryalgorithm A first verifies the proofs π * 1 , . . . , π * n for public keys pk * 1 , . . . , pk * n and computes the aggregate public key apk * , creating additional entries in L if necessary.
Letand π * i = y i .
Looking ahead, if pk * i passes key verification, then we have y i = (h x i ) r i and since we know r i , we will be able to "extract" h x i ∈ G 1 .
If all keys are valid, then it holds that y i = H G 1 (PoP, y i ) x i for all i = 1, . . . , n. Let apk * = Y be the aggregate public key.
From the aggregate verification equationFor all y i = y, A looks up the tuple (y i , r i , v i ) in L.
We know that v i = h r i , and hence that y i = h r i x i .
By comparing the last equation above to the verification equation of the single-signer scheme, and by observing that y i = h r i x i , we know that the pairis a valid forgery for the single-signer scheme, so A can output M * , t * , (σ * 1 , σ * 2 ) as its forgery.
