Reverse engineering is a complex process essential to software-security tasks such as vulnerability discovery and malware analysis.
Significant research and engineering effort has gone into developing tools to support reverse engineers.
However, little work has been done to understand the way reverse engineers think when analyzing programs, leaving tool developers to make interface design decisions based only on intuition.
This paper takes a first step toward a better understanding of reverse engineers' processes, with the goal of producing insights for improving interaction design for reverse engineering tools.
We present the results of a semi-structured, observational interview study of reverse engineers (N=16).
Each observation investigated the questions reverse engineers ask as they probe a program, how they answer these questions, and the decisions they make throughout the reverse engineering process.
From the interview responses, we distill a model of the reverse engineering process, divided into three phases: overview, sub-component scanning, and focused experimentation.
Each analysis phase's results feed the next as reverse engineers' mental representations become more concrete.
We find that reverse engineers typically use static methods in the first two phases, but dynamic methods in the final phase, with experience playing large, but varying, roles in each phase.
Based on these results, we provide five interaction design guidelines for reverse engineering tools.
Software reverse engineering is a key task performed by security professionals during vulnerability discovery, malware analysis, and other tasks [1,2], [3, pg.
5-7].
(For brevity, we will refer to this task as RE and its practitioners as REs.)
RE can be complex and time consuming, often requiring expert knowledge and extensive experience to be successful [4,5].
In one study, participants analyzing small decompiled code snippets with less than 150 lines required 39 minutes on average to answer common malware-analysis questions [5].
Researchers, companies, and practitioners have developed an extensive array of tools to support RE [5][6][7][8][9][10][11][12][13][14][15][16][17][18][19][20][21][22][23][24].
However, there is limited theoretical understanding of the RE process itself.
While existing tools are quite useful, design decisions are currently ad-hoc and based on each designer's personal experience.
With a more rigorous and structured theory of REs' processes, habits, and mental models, we believe existing tools could be refined, and even better tools could be developed.
This follows from recommended design principles for tools supporting complex, exploratory tasks, in which the designer should "pursue the goal of having the computer vanish" [25, pg.
19-22].
In contrast to RE, there is significant theoretical understanding of more traditional program comprehension-how developers read and understand program functionality-including tasks such as program maintenance and debugging [26][27][28][29][30][31][32][33][34][35][36].
However, RE differs from these tasks, as REs typically do not have access to the original source, the developers who wrote the program, or internal documentation [3, pg.
141-196], [37].
Further, REs often must overcome countermeasures, such as symbol stripping, packing, obfuscation, and anti-debugging techniques [3, pg.
327-356], [38], [39, pg.
441-481], [40, pg.
660-661].
As a result, it is unclear which aspects of traditional program comprehension processes will translate to RE.In this paper, we develop a theoretical model of the RE process, with an eye toward building more intuitive RE tools.
In particular, we set out to answer the following research questions:RQ1.
What high-level process do REs follow when examining a new program?RQ2.
What technical approaches (i.e., manual and automated analyses) do REs use?RQ3.
How does the RE process align with traditional program comprehension?
How does it differ?Specifically, when considering REs' processes, we sought to determine the types of questions they had to answer and hypotheses they generated; the specific steps taken to learn more about the program; and the way they make decisions throughout the process (e.g., which code segments to investigate or which analyses to use).
As there is limited prior work outlining REs' processes and no theoretical basis on which to build quantitative assessments, we chose an exploratory qualitative approach, building on prior work in expert decision-making [41][42][43] and program comprehension [26][27][28][29][30][31][32][33][34][35][36].
While a qualitative study cannot indicate prevalence or effectiveness of any particular process, it does allow us to enumerate the range of RE behaviors and investigate in depth their characteristics and interactions.
Through this study, we can create a theoretical model of the RE process as a reference for future tool design.To this end, we conducted a 16-participant, semi-structured observational study.
In each participant session, we asked participants to recreate a recent RE experience while we observed their actions and probed their thought process.
Throughout, we tracked the decisions made, mental simulation methods used, questions asked, hypotheses formulated, and beacons (recognizable patterns) identified.We found that in general, the RE process can be modeled in three phases: overview, sub-component scanning, and focused experimentation.
REs begin by establishing a broad view of the program's functionality (overview).
They use their overview's results to prioritize sub-components-e.g., functions-for further analysis, only performing detailed review of specific sub-components deemed most likely to yield useful results (sub-component scanning).
As REs review these sub-components, they identify hypotheses and questions that are tested and answered, respectively, through execution or in-depth, typically manual static analysis (focused experimentation).
The last two phases form a loop.
REs develop hypotheses and questions, address them, and use the results to inform their understanding of the program.
This produces new questions and hypotheses, and the RE continues to iterate until the overall goal is achieved.Further, we identified several trends in REs' processes spanning multiple phases.
We found that REs use more static analysis in the first two phases and switch to dynamic simulation methods during focused experimentation.
We also observed that experience plays an important role throughout REs' decision-making processes, helping REs prioritize where to search (overview and sub-component scanning), recognize implemented functionality and potential vulnerabilities (sub-component scanning), and select which mental simulation method to employ (all phases).
Finally, we found REs choose to use tools to support their analysis when a tool's input and output can be closely associated with the code and when the tools improve code readability.Based on these results, we suggest five guidelines for designing RE tools.
While little work has investigated expert RE, there has been significant effort studying similar problems of naturalistic decision-making (NDM) and program comprehension.
Because of their similarity, we draw on theory and methods that have been found useful in these areas [26-32, 44, 45] as well as in initial studies of RE [46].
Significant prior work has investigated how experts make decisions in real-world (naturalistic) situations and the factors that influence them.
Klein et al. proposed the theory of Recognition-Primed Decision-Making (RPDM) [45, pg.
15-33].
The RPDM model suggests experts recognize components of the current situation-in our case, the program under investigation-and quickly make judgments about the current situation based on experiences from prior, similar situations.
Therefore, experts can quickly leverage prior experience to solve new but similar problems.
Klein et al. have shown this decision-making model is used by firefighters [41,42], military officers [43,47], medical professionals [48, pg.
58- 68], and software developers [49].
Votipka et al. found that vulnerability-discovery experts rely heavily on prior experience [1], suggesting that RPDM may be the decision-making model they use.NDM research focuses on these decision-making processes and uses interview techniques designed to highlight critical decisions, namely the Critical Decision Method, which has participants walk through specific notable experiences while the interviewer records and asks probing follow-up question about items of interest to the research (see Section 3.1) [44].
Using this approach prior work has driven improvements in automation design.
Specifically, these methods have identified tasks within expert processes for automation [44,50], and inferred mental models used to support effective interaction design [51] in several domains, including automobile safety controls [52,53], military decision support [44,[54][55][56], and manufacturing [57,58].
Building on its demonstrated success, we apply the Critical Decision Method to guide our investigation.
Program comprehension research investigates how developers maintain, modify, and debug unfamiliar code-similar problems to RE.
Researchers have found that developers approach unfamiliar programs from a non-linear, fact-finding perspective [26][27][28][29][30][31][32].
They make hypotheses about program functionality and focus on proving or disproving their hypotheses.Programmers' hypotheses are based on beacons recognized when scanning through the program.
Beacons are common schemas or patterns, which inform how developers expect variables and program components to behave [28,[33][34][35].
To evaluate their hypotheses, developers either mentally simulate the program by reading it line by line, execute it using targeted test cases, or search for other beacons that contradict their hypotheses [2,28,29,33,36].
Von Mayrhauser and Lang showed developers switch among these methods regularly, depending on the program context or hypothesis [59].
Further, when reading code, developers focus on data-and control-flow dependencies to and from their beacons of interest [34,60].
We anticipated that REs might exhibit similar behaviors, so we build on this prior work by focusing on hypotheses, beacons, and simulation methods during interviews (Section 3.1).
However, we also hypothesized some process divergence, as RE and "standard" program comprehension differ in several key respects.
Reverse engineers generally operate on obfuscated code and raw binaries, which are harder to read than source code.
Further, REs often focus on identifying and exploiting flaws in the program, instead of adding new functionality or fixing known errors.
Several researchers have taken steps to improve RE tool usability.
Do et al. created a Just-in-time static analysis framework called CHEETAH, based on the result of user studies investigating how developers interact with static analysis tools [61,62].
CHEETAH lets developers run static analyses incrementally as they write new code, allowing developers to put the analyses results in context and reduce the overwhelming "wall of alerts" feeling.
While we follow a similar qualitative approach, we focus on a different population (i.e., REs instead of developers) and task (RE instead of security alert response).
Shoshitaishvili et al. propose a tool-centered humanassisted vulnerability discovery paradigm [6].
They suggest a new interaction pattern where users provide on-demand feedback to a automated agent by performing well-defined sub-tasks to support the agent's analysis.
This model leverages human insights to overcome the automation's deficiencies, outperforming the best automated systems while allowing the analysis to scale significantly beyond limited human resources.
However, the demonstrated interaction model specifically targets non-expert users who do not understand program internals (e.g., code, control flow diagrams, etc.), treating the program as a black box.Focusing on expert users, Kruger et al. propose a specification language to allow cryptography experts to state secure usage requirements for cryptographic APIs [63].
Unfortunately, this approach still requires the expert to learn a new, potentially complicated language-hundreds of lines of code for each API.Finally, Yakdan et al. designed a decompiler, DREAM++, intended to improve usability compared to existing tools [5].
DREAM++'s experimental evaluation showed that a simple set of code transformations significantly increased both students' and professionals' ability to RE malware, demonstrating the benefit of even minor usability improvements.We hope that our more complete investigation of REs' processes may spur the development of further high-impact improvements.
Ceccato et al. reviewed detailed reports by three penetration testing teams searching for vulnerabilities in a suite of security-specific programs [2].
The participating teams were asked to record their process for searching the programs, finding vulnerabilities, and exploiting them.
Our study delves deeper into the specific problem of RE a program to understand its functionality.
Further, through our interviews, we are able to probe the RE's process to elicit more detailed responses.Most similarly to this work, Bryant investigated RE using a mixed methods approach, including three semi-structured interviews with REs and an observational study where four participants completed a predesigned RE task [46].
Based on his observations, Bryant developed a sense-making model for reverse engineering where REs generate hypotheses from prior experience and cyclically attempt to (in)validate these hypotheses, generating new hypotheses in the process.
Our results align with these findings; we expand on them, producing a more detailed model describing the specific approaches used and how RE behaviors change throughout the process.
Our more detailed model is achieved through our larger sample size and observation of RE processes on different, real-world programs, demonstrating RE behaviors to ensure saturation of themes [64, pg.
113-115].
In our prior work, we performed 25 interviews of white-hat hackers and testers to determine their vulnerability discovery processes [1].
While this research identified RE as an important part of the vulnerability discovery process, its broader focus (e.g., process, skill development, and community interaction) limited its ability to provide details regarding how RE is carried out, leading us to our current, more focused investigation.
We are interested in developing a theoretical model of the RE process with respect to both overall strategy and specific techniques used.
In particular, we focus on the three research questions given in Section 1.
To answer these questions, we employ a semi-structured, observation-based interview protocol, designed to yield detailed insights into RE experts' processes.
The full protocol is given in Appendix A. Interviews lasted 70 minutes on average.
Audio and video were recorded during each interview.
All interviews were led by the first author, who has six years of professional RE experience, allowing him to understand each RE's terminology and process, ask appropriate probing questions, and identify categories of similar actions for coding.
Participants were provided a $40 gift card in appreciation of their time.
Our study was reviewed and approved by the University of Maryland's Institutional Review Board.
In this section, we describe our interview protocol and data analysis process, and we discuss limitations of our method.
We performed semi-structured, observational videoteleconference interviews.
We implemented a modified version of the Critical Decision Method, which is intended to reveal expert knowledge by inquiring about specific cases of interest [44].
We asked participants to choose an interesting program they recently reverse engineered, and had them recall and demonstrate the process they used.
Each observation was divided into the two parts: program background and RE process.
Throughout, the interviewer noted and asked further questions about multiple items of interest.Program background.
We began by asking participants to describe the program they chose to reverse engineer.
This included questions about the program's functionality and size, what tools (if any) they used, and whether they reverse engineered the program with others.Reverse engineering process.
Next, we asked participants about their program-specific RE goals, and then asked them to recreate their process while sharing their screen (RQ1) 1 .
We chose to have participants demonstrate their process, asking them to open all tools they used and perform all original steps, so we could observe automatic and subconscious behaviorscommon in expert tasks [65]-that might be missed if simply asked to recall their process.
As the participant recreated their process, we asked several directed questions intended to probe their understanding while allowing them to delve into areas they felt were important.
We encouraged participants to share their entire process, even if a particular speculative step did not end up supporting their final goal.
For example, they may have decided to reverse a function that turned out to be a common library function already documented elsewhere, resulting in no new information gain.Instead of asking participants to demonstrate a recent experience, we could have asked them to RE a program new to them.
This could be more representative of the real-world experience of approaching a new program and might highlight additional subconscious or automatic behaviors.
However, it would likely require a much longer, probably unreasonable period of observation.
When asked how much time participants spent reverse engineering the programs demonstrated, 1 The only participant who did not share their screen did so because of technical difficulties that could not be resolved in a timely manner.answers ranged from several hours to weeks.
Alternatively, we could have asked participants to RE a toy program.
However, this approach restricts the results, both in depth of process and in terms of the program type(s) selected.
Demonstration provides a reasonable compromise, and is a standard practice in NDM studies [44].
In practice, we believe the effect of demonstration was small, especially because the interviewer asked probing questions to reveal subconscious actions.Items of interest.
The second characteristic of the Critical Decision Method is that the interviewer asks follow-on questions about items of interest to the research.
We selected our items of interest from those identified as important in prior NDM (decision) and program comprehension (questions/hypotheses, beacons, simulation methods) literature-discussed in Sections 2.1 and 2.2, respectively.
These items were chosen to identify specific approaches used (RQ2) and differences between RE and other program comprehension tasks (RQ3).
Below, we provide a short description of each and a summary of follow-on questions asked:• Decisions.
These are moments where the RE decides between one or more actions.
This can include deciding whether to delve deeper into a specific function or which simulation method to apply to validate a new hypothesis.
For decision points, we asked participants to explain how they made the decision.
For example, when deciding to analyze a function, the RE might consider what data flows into the function as arguments or what calls it.
• Questions/Hypotheses.
These are questions that must be answered or conjectures about what the program does.
Reverse engineers might form a hypothesis about the main purpose of a function, or whether a certain control flow is possible.
Prior work has shown that hypotheses are central part to program comprehension [2,[27][28][29], so we expected hypothesis generation and testing to be central to RE.
For hypotheses, we asked participants to explain why they think the hypothesis might be true and how they tested it.
As an example, if a RE observes a call to strcpy, they might hypothesize that a buffer overflow is possible.
To validate their hypothesis, they would check whether unbounded user input can reach this call.
• Simulation methods.
Any process where a participant reads or runs the code to determine its function.
We asked REs about any manual or automated simulation methods used: for example, using a debugger to determine the program's memory state at a specific point.
We wanted to know whether they employed any tools and if they were custom, open source, or purchased.
Further, we asked them to evaluate any tools used, and to discuss their effectiveness for this particular task.
Additionally, we asked participants why they used particular simulation methods, whether they typically did so, the method's inputs and outputs, and how they know when to switch methods.
• Beacons.
These include patterns or tells that a RE recog-nizes, allowing them to quickly generate hypotheses about the program's functionality without reading line-by-line.
For example, if a RE sees an API call to get a secure random number with several bit-shift operations, they may assume the associated function performs a cryptographic process.
For beacons, we had REs explain why the beacon stood out and how they recognized it as that sort of beacon rather than some other pattern.
The goal in inquiring into this phenomenon is to understand how REs perform pattern matching, and identify potentially common beacons of importance.
Additionally, we noted whenever participants referenced documentation or information sources external to the codee.g., StackOverflow, RE blogs, API documentation-to answer a program functionality question.
We asked whether they use that resource often, and why they selected that resource.To make the interviews more fluid and less repetitive, we intentionally skipped questions that had already been answered in response to prior questions.
To ensure consistency, all the interviews were conducted by the first author.We conducted two pilot interviews prior to the main study.
After the first pilot, we made adjustments to ensure appropriate terminology was used and improve question flow.
However, no changes were required after the second interview, so we included the second pilot interview in our main study data.
We applied iterative open coding to identify interview themes [66, pg.
101-122].
After completing each interview, the audio was sent to an external transcription service.
The interviewer and another researcher first collaboratively coded three interviews-reviewing both the text and video-to create an initial codebook 2 .
Then, the two coders independently coded 13 interviews, comparing codes after every three interviews to determine inter-coder reliability.
To measure intercoder reliability, we used Krippendorff's Alpha (α), as it accounts for chance agreements [67].
3 After each round, the coders resolved any differences, updated the codebook as necessary, and re-coded previously coded interviews.
The coders repeated this process four times until they achieved an α of 0.8, which is above the recommended level for exploratory studies [67,69].
Next, we sought to develop our theoretical model by extracting themes from the coded data.
First, we grouped identified codes into related categories.
Specifically, we discovered three categories associated with the phases of analyses performed by REs (i.e., Overview, Sub-component Scanning, and Focused Experimentation).
Then, we performed an axial coding to determine relationships between and within each phase and trends across the three phases [66, pg.
123-142].
From these phases and their connections, we derive a theory of REs' high-level processes and specific technical approaches.
We also present a set of interaction-design guidelines for building analysis tools to best fit REs.
There are a number of limitations innate to our methodology.
First, participants likely do not recall all task details they are asked to relay.
This is especially common for expert tasks [65].
We attempt to address this by using the CDM protocol, which has been used successfully in prior decision-making research on expert tasks [44].
Furthermore, we asked participants to recreate the RE task while the interviewer observed.
This allowed the interviewer to probe subconscious actions that would likely have been skipped without observation.Participants also may have skipped portions of their process to protect trade secrets; however, in practice we believe this did not impact our results.
Multiple participants stated they could not demonstrate certain confidential steps, but the secret component was in the process's operationalization (e.g., the keyword list used or specific analysis heuristics).
In all cases, participants still described their general process, which we were able to include in our analysis.Finally, we focus on experienced REs to understand and model expert processes.
Future work should consider newer REs to understand their struggles and support their development.
We recruited interview participants from online forums, vulnerability discovery organizations, and relevant conferences.Online forums.
We posted recruitment notices on a number of RE forums, including forums for popular RE tools such as IDAPro and BinaryNinja.
We also posted ads on online communities like Reddit.
Dietrich et al. showed online chatrooms and forums are useful for recruiting security professionals, since participants are reached in a more natural setting where they are more likely to be receptive [70].
Related organizations.
We contacted the leadership of ranked CTF teams 4 and bug bounty-as-a-service companies asking them to share study details with their members.
Our goal in partnering with these organizations was to gain credibility with members and avoid our messages dismissed as spam.
Prior work found relative success with this strategy [1].
To lend further credibility, all emails were sent from an address associated with our institution, and detailed study information was hosted on a web domain owned by our institution.Relevant conferences.
Finally, we recruited at several conferences commonly attended by REs.
We explained study details and participant requirements in person and distributed business cards with study information.
Recruiting face-to-face allowed us to clearly explain the goal of the research and its potential benefits to the RE community.Participant screening.
We asked respondents to our recruitment efforts to complete a short screening questionnaire.
Our questionnaire 5 asked participants to self-report their level of RE expertise on a five-point Likert-scale from novice to expert; indicate their years of RE experience; and answer demographic questions.
As our goal is to produce interaction guidelines to fit REs' processes, building on less experienced REs' approaches may not be beneficial.
Therefore, we only selected participants who rated themselves at least a three on the Likert scale and had at least three years of RE experience.We contacted volunteers in groups of ten in random order, waiting one week for their response before moving to the next group.
This process continued until we reached sufficient interview participation.Participants.
We conducted interviews between October 2018 and January 2019.
We received 68 screening survey responses; 42 met our expertise criteria.
Of these volunteers, 16 responded to randomly ordered scheduling requests and were interviewed.
We stopped further recruitment after 16 interviews, when we reached saturation, meaning we no longer observed new themes emerging.
This is the standard stopping criteria for a rigorous qualitative process [64, pg.
113- 115].
Because our participant count is within the range recommended by best practice literature (12-20 participants), our results provide useful insights for later quantitative inquiry and generalizable recommendations [71].
Table 1 shows the type of program each participant reverse engineered during the interview and their demographics, including their self-reported skill level, years of experience, and the method used to recruit them.
Each participants' ID indicates their assigned ID number and the primary type of RE tasks they perform.
For example, P01M indicates the first interviewee is a malware analyst.
Note that three interviewees used a challenge binary 6 during the interview.
These participants could not show us any examples from their normal work due to the proprietary or confidential nature of their work.
Instead, we asked them to discuss where their normal process on a larger program differed from process they showed with the challenge binary.While we know of no good RE demographics surveys, our participant demographics are similar to bug-bounty hunters, who commonly perform RE tasks.
Our population is mostly male (94%), young (63% < 30) and well educated (75% with a bachelor's degree).
HackerOne [72] and Bugcrowd report similar genders (91% of Bugcrowd hunters), ages (84% < 35 5 The screening full questionnaire can be found in an extended form of this paper at https://ter.ps/REStudy2020 Table 1: Participant demographics.
and 77% < 30, respectively), and education levels (68% and 63% with a bachelor's, respectively) for bug-bounty hunters.
Across all participants, we observed at a high-level (RQ1) their RE process could be divided into three distinct phases: Overview, Sub-component scanning, and Focused experimentation.
Beginning with a general goal-e.g., identifying vulnerabilities or malicious behaviors-REs seek a broad overview of the program's functionality (overview).
They use this to establish initial hypotheses and questions which focus investigation on certain sub-components, in which they only review subsets of information (sub-component scanning).
Their focused review produces more refined hypotheses and questions.
Finally, they attempt to test these hypotheses and answer specific questions through execution or in-depth static analysis (focused experimentation).
Their detailed analysis results are then fed back to the second phase for further investigation, iteratively refining questions and hypotheses until the overall goals are achieved.
Each phase has its own set of questions, methods, and beacons that make up the technical approaches taken by REs (RQ2).
In this section, we describe each phase in detail and highlight differences between RE and traditional program comprehension tasks (RQ3).
In the next section, we discuss trends observed across these phases, including RE process components common to multiple phases, such as factors driving their decision-making.
Figure 1 provides an overview of each phase of analysis.
Note, in this section and the next, we give the number of REs who expressed each idea.
We include counts to indicate prevalence, but a participant not expressing an idea may only mean they failed to state it, not that they disagree with it.Therefore, we do not perform comparisons between participants using statistical hypothesis tests.
It is uncertain whether our results generalize past our sample, but they suggest future work and give novel insights into the human factors of RE.Somewhat to our surprise, we generally observed the same process and methods used by REs performing both malware analysis and vulnerability discovery.
In a sense, malware analysts are also seeking an exploit: a unique execution or code pattern that can be exploited as a signature or used to recover from an attack (e.g., ransomware).
We did observe differences between groups, but only in their operationalization of the analysis process.
For example, the two groups focused on different APIs and functionality (e.g., vulnerability finders looked at memory management functions and malware analysts focused on network calls).
However, because our focus is on the high-level process and methods used, we discuss both groups together in the following sections.
Reverse engineers may have a short description of the program they are investigating (N=2), some familiarity with its user interface (N=2), or an intuition from prior experience about the functions the program likely performs (N=7).
However, they generally do not have prior knowledge about the program's organization or implementation (N=16).
They might guess that the program performs cryptographic functions because it is a secure messaging app, but they do not know the algorithm or libraries used, or where in the code cryptographic protocols are implemented.
Therefore, they start by seeking a high-level program view (N=16).
This guides which parts of the program to prioritize for more complex investigation.
P01M said this allows him to "get more to the core of what is going on with this binary."
Reverse engineers approach this phase in several ways.
The left section of Figure 1 summarizes the overview phase's simulation methods, beacons, and outputs.
We discuss these items in more detail below.Identify the strings and APIs used (RQ2).
Most REs begin by listing the strings and API calls used by the program (N=15).
These lists allow them to quickly identify interesting components.
P03V gave the example that "if this was a piece of malware. . . and I knew that it was opening up a file or a registry entry, I would go to imports and look for library calls that make sense.
Like refile could be a good one.
Then I would find where that is called to find where malicious behavior starts."
In some cases, REs begin with specific functionality they expect the program to perform and search for related strings and APIs (N=7).
As an example, P08V performed a "grep over the entire program looking for httpd because a lot of times these programs have a watchdog that includes a lot of additional configuration details.
"Run the program and observe its behavior (RQ2).
Many REs execute the program to see how it behaves under basic usage (N=7).
When running the program, some REs look at UI elements (e.g., error messages), then search for them in the code, marking associated program components for further review (N=3).
For example, P13V began by "starting the software and looking for what is being done."
He was shown a pop-up that said he had limited features with the free version.
He observed that there was "no place I can put a [access] code, so it must be making a web services check" to determine license status.
Next, he opened the program in a disassembler and searched for the pop-up's text "because you expect there to be a check around where those strings are.
"Review program metadata (RQ2).
Some REs looked at information beyond the binary or execution trace, such as the file metadata (N=3), any additional resources loaded (N=3) (e.g., images or additional binaries), function size (N=2), history of recent changes (N=1), where vulnerabilities were found previously (N=1), and security mitigations used (N=1) (e.g., DEP or ASLR).
This information gives further insights into program functionality and can help REs know what not to look for.
P04V said "I've been burned in the past.
You kind of end up down a long rabbit hole that you have to step completely back from if you don't realize these things. . . For example, for PIE [Position Independent Executables] there has to be some sort of program relative read or write or some sort of address disclosure that allows me to defeat the randomization.
So that's one thing to look for early on.
"Malware analysts perform overview after unpacking (RQ2).
Many malware binaries are stored in obfuscated form and only deobfuscated at execution time to complicate RE.
This is commonly referred to as packing.
Therefore, REs must first unpack the binary before strings and imported APIs become intelligible (N=2).
However, once unpacking is performed and the binary is in a readable state, REs perform the same overview analyses described above (N=2).
Overview is unique to RE (RQ3).
In most other program comprehension tasks, the area of code to focus on is known at the outset based on the error being debugged [73] or the functionality being modified or updated [34,74].
Additionally, developers performing program comprehension tasks typically have access to additional resources, such as documentation and the original developers, to provide high-level understanding [75], making overview analyses unnecessary.
Based on findings from their overview, REs next shift their attention to program sub-components, searching for insights into the "how" of program functionality.
By focusing on subcomponents, sub-component scanning allows REs to quickly identify or rule out hypotheses and refine their view of the program.
P08V explained that he scanned the code instead of reading line-by-line, saying, "I'm going through it at a high level, because it's really easy to get caught in the weeds when there could be something much better to look at."
The middle column of Figure 1 gives an overview of this analysis phase.Scan for many beacons (RQ2).
Most commonly, REs scan through functions or code segments prioritized in the overview (N=15), looking for a variety of beacons indicating possible behaviors.
These include APIs (N=15), strings (N=15), constants (N=11), and variable names (N=11).
For example, while investigating a piece of malware, P02V saw GetProcAddress was called.
This piqued his interest because "it's a very common function for obfuscation. . . it's likely setting up an alternate input table" to hide obviously malicious calls from an RE looking only at the standard import table.REs infer program behaviors both from individual instances (N=16) and specific sequences (N=12) of these items.
For example, while reverse engineering the code in Figure 2, P11M first scanned the strings on lines 44-46 and recognized them as well-known websites, generally reachable by any device connected to the Internet.
He then looked at the API calls and strings on lines 51-56 and said that "it's just trying to make a connection to each of those [websites]."
By looking at the constant checked on line 66, he inferred that "if it's able to make a connection, it's going to return a non-zero value [at line 66]."
Putting this all together and comparing to past experience, P11M explained, "usually you see this activity if something is trying to see if it has connectivity.
"REs also make inferences from less obvious information.
Many review control-flow structures (N=13) for common patterns.
When studying a router's firmware, P08V noticed an assembly code structure corresponding to a switch statement comparing a variable to several constants.
From this, he assumed that it was a "comparison between the device's product ID and a number of different product IDs.
And then it's returning different numbers based off that.
So it looks like it's trying to ascertain what product it is and then doing something with it," because he has "seen similar behavior before where firmware is written in generically."
Other REs consider the assembly instructions chosen by the compiler (N=8) or function prototypes (N=5) to determine the data types of variables.
P02V explained, "It is very important to understand. . . how compilers map code to the actual binary output."
As an example, he pointed out instructions at the start of a function and said, "that's just part of saving the values. . . I can safely skip those."
Then he identified a series of registers and observed "those are the function's arguments. . . after checking the codebase of FreeBSD, I know the second argument is actually a packed structure of arguments passed from outside the kernel.
This is [the data] we control in this function context."
Finally, REs consider the code's relation to the overall program flow (N=6).
For example, P08V identified a function as performing "tear down" procedures-cleaning up the state of the program before terminating-because it "happened after the main function.
"Focused on specific data-flow and control-flow paths (RQ2).
Some REs also scanned specific data-(N=8) and control-flow (N=7) paths, only considering instructions affecting these paths.
These analyses were commonly used to understand how a function's input (N=7) or output (N=4) is used and whether a particular path is realizable (N=4).
For example, while reviewing the program summarized in Fig- ure 3, P02V asked whether a control-flow path exists through id_alloc in which x is not written.
Memory for x is allocated before the id_alloc call and read after, so if such a path is possible, "we can have it read from undefined memory."
To answer this question, P02V scanned each control flow path through the function from the bottom of the graph up.
If he saw a write to x, he moved on to the next path.
This check invalidated the first two control-flow paths (counting left-toright) in Figure 3.
Additionally, in main, the program exits if the return value of id_alloc is -1.
Thus his next step was to check the data flow to id_alloc's return value to see whether it was set to -1.
He found the return value was set to -1 in both remaining control-flow paths, indicating it was not possible to read from undefined memory.The diversity of beacons represents a second difference from program comprehension (RQ3).
While program comprehension research has identified several similar beacons (API calls, strings, variable names, sequences of operations, and constants [28,[33][34][35]), developers have been shown to struggle when variable names and other semantic information are obfuscated [33].
However, REs adapt to the resourcestarved environment and draw on additional beacons (i.e., control flow structures, compiler artifacts, and program flow).
Finally, when REs identify a specific question or hypothesis, they shift to focused experimentation: setting up small experiments, varying program inputs and environmental conditions, and considering the program's behavior in these states to find a concrete answer or prove whether specific hypotheses hold.
This phase's results are fed back into sub-component scanning, to refine high-level hypotheses and the RE's interpretation of observed beacons.
Again, REs rely on a wide range of methods for this analysis.Execute the program (RQ2).
In most cases, REs validate their hypotheses by running the code under specific conditions to observe whether the expected behavior occurs (N=13).
They may try to determine what value a certain variable holds at a particular point (e.g., input to a function of interest) under varying conditions (N=13) or whether user input flows to an unsafe function (N=9).
For example, after reviewing the data-flow path of the program's arguments, P03V hypothesized that the program required two input files with a specific string in the first line to allow execution to reach potentially vulnerable code.
To test this hypothesis, she ran the program in a debugger with the expected input and traced execution to see the state of memory at the potentially vulnerable point.While running the program, REs gather information in a variety of ways.
Most execute the code in a debugger (N=12) to probe memory and have full control over execution.
Some use other tools like packet capturers and file monitors to observe specific behaviors (N=8).
In some cases, REs manipulate the execution environment by dynamically changing registry values (N=7) or patching the binary (N=5) to guide the program down a specific path.
As an example, while analyzing malware that "checks for whether it is being run in a debugger," P16M simply changes the program "so that the check will always just return false [not run in debugger].
"Finally, some REs fuzz program inputs to identify mutationspecific behavior changes.
In most cases, fuzzing is performed manually (N=6), where the RE hand-selects mutations.
Automation is used in later stages, once a good understanding of the program is established (N=1).
P08V explained, "I wait until I have a good feel for the inputs and know where to look, then I patch the program so that I can quickly pump fuzzed USENIX Association 29th USENIX Security Symposium 1883 inputs from angr [76] into the parts I care about.
"Compare to another implementation (RQ2).
Some REs chose to re-write code segments in a high-level language based on the expected behavior (N=8) or searched for public implementations (e.g., libraries) of algorithms they believed programs used (N=5).
They then compared the known implementation's outputs with the subject program's outputs to see if they matched.
For example, once P10B recognized the encryption algorithm he was looking at was likely Blowfish, he downloaded an open-source Blowfish implementation.
He first compared the open-source code's structure to the encryption function he was reviewing.
He then ran the reference implementation and malware binary on a file of all zeros saying, "we can then verify on this sample data whether it's real Blowfish or if it's been modified.
"Read line-by-line only for simple code or when execution is difficult (RQ2).
Finally, REs resorted to reading the code line-by-line and mentally tracking the program state when other options became too costly (N=9).
In some cases, this occurred when they were trying to answer a question that only required reading a few, simple lines of code.
For example, P05V described a situation where he read line-by-line because he wanted to fully understand a small number of specific checks, saying, "After Google Project Zero identified some vulnerabilities in the system, the developers tried to lock down that interface by adding these checks.
Basically I wanted to figure out a way to bypass these specific checks.
At this point I ended up reading line-by-line and really trying to understand the exact nature of the checks."
While no participants quantified the number of lines or code complexity they were willing to read line-by-line, we did not observe any participants reading more than 50 lines of code.
Further, this determination appeared goal-and participant-dependent, with wide variation between participants and even within individual participants' own processes, depending on the current experiment they were carrying out.
REs also chose to read line-by-line instead of running the program when running the program would require significant setup (e.g., when using an emulator to investigate uncommon firmware like home routers).
P09V explained, "The reason I was so IDA [disassembler] heavy this time is because I can't run this binary.
It's on a cheap camera and it's using a shared memory map.
I mean, I could probably run this binary, but it's going to take a while to get [emulation] set up.
"During this line-by-line execution, a few REs said they used symbolic execution to track inputs to a control flow conditional of interest (N=2).
P03V explained, "I write out the conditions to see what possible states there are.
I have all these variables with all these constraints through multiple functions, and I want to say for function X, which is maybe 10 deep in the program, what are the possible ranges for each of these variables?"
In both cases, the REs said they generally performed this process manually, but used a tool, such as Z3, when the conditions became too complicated.
As P03V put it, "It's easier if you can just do it in your brain of course, but sometimes you can't. . . if there are 10 possibilities or 100 possibilities, I'll stick it in a SAT solver if I really care about trying to get past a barrier [conditional].
"Beacons are still noticed and can provide shortcuts (RQ2).
While REs focus on answering specific questions in this phase, some also notice beacons missed in prior analyses.
If inferences based on these beacons invalidated prior beliefs, REs quickly stop focused experimentation that becomes moot.
For example, while P04V was reverse engineering a card-game challenge binary, he decided to investigate a reset function operating on an array he believed might be important.
There were no obvious beacons on initial inspection and there were only a few instructions, so he decided to read line-by-line.
However, he quickly recognized two constants that allowed him to infer functionality.
He saw that "it's incrementing values from 0 to 51.
So at this point, I'm thinking it's a deck of cards.
And then it has this variable hold.
Hold is a term for poker, and it sets 0 to 4."
Once he realized what these variables were, he decided he had sufficient information to stop analyzing the function, and he moved back to the calling function to resume sub-component scanning.Simulation methods mostly overlap with program comprehension (RQ3).
Most of the methods described above, including using a debugger and reading code line-by-line, are found in the program comprehension literature.
However, comparing program execution to another implementation appears unique to REs.
As in sub-component scanning, this extra method is likely necessitated by the additional complexity inherent in an adversarial environment.
In addition to the phases themselves, we observed several cross-phase trends in our participants' RE approaches, which we discuss in this section.
This includes both answers to our research questions which were not unique to a specific phase and additional observations regarding tool usage which inform future tool development.
Figure 4 includes some of these trends as they interact with the phases.Begin with static methods and finish with dynamic (RQ2).
Most of the simulation methods described in the first two analysis phases focused on static program representations, i.e., the binary or decompiled code.
In contrast, focused experimentation was mainly performed dynamically, i.e., by running the program.
Reverse engineers typically make this switch, as P05V stated, "because this thing is so complex, it's hard to trace the program flow [statically], but you can certainly tell when you analyze an [execution] trace.
You could say this was hit or this wasn't hit."
However, REs sometimes choose not to switch when they perceive the switch to be difficult.
Unfortunately, in most cases, switching contexts can be difficult because REs have to manually transfer information back and forth between static and dynamic tools (e.g., instructions or memory states) (N=14).
To overcome this challenge, some REs opened both tools side-by-side to make comparisons easier (N=4).
For example, P08V opened a debugger in a window next to a disassembler and proceeded to step through the main function in the debugger while following along in the assembly code.
As he walked through the program, he regularly switched between the two.
For example, he would scan the possible control-flow paths in the disassembler to decide which branch to force execution down and the necessary conditions would be set through the debugger.
Whenever he came across a specific question that could not be answered just by scanning, he would switch to the debugger.
Because he stepped through the program as he scanned, he could quickly list register values and relevant memory addresses to get concrete variable values.Experience and strategy guide where to look in the first two phases (RQ1).
Initially, REs have to make decisions about which metadata to look at, e.g., all strings and APIs or specific subsets, (N=4) and what inputs to provide to exercise basic behaviors (N=2).
Once they run their overview analyses, they must determine which outputs (strings, APIs, or UI elements) are relevant to their investigation (N=16) and in what order to process them (N=11).
Reverse engineers first rely on prior experience to guide their actions (N=14).
P04V explained that when he looks for iPhone app vulnerabilities, he has "a prioritized list of areas [APIs] I look at...it's not a huge list of things that can go horribly wrong from a security standpoint when you make an iPhone app...So, I just go through my list of APIs and make sure they're using them properly."
If REs are unable to relate their current context to prior experience, then they fall back on basic strategies (N=16) such as looking at the largest functions first.
P03V said, "If I have no clue what to start looking at...I literally go to the function list and say the larger function is probably interesting...as long as I can distinguish the actual code versus library code, this technique is actually pretty useful."
Similarly, REs employ heuristics to decide which functions not to investigate.
For example, P16M said, "If the function is cross-referenced 100 times, then I will avoid it.
It's probably something like an error check the compiler added in.
"In sub-component scanning, experience plays an even more important role.
As in the previous analysis phase, REs must decide which data-(N=8) and control-flow paths (N=7) to consider.
Again, this is done first by prior experience (N=6) and then by simple strategies (N=4).
As they perform their analyses, REs must also determine potential hypotheses regarding program functionality (N=16) and possible vulnerabilities (N=9)-exploitable flaws in the case of vulnerability discovery, or signaturable behaviors for malware analysis.
In most cases, these determinations are made by recognizing similarities with previous experiences (N=15).
For example, when P08V saw a function named httpd_ipc_init, he recognized this might introduce a vulnerability, saying, "IPC generally stands for inter-process communication, and many router firmwares like this set up multiple processes that communicate with each other.
If it's doing IPC through message passing, then that opens up the attack surface to anything that can send messages to this httpd binary."
If the RE is unable to generate hypotheses based on prior experience, they instead make determinations based on observed behaviors (N=16), obtained via more labor intensive investigation of the program execution or in-depth code review.Experience used to select analysis method throughout (RQ1).
There were typically multiple ways to answer a question.
The most common example, as discussed in Section 5.3, was deciding between executing the program or reading lineby-line during focused experimentation (N=9).
Similar decisions occurred in the other phases.
For example, some REs choose to simply skip the overview phase all together and start with the main function (N=5) whenever, as P03V said, "it's clear where the actual behavior starts that matters.
"REs also decide the granularity of analysis, weighing an approximation's benefits against the inaccuracy introduced (N=5).
For example, several participants discussed choosing to use a decompiler to make the code easier to read, knowing that the decompilation process introduces inaccuracies in certain circumstances.
P04V said, "I actually spend most of my time in Hex-Rays [decompiler].
A few of my friends generally argue that this is a mistake because Hex-Rays can be wrong, and disassembly can't be.
And this is generally true, but Hex-Rays is only wrong in specific ways."
Further, because these are explicit decisions, REs are also able to recognize situations where the inaccuracies are common and can switch analysis granularities to verify results (N=5).
For example, when using a decompiler, the RE has some intuition regarding what code should look like.
P04V explained, "I've USENIX Association 29th USENIX Security Symposium 1885 had many situations where I think this looks like an infinite loop, but it can't be.
It's because Hex-Rays is buggy.
Basically, in programming, no one does anything all that odd.
"Preferred tools presented output in relation to the code (RQ2).
In almost all cases, the tools REs choose to use provide a simple method to connect results back to specific lines of code (N=16).
They choose to list strings and API calls in a disassembler (N=15), such as IDA, which shows references in the code with a few clicks, as opposed to using the command-line strings command (N=0).
Similarly, those participants who discussed using advanced automated analyses, i.e., fuzzing (N=1) and symbolic execution (N=1), reported using them through disassembler plugins which overlaid analysis results on the code (e.g., code coverage highlighting for fuzzing).
P03V used Z3 for symbolic execution independently of the code, supplying it with a list of possible states and manually interpreting its output with respect to the program.
However, she explained this decision was made because she did not know a tool that presented results in the context of the code that could be used with the binary she was reversing.
She said, "The best tool for this is PAGAI. . . If you have source it can give you ranges of variables at certain parts in a program, like on function loops and stuff."
Specifically, PAGAI lets REs annotate source code to define variables of interest and then presents results in context of these annotations [77].
Focused on improving readability (RQ2).
Throughout, REs pay special attention to improving code readability by modifying it to include semantic information discovered during their investigation.
In most cases, the main purpose of tools REs used was to improve code readability (N=9).
Many REs used decompilers to convert the assembly code to a more readable high-level language (N=9), or tools like IDA's lumina server [78] to label well-known functions (N=2).
Additionally, most REs performed several manual steps specifically to improve readability, such as renaming variables (N=14), taking notes (N=14), and reconstructing data structures (N=8).
P01M explained the benefit of this approach when looking at a file reading function by saying, "It just says call DWORD 40F880, and I have no idea what that means. . . so, I'll just rename this to read file. . . [now I know] it's calling read file and not some random function that I have no idea what it is."
Taking notes was also useful when several manipulations were performed on a variable.
For example, to understand a series of complex variable manipulations, P05V said "I would type this out.
A lot of times I could just imagine this in my head.
I think usually I can hold in my head two operations...If it's anything greater than that I'll probably write it down.
"Online resources queried to understand complex underlying systems (RQ2).
Regarding external resources, REs most often reference system and API documentation (N=10).
They reference this documentation to determine specific details about assembly opcodes or API arguments and functionality.
They also reference online articles (N=4) that provide indepth breakdowns of complicated, but poorly documented system functions (e.g., memory management, networking, etc.).
When those options fail, some REs also reference questionanswering sites like StackOverflow (N=4) because "sometimes with esoteric opcodes or functions, you have to hope that someone's asked the question on StackOverflow because there's not really any good documentation" (P3).
Many participants also google specific constants or strings they assume are unique to an algorithm (N=7).
P10 explained, "For example, MD5 contains an initialization vector with a constant.
You just google the constant and that tells you the algorithm."
Our key finding is the identification and description of a threephase RE process model, along with cross-phase trends in REs' behaviors.
This both confirms and expands on prior work, which described an RE model of increasingly refined hypotheses [46].
We demonstrate a process of hypothesis generation and refinement through each phase, but also show the types of questions asked, hypotheses generated, actions taken, and decisions made at each step as the RE expands their program knowledge.
Our model highlights components of RE for tool designers to focus on and provides a language for description and comparison of RE tools.
Building on this analysis model, we propose five guidelines for RE tool design.
For each guideline, we discuss the tools closest to meeting the guideline (if any), how well it meets the guideline, and challenges in adopting the guideline in future tool development.
Table 2 provides a summary, example application, and challenges for each guideline.
While these guidelines are drawn directly from our findings, further work is needed to validate their effectiveness.G1.
Match interaction with analysis phases.
The most obvious conclusion is that RE tools should be designed to mesh with the three analysis phases identified in Section 5.
This means REs should first be provided with a program overview for familiarization and to provide feedback on where to focus effort (overview).
As they explore sub-components, specific slices of the program (beacons and data/control-flow paths) should be highlighted (sub-component scanning).
Finally, concrete, detailed analysis information should be produced on demand, allowing REs to refine their program understanding (focused experimentation).
While this guideline is straightforward, it is also significant, as it establishes an overarching view of the RE process for tool developers.
Because current RE tool development is adhoc, tools generally perform a single part of the process and leave the RE to stitch together the results of several tools.
G1 provides valuable insights to single-purpose tool developers by identifying how they should expect their tools to be used Example Application G1Match interaction with analysis phases Reverse engineering tools should be designed to facilitate each analysis phase: overview, sub-component scanning, and focused experimentation.IDAPro [19], BinaryNinja [20], Radare2 [79] Provide platforms for REs to combine analyses, but previously lacked thorough RE process model to guide analysis development and integration.
G2Present input and output in the context of code Integrate analysis interaction into the disassembler or decompiled code view to support tool adoption Highlights output in the context of code, but does not support input in code context.
G3Allow data transfer between static and dynamic contexts Static and dynamic analyses should be tightly coupled so that users can switch between them during exploration.None we are aware of We do not know of any complex analysis examples.
This is possibly due to challenges with visualization and incremental analysis.
G4Allow selection of analysis methods When multiple options for analysis methods or levels of approximation are available, ask the user to decide which to use.
Minimally applies G4 by giving users a binary option of a potentially imprecise decompiled view or a raw disassembly view.
G5Support readability improvements Infer semantic information from the code where possible and allow users to change variable names, add notes, and correct decompilation to improve readability.
Provides significantly improved decompiled code readability through several heuristics, but is limited to a preconfigured set of readability transformations.
and the input and output formats they should support.
Additionally, with the growing effort to produce human-assisted vulnerability discovery systems [4], G1 shows when and how human experts should be queried to support automation.
The closest current tools to fulfilling G1 are popular reverse engineering platforms such as IDAPro [19], BinaryNinja [20], and Radare [79], which provide disassembly and debugger functionality and support user-developed analysis scripts.
These tools allow REs to combine different analyses (N=16).
However, due to these tools' open-ended nature and the lack of a prior RE process model, there are no clear guidelines for script developers, and users often have to perform significant work to find the right tool for their needs and incorporate it into their process.G2.
Present input and output in the context of code.
We found that most REs only used tools whose interactions were tightly coupled with the code.
This suggests that tool developers should place a high priority on allowing users to interact directly with (disassembled or decompiled) code.
The best example of this we observed was given by P05V in the code-coverage visualization plugin Lighthouse, which takes execution traces and highlights covered basic blocks in a disassembler view [80].
It also provides a "Boolean query where you can say only show me covered blocks that were covered by this trace and not that trace, or only show blocks covered in a function whose name matches a regular expression."
However, Lighthouse does not fully follow our recommendation, as there is no way to provide input in the context of the code.
For example, the user might want to determine all the inputs reaching an instruction to compare their contents.
However, this is not currently possible in the tool.G3.
Allow data transfer between static and dynamic contexts.
We found that almost all participants switched between static and dynamic program representations at least once (N=14).
This demonstrates tools' need to consider both static and dynamic information, associate relevant components between static and dynamic contexts, and allow REs to seamlessly switch between contexts.
For example, P04V suggested a dynamic taint analysis tool that allows the user to select sinks in the disassembler view, run the program and track tainted instructions, then highlight tainted instructions again in the disassembler view.
This tool follows our suggested guideline, as it provides results from a specific execution trace, but also allows the user to contextualize the results in a static setting.We did observe one participant using a tool which displayed the current instruction in the disassembly view when stepping through the code in a debugger, and there have been several analyses developed which incorporate static and dynamic data [18,[82][83][84][85][86].
However, we are unaware of any more complex analyses that support user interaction with both static and dynamic states.
Following G3 requires overcoming two difficult challenges.
First, the analysis author must determine how to best represent dynamic information in a static setting and vice versa.
This requires careful design of the visualization to ensure the user is provided relevant information in an interpretable manner.
Second, we speculate that incremental program analyses (such as those of Szabo et al. [87]) may be necessary in this setting to achieve acceptable performance compared to current batch-oriented tools.G4.
Allow selection of analysis methods.
Throughout the RE process, REs choose which methods to use based on prior experiences and specific needs, weighing the method's benefit against any accuracy loss (N=5).
These tradeoff decisions are inherent in most analyses.
Therefore, we recommend tool designers leverage REs' ability to consider costs and also recognize instances where the analysis fails.
This can be done by allowing REs to select the specific methods used and tune analyses to fit their needs.
One example we observed was the HexRays decompiler [81], which allows users to toggle between a potentially imprecise, but easier to read, decompiled program view and the more complex disassembled view.
This binary choice, though, is the minimum implementation of G4, especially when considering more complex analyses where the analysis developer must make several nuanced choices involving analyses such as context, heap, and field sensitivity [88].
This challenge becomes even more difficult if the user is allowed to mix analysis precision throughout the program, as static analysis tools generally use uniform analysis sensitivity.
However, recent progress indicates that such hybrid analyses are beginning to receive attention [89,90].
G5.
Support readability improvements.
We found most REs valued program readability improvements.
Therefore, RE tool designers should allow the user to add notes or change naming to encode semantic information into any outputs.
Further, because annotation is such a common behavior (N=14), tools should learn from these annotations and propagate them to other similar outputs.
The best example of a tool seeking to follow this recommendation is the DREAM++ compiler by Yakdan et al. [5].
DREAM++ uses a set of heuristics derived from feedback from REs to provide semantically meaningful names to decompiled variables, resulting in significant readability improvements.
One improvement to this approach might be to expand beyond DREAM++'s preconfigured set of readability transformations by observing and learning from developer input through renaming and annotations.
This semantic learning problem poses a significant challenge for the implementation of G5, as it likely requires the analysis to consider minor nuances of the program context.RE tool designers should consider the exploratory visual analysis (EVA) literature.
In addition to the guidelines drawn directly from our results, we believe RE tool designers can draw inspiration from EVA.
EVA considers situations where analysts search large datasets visually to summarize their main characteristics.
Based on a review of the EVA literature, Battle and Heer define a process similar to the one we observed REs to perform, beginning with a high-level overview, generating hypotheses, and then iteratively refining these hypotheses through a mix of scanning and detailed analysis [91].
Further, Shneiderman divided EVA into three phases, similar to those we suggest, with his Visual Information Seeking Mantra: "Overview first, zoom and filter, then details-ondemand" [92].
While techniques from this field likely cannot be applied as-is due to differences in the underlying data's nature, these similarities suggest insights from EVA could be leveraged to guide similar development in RE tools, including methods for data exploration [93][94][95][96], interaction [97][98][99][100], and predicting future analysis questions [101][102][103][104].
Our goal is to carefully model REs' processes, in order to support better design of RE tools.
To do this, we conducted a semi-structured observational interview study of 16 professional REs.
We found that RE involves three distinct phases: overview, sub-component scanning, and focused experimentation.
Reverse engineers work through a program using a variety of manual and automated approaches in each of these phases, often using a combination of methods to accomplish a specific task (e.g., a static analysis alongside a debugger).
In the first two phases (overview and sub-component scanning), REs typically use static techniques (e.g., looking at a control-flow graph), but switch to using dynamic techniques (e.g., debugging or dynamic analysis) in the last phase (focused experimentation).
Based on our results, we proposed five design guidelines for RE tools.
We believe our model will help in the design and development of RE tools that more closely match the RE process.
[10] A. Austin and L. Williams, "One technique is not enough: A comparison of vulnerability discovery techniques," in ESEM '11.
IEEE Computer Society, 2011, pp. 97-106.
[11] N. Antunes and M. Vieira, "Comparing the effectiveness of penetration testing and static code analysis on the detection of sql injection vulnerabilities in web services," in PRDC '09.
IEEE Computer Society, 2009, pp. 301-306.
[12] L. Suto, "Analyzing the effectiveness and coverage of web application security scanners," BeyondTrust, Inc, Tech.
Rep., 2007.
[Online].
Available: https://www.beyondtrust.com/resources/white-paper/analyzing-theeffectiveness-and-coverage-of-web-application-security-scanners/ We thank Kelsey Fulton and the anonymous reviewers for their helpful feedback; BinaryNinja, the two bug-bounty platform companies, and the many CTF teams that supported our recruitment efforts; and Jordan Wiens for providing valuable insights into the world of reverse engineering.
This research was supported in part by a UMIACS contract under the partnership between the University of Maryland and DoD, and by a Google Research Award.
dTo begin our discussion, I want you to think of a program that you recently reverse engineered.
[If they do share their screen] Also, if you are comfortable, I would like to record this screen sharing session, so that we have a later reference.Please walk me through how you searched the program.
As you go through your process, please explain every step you took, even if it was not helpful toward your eventual goal.
For example, if you decided to reverse engineer a specific class, but realized it was not relevant to your search after reading the code, we would still like to know that you performed this step.
[a few cueing questions are provided below to guide the conversation]1.
Where did you start?
2.
What questions did you ask?
How did you answer these questions?A.
Beacons.
[Every time the participant states recognizing the functionality of some code without actually stepping through it.
That is, they are able to notice some pattern in the code and make some deductions about functionality based on this]1.
Record the beacon that was noticed 2.
Why did this stand out to you?
How were you able to recognize it?
3.
How did you know that it was X instead of something else?Simulation.
[Every time the participant discusses looking at the code to determine how it works] 1.
Record how they investigate the code.
To begin our discussion, I want you to think of a program that you recently reverse engineered.
[If they do share their screen] Also, if you are comfortable, I would like to record this screen sharing session, so that we have a later reference.Please walk me through how you searched the program.
As you go through your process, please explain every step you took, even if it was not helpful toward your eventual goal.
For example, if you decided to reverse engineer a specific class, but realized it was not relevant to your search after reading the code, we would still like to know that you performed this step.
[a few cueing questions are provided below to guide the conversation]1.
Where did you start?
2.
What questions did you ask?
How did you answer these questions?A.
Beacons.
[Every time the participant states recognizing the functionality of some code without actually stepping through it.
That is, they are able to notice some pattern in the code and make some deductions about functionality based on this]1.
Record the beacon that was noticed 2.
Why did this stand out to you?
How were you able to recognize it?
3.
How did you know that it was X instead of something else?Simulation.
[Every time the participant discusses looking at the code to determine how it works] 1.
Record how they investigate the code.
