Recent years have witnessed an increasing number of protocols relying on UDP.
Compared to TCP, UDP offers performance advantages such as simplicity and lower latency.
This has motivated its adoption in Voice over IP, tunneling technologies , IoT, and novel Web protocols.
To protect sensitive data exchange in these scenarios, the DTLS protocol has been developed as a cryptographic variation of TLS.
DTLS's main challenge is to support the stateless and unreliable transport of UDP.
This has forced protocol designers to make choices that affect the complexity of DTLS, and to incorporate features that need not be addressed in the numerous TLS analyses.
We present the first comprehensive analysis of DTLS implementations using protocol state fuzzing.
To that end, we extend TLS-Attacker, an open source framework for analyzing TLS implementations, with support for DTLS tailored to the stateless and unreliable nature of the underlying UDP layer.
We build a framework for applying protocol state fuzzing on DTLS servers, and use it to learn state machine models for thirteen DTLS implementations.
Analysis of the learned state models reveals four serious security vulnerabilities, including a full client authentication bypass in the latest JSSE version, as well as several functional bugs and non-conformance issues.
It also uncovers considerable differences between the models, confirming the complexity of DTLS state machines.
UDP is widely used as an unreliable transfer protocol for Voice over IP, tunneling technologies, and new Web protocols, and is one of the commonly used protocols in the Internet of Things (IoT).
As UDP does not offer any security by itself, Datagram Transport Layer Security (DTLS) [29,36] was introduced.
DTLS is a variation on TLS, a widely used security protocol responsible for securing communication over a reliable data transfer protocol.DTLS is one of the primary protocols for securing IoT applications [38].
The number of IoT devices is projected to reach 11.6 billion by 2021 [26].
This will constitute half of all devices connected to the Internet, with the percentage set to grow in subsequent years.
Such trends also increase the need to ensure that software designed for these devices is properly scrutinized, particularly with regards to its security.DTLS is also used as one of the two security protocols in WebRTC, a framework enabling real-time communication.
WebRTC can be used, for example, to implement video conferencing in browsers without the need for a plugin.
It is supported by all major browsers, including Mozilla Firefox, Google Chrome, Microsoft Edge, and Apple's Safari.Whereas significant effort has been invested into ensuring security of TLS implementations, those based on DTLS have so far received considerably less scrutiny.
Our work fills this gap by providing an extensible platform for testing and analyzing systems based on DTLS.
We describe this framework, and use it to analyze a number of existing DTLS implementations, including the most commonly used ones.
Our specific focus is on finding logical flaws, which can be exposed by non-standard or unexpected sequences of messages, using a technique known as protocol state fuzzing (or simply state fuzzing).
As in TLS, each DTLS client and server effectively implements a state machine which keeps track of how far protocol operation has progressed: which types of messages have been exchanged, whether the cryptographic materials have been agreed upon and/or computed, etc.
Each DTLS implementation must correctly manage such a state machine for a number of configurations and key exchange mechanisms.
Corresponding implementation flaws, so-called state machine bugs, may be exploitable, e.g., to bypass authentication steps or establish insecure connections [5].
To find such flaws, state fuzzing has proven particularly effective not only for TLS [13], but also for SSH [19], TCP [18], MQTT [40], OpenVPN [12], QUIC [33], and the 802.11 4-Way Handshake [28], leading to the discovery of several security vulnerabilities and nonconformance issues in their implementations.State fuzzing automatically infers state machine descriptions of protocol implementations using model learning [32,41].
This is an automated black-box technique which sends selected sequences of messages to the implementation, observes the corresponding outputs, and produces a Mealy machine that abstractly describes how the implementation responds to message flows.
The Mealy machine can then be analyzed to spot flaws in the implementation's control logic or check compliance with its specification.
State fuzzing works without any a priori knowledge of the protocol state machine, but relies on a manually constructed protocol-specific test harness, a.k.a. a MAPPER, which translates symbols in the Mealy machine to protocol packets exchanged with the implementation.Challenges resulting from the DTLS design.
DTLS is more complex than other security protocols that have so far been subject to state fuzzing.
Most of these [12,18,19] run over TCP, relying on its support for reliable connections.
In contrast, DTLS runs over UDP, which is connectionless.
This implies that DTLS has to implement its own retransmission mechanism and provide support for message loss, reordering, and fragmentation.
Moreover, an ongoing DTLS interaction cannot be terminated by simply closing the connection, as is the case with TLS.
As a result, most DTLS implementations allow interaction to continue even after reception of unexpected messages -after all, these messages might have just arrived out of order-and may subsequently allow a handshake to "restart in the middle" and finish successfully.
Finally, compared to TLS, DTLS includes an additional message exchange used to prevent Denial-of-Service attacks.
All this added complexity makes protocol state fuzzing more difficult to apply for DTLS than for TLS.Supporting mapper construction.
DTLS' support for message loss, reordering, and fragmentation requires additional packet parameters compared to TLS, such as message sequence numbers.
DTLS parameters have to be correctly managed by the MAPPER.
This requires special care when deviating from an expected handshake sequence (a.k.a. a happy flow), since each particular parameter management strategy may allow or prohibit a "restarting" handshake to be eventually completed.
In order to facilitate MAPPER construction and parameter management, we have developed a test framework for DTLS, which allows easy definitions of arbitrary protocol packets and efficient experimentation with parameter management strategies.
This test framework is realized by extending TLS-Attacker [39], an existing open source framework for testing TLS implementations, with support for DTLS.
The framework forms the basis for our MAPPER used for DTLS state fuzzing.
The test framework can also be used in its own right to support other fuzzing techniques.Handling the complexity of DTLS state machines.
The above properties of DTLS imply that state machine models of DTLS implementations are significantly more complex than corresponding state machines for TLS and other protocols.
Their complexity is further increased when analyzing the four main key exchange mechanisms together rather than separately, and when exploring settings involving client certificate authentication.
Such complexity in the models creates problems both for the model learning algorithm and for the interpretation of resulting models.
We ameliorate and avoid some of the complexity in two ways: 1) Our test harness does not employ reordering and fragmentation, and hence this is not part of our learned models.
2) We adapt the MAPPER so as to enable handshakes to "restart", which has the additional side-effect of decreasing the size of the learned models, since successful restarts typically show up as back-transitions to regular handshake states.
Obtaining models for a wide range of implementations and configurations.
We have applied our platform to thirteen implementations of ten distinct vendors (Section 6).
Besides covering a wide spectrum of DTLS implementations, ranging from mature, general-purpose libraries to implementations designed for IoT or WebRTC, we mention that some of them are DTLS libraries without a TLS component, on which state fuzzing has never been applied before.For each implementation we examine many, often all, combinations of supported key exchange and client certificate authentication configurations.
This ensures that state fuzzing does not miss bugs that are only present in certain configurations.
In fact, this proved important: several of the Java Secure Socket Extension (JSSE) bugs reported in Section 7.4 could only have been discovered with a configuration requiring client certificate authentication.
From models to bugs.
Once models are obtained we proceed to analyze them, looking for unexpected or superfluous states and transitions.
Some of the main findings of our analysis are: (i) A complete client authentication bypass in JSSE, which is the default TLS/DTLS library of the Java Standard Edition Platform.
The bug allows attackers to authenticate themselves to a JSSE server by sending special out-of-order DTLS messages without ever proving to the server that they know the private key for the certificate they transmit.
The bug is especially devastating, since it also affects JSSE's TLS library.
This greatly increases its impact, as JSSE's TLS library is often used to authenticate users with smart cards at web sites or web services.
(ii) A state machine bug in the Scandium framework allowed us to finish a DTLS handshake without sending a ChangeCipherSpec message.
This resulted in the server accepting plaintext messages even if indicated otherwise by the negotiated cryptographic mechanisms.
Note that this bug is similar to the EarlyFinished bug found in the TLS JSSE implementation [13].
(iii) A similar bug was also present in PionDTLS, a Go implementation for WebRTC.
Investigation of this bug led to discovery of a graver issue whereby the PionDTLS server freely processes unencrypted application data once a handshake has been completed.
(iv) Finally, three confirmed functional bugs in TinyDTLS, a lightweight DTLS implementation for IoT devices.
Contributions.
In summary, this work:• Extends TLS-Attacker with DTLS functionality and uses it to implement a protocol state fuzzing platform for DTLS servers.
• Provides Mealy machine models for thirteen DTLS server implementations, including the most commonly used ones, with models exploring most key exchange algorithms and client certificate authentication settings.
• Analyzes the learned models and reports several nonconformance bugs and a number of security vulnerabilities in DTLS implementations.
Some of these vulnerabilities affect also the TLS part of these libraries.Responsible disclosure.
We have reported all issues to the respective projects complying with their security procedures.
The reported security issues were all confirmed by the responsible developers, who implemented proper countermeasures.We provide more details in Section 7.
Outline.
We start by briefly reviewing DTLS, model learning, and the TLS-Attacker framework in Sections 2 to 4.
Subsequently, we present the learning setup we employ (Section 5), the DTLS server implementations we tested and the effort spent on learning state machines for them (Section 6), followed by a detailed analysis of the issues that were found in the various DTLS implementations (Section 7).
Therein, we present state machines for three of these implementations, whilst making the rest available online.
Section 8 reviews related work, and Section 9 ends this paper with some conclusions and directions for further work.
DTLS is an adaptation of TLS [15] for datagram transport layer protocols.
It is currently available in two versions: DTLS 1.0 [35], based on TLS 1.1 [14], and DTLS 1.2, based on TLS 1.2 [15].
Version 1.3 is currently under development.
This work focuses on TLS/DTLS version 1.2.
At a high level, both TLS and DTLS consist of two major building blocks: (1) The Handshake is responsible for negotiating session keys and cryptographic algorithms, and key agreement is either based on public key cryptography (the standard case), or on pre-shared keys.
The set of algorithms to be used is specified in a cipher suite.
(2) The Record Layer splits the received cleartext data stream into DTLS Records.
Handshake messages are also sent as records (typically unencrypted), and after the ChangeCipherSpec message is sent in the handshake, the content of all subsequent records is encrypted using the negotiated session keys-where different keys are used for the two communication directions.The stateless and inherently unreliable datagram transport layer has prompted the designers of DTLS to introduce several changes to the original TLS protocol.
Below, we describe the handshake protocol and Record Layer, and discuss the changes introduced which are relevant to our paper.
However, we remark that more differences exist [29,36].
ChangeCipherSpec {Finished} Handshake protocol.
Figure 1 illustrates the DTLS handshake.
The client initiates communication by sending ClientHello, which includes the highest supported DTLS version number, a random nonce, the cipher suites supported by the client, and optional extensions.
In DTLS, the server responds with a HelloVerifyRequest message, which contains a stateless cookie.
This message prompts the client to resend the ClientHello message, which then includes the stateless cookie, and attempts to prevent Denial-of-Service attacks [36].
The server responds with the following messages: ServerHello contains the server's DTLS version, the cipher suite chosen by the server, a second random nonce, and optional extensions.
Certificate carries the server's certificate, which contains the server's public key.
In ServerKeyExchange the server sends an ephemeral public key which is signed with the private key for the server's certificate.
This signature also covers both nonces.
CertificateRequest asks the client to authenticate to the server.
This message is optional, and only used when the server is configured to authenticate clients via certificates.
ServerHelloDone marks that no other messages are forthcoming.The client responds with a list of messages: Certificate, ClientKeyExchange, CertificateVerify, ChangeCipherSpec, and Finished.
The Certificate and CertificateVerify messages are optional and only transmitted when the server requests client authentication.
They contain, respectively, a client certificate and a signature computed over all previous messages with the client's long term private key.
The client sends its public key share in the ClientKeyExchange message.
Both parties then use the exchanged information to derive symmetric keys that are used in the rest of the protocol.
The client sends ChangeCipherSpec to indicate that it will use the negotiated keys from now in the Record Layer.
Finally, it sends Finished encrypted with the new keys, which contains an HMAC over the previous handshake messages.
The server responds with its own ChangeCipherSpec and Finished messages.
Thereafter, both client and server can exchange authenticated and encrypted application data.Several DTLS handshakes can be performed within one DTLS connection.
Performing a subsequent handshake allows the client and server to renew the cryptographic key material.
This process is also called renegotiation.UDP datagrams are often limited to 1500 bytes [36].
Since handshake messages can become longer than the datagram size, a fragmentation concept has been introduced in DTLS.
This allows the implementation to split a handshake message into several fragments and send it over the wire in distinct records so that every record respects the maximum datagram size.
To support this, new fields have been introduced in the handshake messages: message sequence, fragment offset, and fragment length.
Message sequence indicates the position of the message within the handshake and is also used in a retransmission mechanism.Record Layer.
All messages in DTLS are wrapped in socalled records.
During the first DTLS handshake, the Record Layer operates in epoch 0.
This epoch number is included in the header of the DTLS record.
If cryptographic keys have been negotiated and activated by sending a ChangeCipherSpec, the Record Layer increases the epoch number to 1 which indicates that the contents of the actual record are encrypted.
Since the handshake may be repeated several times (renegotiation), the epoch number may also be increased further.While TLS has implicit sequence numbers, DTLS has explicit sequence numbers.
This is required since the protocol does not guarantee message arrival and therefore cannot guarantee that the implicit counters are synchronized.
At the start of each epoch, sequence numbers are reset to 0, and for each new record the sequence number is increased.
Note that re-sending a record due to the loss of a UDP packet still increases the sequence number.
Our state fuzzing framework infers a model of a protocol implementation in the form of a Mealy machine, which describes how the implementation responds to sequences of well-formed messages.
Mealy machines are finite state automata with finite alphabets of input and output symbols.
They are widely used to model the behavior of protocol entities (e.g., [10,25]).
Starting from an initial state, they process one input symbol at a time.
Each input symbol triggers the generation of an output symbol and brings the machine to a new state.To infer a Mealy machine model of an implementation, we use model learning.
An analyzed implementation is referred to as the system under test (SUT).
Model learning is an automated black-box technique which a priori needs to know only the input and output alphabets of the SUT.
The most well-known model learning algorithm is Angluin's L * algorithm [3], which has been refined into more efficient versions, such as the TTT algorithm [22] which is the one we use.
These algorithms assume that the SUT exhibits deterministic behavior, and produce a deterministic Mealy machine.Model learning algorithms operate in two alternating phases: hypothesis construction and hypothesis validation.
During hypothesis construction, selected sequences of input symbols are sent to the SUT, observing which sequences of output symbols are generated in response.
The selection of input sequences depends on the observed responses to previous sequences.
When certain convergence criteria are satisfied, the learning algorithm constructs a hypothesis, which is a minimal deterministic Mealy machine that is consistent with the observations recorded so far.
This means that for input sequences that have been sent to the SUT, the hypothesis produces the same output as the one observed from the SUT.
For other input sequences, the hypothesis predicts an output by extrapolating from the recorded observations.
To validate that these predictions agree with the behavior of the SUT, learning then moves to the validation phase, in which the SUT is subject to a conformance testing algorithm which aims to validate that the behavior of the SUT agrees with the hypothesis.
If conformance testing finds a counterexample, i.e., an input sequence on which the SUT and the hypothesis disagree, the hypothesis construction phase is reentered in order to build a more refined hypothesis which also takes the discovered counterexample into account.
If no counterexample is found, learning terminates and returns the current hypothesis.
This is not an absolute guarantee that the SUT conforms to the hypothesis, although many conformance testing algorithms provide such guarantees under some technical assumptions.
If the cycle of hypothesis construction and validation does not terminate, this indicates that the behavior of the SUT cannot be captured by a finite Mealy machine whose size and complexity is within reach of the employed learning algorithm.Model learning algorithms work in practice with finite input alphabets of modest sizes.
In order to learn realistic SUTs, the learning setup is extended with a so-called MAPPER, which acts as a test harness that transforms input symbols from the finite alphabet known to the learning algorithm to actual protocol messages sent to the SUT, as illustrated in Fig. 2.
Typically, the input alphabet consists of different types of messages, often refined to represent interesting variations, e.g., concerning the key exchange algorithm.
The MAPPER transforms each such message to an SUT message by supplying message parameters, performing cryptographic operations, etc.
Conversely, the MAPPER translates output from the SUT into the alphabet of output symbols known to the learning algorithm.
The MAPPER also maintains state that is hidden from the learning algorithm but needed for supplying message parameters; this can include sequence numbers, agreed encryption keys, etc.
The choice of input alphabet and the design of the MAPPER require domain specific knowledge about the tested protocol.
Once the mapper has been implemented, model learning proceeds fully automatically.
The Transport Layer Security (TLS) protocol is one of the most important cryptographic protocols used on the Internet.
Due to its importance and widespread deployment, TLS and its various attacks [2,4,5,7,13,30,43] have been under scrutiny by security researchers.
As a result, by now, there exist several frameworks [6,24,31,39] for the evaluation of TLS libraries.
In contrast, DTLS has been largely overlooked in these frameworks or considered out of scope.
Instead of starting from scratch, we have decided to create a framework for testing DTLS based on the newest version of TLS-Attacker [39].
TLS-Attacker is an open-source, flexible Java-based TLS analysis framework that allows its users to create and modify TLS protocol flows as well as the structure of the included TLS messages.
The user is then able to test and analyze the behavior of an implementation, and create attacks and tools with the custom TLS stack of TLS-Attacker as a software library.
TLS-Attacker has been integrated in the build process of several TLS libraries [8,27] to increase their test coverage.TLS-Attacker employs solely the low-level cryptography provided by Java, and implements the TLS protocol itself.
Its main functionality relies on the concept of workflow traces which allow to define arbitrary protocol flows.
Every TLS protocol flow can be represented by a sequence of Send and Receive actions.
The developer can construct a workflow trace in Java or in XML.
Once TLS-Attacker receives a workflow trace, it attempts to execute the predefined TLS messages, and records the behavior of the tested TLS peer.
A Java example with an ECDHE-RSA key exchange is shown below:WorkflowTrace flow = new WorkflowTrace(); trace.addTlsActions(new TlsAction[]{ new SendAction(conn, new ClientHelloMessage()), new ReceiveAction(conn, new ServerHelloMessage()), new ReceiveAction(conn, new CertificateMessage()), new ReceiveAction(conn, new ECDHEServerKeyExchangeMessage()), new ReceiveAction(conn, new ServerHelloDoneMessage()), new SendAction(conn, new ECDHClientKeyExchangeMessage()), new SendAction(conn, new ChangeCipherSpecMessage()), new SendAction(conn, new Finished()), new ReceiveAction(conn, new ChangeCipherSpecMessage()), new ReceiveAction(conn, new Finished()) });Notice how messages in the above flow are described at a high level.
To execute flows, TLS-Attacker generates valid packets for messages, and parses messages from packet responses.
It does this by maintaining a context, which it updates as new messages are sent and received.
The context encompasses stateful information relevant to a TLS connection such as stored random nonces, agreed upon algorithms, and supported cipher suites.
Using this information, TLS-Attacker can generate valid or semi-valid messages, encrypt them using the negotiated cipher suite, and send them to a peer.All the above properties make TLS-Attacker ideal for generating valid packets from message names, which in our case are the symbols of the input alphabet.
Our DTLS testing framework extends TLS-Attacker with support for DTLS 1.0 and DTLS 1.2.
This extension allows TLSAttacker to generate, send and receive DTLS packets and, more broadly, to execute valid and invalid DTLS flows.
Our implementation involved several changes, among which we mention: i) added support for DTLS handshake message fragmentation; ii) a new field to the ClientHello message for storing a server cookie; iii) new fields to the TLS context, one for storing the cookie received, others for keeping track of the record epoch and message sequence number (how these fields are updated is explained in Section 5.2); and iv) new options for retransmission and fragmentation handling.
The learning setup 1 comprises three components: the LEARNER, the MAPPER and the SUT; cf. Fig. 2.
The SUT is a DTLS server implementation, though our setup can be easily adapted to support clients.
The LEARNER generates inputs from a finite alphabet of input symbols.
The MAPPER transforms these inputs into full DTLS records and sends them over a datagram connection to the SUT.
The MAPPER then captures the SUT's reply, translates it to symbols in the alphabet of output symbols, and delivers them back to the LEARNER.
The LEARNER finally uses the information obtained from the exchanged sequences of input and output symbols to generate a Mealy machine, as described in Section 3.
The LEARNER is implemented using LearnLib [23], a Java library implementing algorithms for learning automata and Mealy machines.
The library also provides state-of-the art Table 1: Symbols used in learning and their shorthands.
We list only the output symbols which are mentioned in the paper.
ShorthandClientHello(T) CH(T) T ∈ {DH, ECDH, RSA, PSK} CertificateRequest CertReq ClientKeyExchange(T) CKE(T) T ∈ {DH, ECDH, RSA, PSK} CertificateVerify CertVer EmptyCertificate Cert(empty) Certificate(T) Cert(t) T ∈ {RSA, ECDSA} t ∈ {RSA, EC} ChangeCipherSpec CCS Application App Alert(CloseNotify) A(CN) Alert(UnexpectedMessage) A(UM) Alert(BadCertificate) A(BC) Alert(DecodeError) A(DE) Alert(DecryptError) A(DYE) Alert(InternalError) A(IE) HelloVerifyRequest HVR ServerHello SH ServerHelloDone SHD ServerKeyExchange(T) SKE(T) T ∈ {DH, ECDH, PSK} Finished F NoResp - Disabled Disabled Unknown Message UM input alphabet output alphabetconformance testing algorithms, which are used by the learning algorithm for hypothesis validation.
The learning algorithm chosen is TTT [22], a state-of-the-art algorithm that requires fewer test inputs compared to other algorithms [21].
For conformance testing, we use Wp [11] and a variation of it, Wp-Random [20].
Table 1 displays the alphabets of input and output symbols, as well as the shorthands that we use to make their representation more compact.
The input alphabet includes in abstract form all client messages introduced in Section 2.
Additionally, it includes Application for sending a simple application message, and two common alert messages, Alert(CloseNotify) and Alert(UnexpectedMessage).
(Interpretations for the alerts can be found in the TLS 1.2 specification [15, p. 31].)
Finally, Certificate, EmptyCertificate, and CertificateVerify are included for sending certificate-related messages.
Certificate contains a single valid certificate, and is parameterized by the public key signing algorithm.
EmptyCertificate denotes sending a certificate message with an empty list of certificates.The output alphabet includes abstractions for each different message the SUT responds with, similarly to the input alphabet.
It also includes three special outputs: NoResp, when the SUT does not respond; Disabled, when the SUT process is no longer running; and Unknown, when the SUT responds with a message which cannot be decrypted by the MAPPER.
This happens, for example, if the MAPPER has replaced the keys necessary to decrypt the output by a new set of keys.
The MAPPER uses our DTLS testing framework to translate between LEARNER inputs/outputs and actual DTLS messages.
Behaviorally, the MAPPER operates like a DTLS client, with control flow deferred to the LEARNER.
In order to reduce the learning effort, we do not subject the SUT to message reordering or fragmentation.
Hence, the MAPPER is configured to send each handshake message in one single DTLS fragment.To correctly supply and check DTLS-specific fields in messages, the MAPPER maintains the state of the interaction in a context, which it uses to generate and parse messages.
Our DTLS testing framework already maintains such a context for executing protocol flows.
Hence, we let our MAPPER use this context, with a few adaptations to support efficient learning.
Key components of this context are cookie, cipherState and digest, as well as nextSendMsgSeq and nextRecvMsgSeq, for the next message sequence number to be sent and received, respectively.
Each message sent is equipped with the value of nextMsgSeqSent, which is then incremented.
nextRecvMsgSeq is assigned the sequence number of each message received, provided it is the next expected one.
The MAPPER also maintains analogous state variables for record sequence numbers, as well as numbers of epochs that are incremented whenever a ChangeCipherSpec is sent.
These variables are also used to assemble fragments into messages and detect retransmissions.
Retransmissions here refer to messages whose message sequence number or epoch are smaller than those expected.The variable cookie, initially set to empty, retains the value of the cookie field in the most recent HelloVerifyRequest message received from the server, and is used when sending subsequent ClientHello messages.
The variable cipherState stores the next symmetric keys to be used for decrypting/encrypting messages.
To be put in use, a cipherState first has to be deployed.
The cipherState deployed initially is set to null (no encryption/decryption).
On each ClientKeyExchange sent, cipherState is updated using information from an earlier ClientHello-ServerHello exchange.
On each ChangeCipherSpec sent, cipherState is deployed.
This implies that the MAPPER will only start encrypting/decrypting once ClientHello and ServerHello are exchanged, and a ClientKeyExchange and a ChangeCipherSpec have been issued.
Prior to these actions, messages are sent in plaintext.The variable digest stores a buffer of all handshake messages sent so far, i.e., each handshake message that is sent or received is also appended to digest.
A hash over this variable is included in every Finished message sent, to be verified by the server.
The variable digest is cleared after each Finished, and also before sending ClientHello.
This strategy for resetting digest enables handshakes to "restart in the middle", by ensuring that hashes are computed over exactly the messages in the most recent current handshake.
After experimenting with different strategies for resetting digest, we found that this strategy allows handshakes that restart to complete, whereas other strategies do not.
It also produces smaller learned models, since successful restarts typically show up as backtransitions to regular handshake states.
As an example, for TinyDTLS using a PSK configuration, the number of states in the learned model was reduced from 36 if digest was not reset, to 22 if it was.
As mentioned in Section 3, the learning algorithm employed works under the assumption that the SUT exhibits deterministic behavior, i.e., the output generated depends uniquely on the supplied input sequence.
During learning experiments, however, timing effects occasionally manifest as non-determinism to the time-agnostic LEARNER.
Below, we describe our strategies to remedy this problem.One cause for timing-induced non-determinism is the LEARNER sending the first input too early, before the SUT has fully started, or the MAPPER determining prematurely that the SUT does not respond.
We address this by tailoring, for each SUT, the start and response timeouts.
These are, respectively, the delay before the first input is sent (allowing the SUT to initialize), and the time the MAPPER waits for each response before concluding a timeout.
In order to reduce learning time, we adjust the response timeout for certain messages, particularly ClientHello and Finished, to which the SUT could take longer to respond.
Finally, in order to optimize the start timeout for the slower JSSE and Scandium implementations, we wrap around the SUT a program which preloads key material, among other things.
This key material is then reused rather than reloaded for each new sequence of inputs.
Once the server is ready to receive packets, the wrapper program notifies the LEARNER of the port number at which the server is listening.
The LEARNER can then immediately start sending inputs, rather than having to wait for a predefined period.Another cause for non-determinism is timeout-triggered retransmissions by the SUT.
To address this, we set the retransmission timeout of the SUT to a high value.
For some SUTs, this is a configurable parameter; for others we had to alter the source code.
Corresponding patches are provided on the learning setup's website for reproducibility.Even with the above strategies, an SUT would sometimes produce alternative outputs due to spurious timing effects.
In order to detect such cases, we store SUT's responses to queries in a cache during the hypothesis construction phase, and confirm each counterexample produced by hypothesis validation before delivering it to the LEARNER.
When detecting a case of differing responses to the same input, we rerun the sequence until at least 80% of the responses are the same; this always happened within a small number of retrials.
An experiment configuration comprises the implementation, the key exchange algorithms and client authentication setting based on which we form the input alphabet, and whether messages with retransmissions were discarded.
In total, we analyzed thirteen different implementations.
This includes well-known TLS implementations like OpenSSL, GnuTLS, MbedTLS, JSSE, WolfSSL, and NSS, which also support DTLS.
For JSSE we analyzed the Sun JSSE provider of Java 9 and 12.
Furthermore, we analyzed PionDTLS, a Go implementation of DTLS 1.2 for WebRTC.
The remaining implementations are IoT-specific and support only DTLS.
Scandium is the DTLS implementation which is part of Eclipse's Java CoAP implementation.
The two TinyDTLS variants are lightweight implementations specifically designed for IoT devices.
TinyDTLS for Contiki-NG branched out from that in Eclipse's IoT suite, and has been developed independently ever since.
We refer to Eclipse's variant as TinyDTLS E , and to Contiki-NG's as TinyDTLS C .
When referring to both, we simply use TinyDTLS.
For GnuTLS and Scandium, we analyzed two versions; the later version contains bug fixes uncovered in the earlier one.
As with TinyDTLS, we omit versions when referring to both.To avoid having to write our own DTLS servers, we use utilities to configure and launch DTLS servers that are provided by the developers where possible.
For example, for OpenSSL, we use the openssl s _ server utility, for GnuTLS we use gnutls-serv, etc.
There are three exceptions (PionDTLS, Scandium, and JSSE) for which we wrote our own DTLS applications 2 as either there were no standard utilities available or the available ones did not provide the desired functionality.
For every implementation, Table 2 displays the name, version, utility, supported key exchange algorithms and client certificate authentication configurations, and a URL.
We use commit identifiers as versions for both TinyDTLS variants, PionDTLS, and Scandium.
The two commits for Scandium belong to the development version 2.0.0 and shall, more suggestively be referred to as Scandium old and Scandium new .
Note that client certificate authentication is relevant for DH, ECDH and RSA, but not for PSK whose handshake does not incorporate certificate messages [17, p. 4].
The input alphabet, described in Table 1, includes inputs necessary to perform handshakes using every key exchange algorithm supported, two alerts, and one application message.
Whenever certificates can be part of the key exchange algorithm, they are also included in the alphabet.
The SUT is configured to use client certificates whenever these are supported.
Therein we explore three configurations: (i) required: In some experiments, we had to remove inputs from the input alphabet and/or limit the set of explored configurations.
For PionDTLS, NSS and WolfSSL, the reason was that the server program or library does not support certain combinations of key exchange algorithms and certificate configurations.
Similarly, PionDTLS's library does not allow PSK and ECDH cipher suites to be used together, NSS's utility does not support certificate authentication, whilst WolfSSL's utility could not be configured to simultaneously support all key exchange algorithms.
In cases where learned models were large (for TinyDTLS, Scandium, and JSSE) or when response time was slow (for Scandium and JSSE), we generated models separately for each key exchange algorithm, in order to keep the learning time reasonable.
In our experiments, model learning converged on all analyzed implementations, except for JSSE (all configurations), WolfSSL with disabled client authentication, and Scandium using ECDH alphabets.
For these configurations, the last hypothesis models produced by learning are not complete, but still very informative as bases for analysis.Statistics from the learning experiments for which model learning converged are shown in Table 3.
These include the number of states, number of tests, and learning time.
Our analysis focuses on these three quantities.
Number of states.
First, note that the number of states in all models is a two-digit number.
This means that the models we learn for these DTLS implementations are non-trivial.
In particular, we remark that the number of states is considerably larger than those reported for TLS implementations, with our DTLS models averaging 25 states while the TLS models are averaging 9 states [13].
This confirms our expectations about the increased complexity of DTLS, and the complexity that learning with several cipher suites adds to most models.Second, the number of states is, unsurprisingly, affected by the alphabet configuration.
PSK configurations generally lead to smaller models than ECDH ones.
(This is expected, since the handshake sequence is longer unless client certificate authentication is disabled.)
However, combining multiple cipher suites in one alphabet does not necessarily result in much larger models.
For example, OpenSSL or MbedTLS generate relatively small models (19 and 17 states respectively, when authentication is required) even with four cipher suites.
This can be explained by the fact that in mature implementations handshakes for different key exchange algorithms/authentication configurations tend to share states.
(For example, in Fig. 3 note how all handshakes finish in states 5 and 6.)
Third, as we will soon see, there appears to be a strong correlation between the number of states and bugs.
The most consequential bugs were found in implementations generating the largest models (JSSE, PionDTLS, Scandium old , TinyDTLS).
Hence, reducing state machine size is a viable strategy for improving software correctness.
Number of tests.
The number of tests was between 21 000 and 50 000 for most implementations, with only PionDTLS and GnuTLS 3.6.7 requiring considerably more.
Implementations which resulted in the largest models also required the most tests.
PionDTLS leads in terms of model size (66 states) and number of tests (113 508).
The one exception to Table 3: Results of learning experiments.
The "Timeout" column refers to the response timeout, to which * is appended in case the timeout was adjusted based on the input.
The "Alphabet Used" column describes the type of cipher suites used, if certificate inputs were included (CERT), if authentication was disabled (NONE), optional (OPT) or required (REQ), and if retransmissions were discarded (DISC).
Implementation GnuTLS is designed to provide minimally informative output to inputs that deviate from the happy flow: in most cases, the implementation simply discards such inputs and stays silent (this can be seen in e.g., Fig. 3).
As a consequence, the input sequence which uniquely identifies a state can be very hard to find, and can even be too long to be discovered during learning or conformance testing.Learning time.
Model learning experiments completed within one day on average, except for four implementations.
Among these, PionDTLS and Scandium take considerably longer due to large models (66 states for PionDTLS).
Scandium and GnuTLS take longer due to high response timeout values, motivated by very long processing times for messages such as ClientHello (400 and 200 msecs respectively).
This highlights the importance of message-specific timeouts, as suggested in Section 5.3.
This section provides an analysis of the models against the specification.
We first give an overview of a DTLS state machine, using the model learned for GnuTLS as an example.
We explain the strategies employed to identify non-compliant behaviors using the learned models.
We then outline the noncompliant behaviors observed in the tested libraries.
Finally, we present library-specific findings and vulnerabilities, including the client authentication bypass in JSSE.
Displaying models is challenging due to the large number of inputs and states.
We therefore prune the models via the following strategies.
We first use the Other input as replacement for inputs not captured in a visible transition which lead to the same state and output.
Inputs and outputs are then replaced by their corresponding shorthands shown in Figure 3 shows a model generated for the GnuTLS 3.6.7 library and can be interpreted as follows.
The server starts from the initial state, which is always state 0 on the state machine.
On receiving ClientHello(PSK) it generates HelloVerifyRequest and transitions to state 2.
In response to a second ClientHello(PSK), it generates the messages ServerHello and ServerHelloDone and transitions to state 3.
Continuing the PSK handshake flow, on receiving ClientKeyExchange(PSK), ChangeCipherSpec and Finished, the server generates NoResp (i.e., nothing) for the first two messages, and ChangeCipherSpec and Finished for the third.
In this interaction, the server traverses the states 4 and 5, ending in 6.
The GnuTLS server was configured to use PSK-and RSAbased cipher suites.
This is reflected in the model's input alphabet, which includes ClientHello and ClientKeyExchange for both PSK and RSA.
Client certificate authentication was set to optional.
In this situation, the server makes a client certificate request, as indicated by the CertReq label on the edge from state 2 to state 7 in Fig. 3.
The server does not require client certificates, hence handshakes can be completed even if the client chooses to send an EmptyCertificate by following states 0, 2, 7, 11, 4, 5 and 6; or no certificate at all by following states 0, 2, 7, 4, 5 and 6.
Finally, if the client authenticates with a Certificate message, the handshake traverses states 0, 2, 7, 9, 10, 4, 5 and 6.
Note that client certificate authentication is implicitly disabled for cipher suites which do not support it, such as PSK-based ones.Besides states traversed by handshake flows, the model contains three other states: states 1, 8 and 12.
State 1 is a sink state, which is a state the model cannot transition out of.
States 8 and 12 are superfluous states, since they are not necessary for implementation correctness.
They are a byproduct of the implementation allowing handshake restarts, which are possible from these states by transitions to state 2.
To identify potentially vulnerable behaviors using learned models, we employ the following strategies.First, we inspect models for irregular handshake flows (irregular handshakes for short).
These are flows that lead to handshake completion, indicated by a successfully transmitted Finished from the server, but may omit, repeat or change the order of handshake messages, relative to regular flows permitted by the specification.
To aid analysis of larger models (such as those of JSSE or PionDTLS) we developed a script to automatically remove states from which a handshake cannot be completed (i.e., it is no longer possible to receive a Finished from the server).
On the reduced models, handshake-completing flows can be identified much more easily; this is showcased by Figs. 4 and 5.
Using this approach, we uncovered bugs like early Finished, wherein a handshake is completed by omitting the ChangeCipherSpec message.
We refer to Sections 7.4 to 7.6 for descriptions of such bugs for JSSE, Scandium and PionDTLS.
Note that the script used to reduce models comes packaged with our learning setup.Second, we look for outputs from the server which do not conform to the specification.
Of particular interest are irregular ServerHello responses, which are not part of irregular handshakes (otherwise the flows would have been detected and analyzed by our first strategy).
We investigate whether a handshake may be completed using these responses.
To that end, we probe the SUT's reaction after such responses to manually-crafted messages (typically ClientKeyExchange, ChangeCipherSpec and Finished), whose message sequence/epoch numbers differ from what our MAPPER generates.
Doing so, we were able to complete handshakes in TinyDTLS using invalid epoch numbers; see Section 7.8.
Also of interest are Alert outputs, as they shed light on how the system processes unexpected inputs.
For example, Alert(DecryptError) suggests the SUT is not able to decrypt a message.
Hence, Alert(DecryptError) is only expected as a response to an encrypted message, and not to an unencrypted message, as was Finally, we inspect the code exercised by irregular behaviors identified by the first two strategies in order to assess whether they can result in further flaws.
Such flaws can be more severe than the initial irregularity suggests.
As an example, the non-conforming Alert(DecryptError) in TinyDTLS led us to discover loss of reliability in the face of reordering.
Investigation can also reveal bugs not directly related to the behavior inspected, which, however, exercise roughly the same portion of code.
Such was the case for PionDTLS, where investigating an early Finished bug led to the discovery of premature processing of application data; see Section 7.6.
Several conforming and non-conforming behavior patterns emerged while analyzing the learned models.
Table 4 summarizes the irregular behaviors and the affected implementations.
Handshake with invalid message_seq numbers.
Many DTLS server implementations allow for creating new associations even when having an already established connection [36, Section 4.2.8].
This process involves performing a new ClientHello-ServerHello exchange in the middle of an already started or finished handshake, and results in agreeing on a new cipher suite and key material.
The motivation behind this behavior is to support clients that want to re-establish a new connection after loosing one (e.g., after a reboot).
message_seq number by one.
3 In five of the tested implementations, it was possible to start a DTLS handshake with a higher message_seq number.
It was also possible to identify these implementations from the learned models.
For example, in the GnuTLS model (Fig. 3), we were able to detect such an invalid behavior by following the transitions looping back to state 2.
Non-conforming cookie computation.
Upon receiving a ClientHello message, the server computes a stateless cookie and sends it via HelloVerifyRequest.
The server expects the cookie to be replayed in the subsequent ClientHello message.
According to the specification, the replayed ClientHello message must contain the same parameters as the first one (e.g., supported cipher suites) [36, Section 4.2.1].
For this purpose, the server should use the initial ClientHello parameters to compute the cookie value.In our evaluation, we could observe four implementations incorrectly computing the cookie value, resulting in incorrect validation of replayed ClientHello messages.
Such a handshake is also captured in Fig. 3, where an RSA handshake can be completed even if the first message was ClientHello(PSK).
An exceptional case is NSS, which omits the cookie exchange step altogether, in discord with the specification's recommendation.Handshake with invalid order of messages.
The most con-sequential divergent behaviors are handshakes where invalid message sequences lead to handshake completion.
These behaviors may have severe security implications.
We found that JSSE, PionDTLS, and Scandium old do not correctly verify the DTLS handshake message sequence in their internal state machines.
Below we discuss these bugs and their implications.
Figure 4 depicts the hypothesis model generated for JSSE 12.0.2 using one RSA-based cipher suite after two days of learning.
The model was obtained by erasing all states from which a handshake could no longer be completed.
The JSSE server was configured to require client authentication.
The model depicts a correctly completed handshake, which is marked with blue edges and follows states 0, 2, 4, 11, 12, 3, 9, and 10.
This flow includes Certificate and CertificateVerify messages correctly sent by the client to authenticate to the server.
However, even though the server required client authentication, we were able to complete DTLS handshakes without sending Certificate or CertificateVerify messages.
The invalid handshakes are captured in red and allow a client to bypass client authentication.
Our analysis revealed that versions 11, 12 and 13 of Oracle and OpenJDK Java are affected for all key exchange algorithms.
Previous versions are not affected by this issue.
Unauthenticated ClientKeyExchange.
We start the description of JSSE vulnerabilities with a slightly modified happy flow, which follows states 0, 2, 4, 11, 5, 3, 9 and 10, and traver-ses dotted red edges on the model.
In this flow, the client sends a CertificateVerify message before the ClientKeyExchange.
This implies that the ClientKeyExchange message is not authenticated with the client certificate.Being able to finalize such a DTLS handshake does not directly result in a critical vulnerability.
If the client behaves correctly and sends messages in the correct order, an attacker cannot modify the ClientKeyExchange message or the message order because all the handshake messages are protected by the Finished message.
Still, this bug shows a first invalid behavior, and scratches on the surface of other invalid ones.
Certificate-less client authentication.
The second vulnerability is marked with dashed-dotted red edges in Fig. 4.
The DTLS handshake starts with four ordinary flights of messages.
In the fourth flight, the server requests client authentication by sending a CertificateRequest message.
However, the client ignores this message and continues the handshake with ClientKeyExchange, ChangeCipherSpec, and Finished messages, without sending Certificate and CertificateVerify.
The server responds to the last message with ChangeCipherSpec and Finished, thus completing handshake.
This allows the client to completely bypass client authentication and proceed with sending application data.Note that the handshake process remains completely transparent to the server, as long as the server does not try to manually inspect the certificate of the peer after completing the handshake.
Since the client does not send any certificate, the certificate in the internal JSSE context is null.
If the server attempts to evaluate the certificate data (e.g., to access the subject name or certificate issuer fields), this will result in an SSLPeerUnverifiedException and most likely interrupt the authentication process.
The next finding bypasses this constraint as well.
CertificateVerify-less client authentications.
The third vulnerability follows red dashed edges in Fig. 4 and partially relies on the behavior described above.
It allows an attacker to authenticate as an arbitrary user without the possession of the private key.
The only prerequisite is that the attacker is in possession of a valid client certificate.
This requirement is in most cases trivially achieved as certificates are usually not considered private and can be found in public repositories or provided in frameworks like Certificate Transparency.As already visualized on the model, after receiving the second server message flight, the attacker can send a ClientKeyExchange message, thus transitioning from 4 to 7.
Instead of directly sending a ChangeCipherSpec message, we continue with an out-of-order Certificate message.
Finally, we send ChangeCipherSpec and Finished.
The server then responds with ChangeCipherSpec and Finished, after which it can accept an Application message encrypted under the established keys.
Thus, the attacker is able to finalize the DTLS handshake without CertificateVerify, and thus without being in possession of the certificate's private key.
The crucial difference in comparison to the previous vulnerability is that the server accepts the certificate, and is able to correctly process its contents.
Therefore, no SSLPeerUnverifiedException is thrown, and the application has no possibility to detect the invalid client behavior.
Attack rationale and state machine analysis.
To understand the above described behaviors, we analyzed the JSSE state machine implementation.
The reason behind the vulnerabilities is not intuitive.
In general, it can be summarized in the following processing properties.
First, the server does not validate a proper message order.
From the first bug, we can conclude that specific handshake messages can be sent in a different order (e.g., ClientKeyExchange and CertificateVerify).
Second, the server only partially validates the correctness of received messages.
For example, it validates whether the handshake contains a ClientKeyExchange message, or it does not accept further ClientHello messages after a ServerHelloDone message has been sent.
Third, and most importantly, the server does not verify the presence of critical messages after the handshake has been finalized.
In particular, it does not check whether Certificate and CertificateVerify messages were received after a CertificateRequest has been sent.Our code analysis revealed that the JSSE implementation always waits for at least ClientKeyExchange, ChangeCipherSpec, and Finished messages.
Messages arriving outof-order can be cached.
This explains why we could observe so many different paths leading to handshake completion in the learned model.
Interestingly, the bugs affect the TLS implementation in a similar way as well.
Omitting the Certificate and CertificateVerify messages also authenticates the client.
Additionally, just removing the CertificateVerify message (while leaving the Certificate message) also authenticates the client.
We were able to reproduce the issues with Apache Tomcat 9.0.22, which was configured with JSSE and required client authentication.
4 We reported the vulnerabilities to the Oracle security team.
They were assigned CVE-2020-2655 and patched with the Oracle critical patch update in January 2020.
Scandium old produced some of the largest models.
This is reflective of the fact that the implementation did not use an internal state machine to validate the sequence of handshake messages.
Consequently, its model captures handshakes with invalid sequences of messages.
Reporting our findings prompted Scandium developers to update the implementation with state machine validation (Scandium new ).
This update fixed all the Scandium bugs reported in this paper.
The update not only helped to simplify the learned model (for a PSK configuration reducing the size from 16 to 13), but also enabled convergence for ECDH configurations resulting in similarly small models.
Models for the original and updated versions are available online.
Below, we present findings for the original version.
Early Finished.
Scandium allows a handshake to be completed without the client sending a ChangeCipherSpec message.
The server then interprets all the upcoming messages as sent in plaintext.
It still expects a valid Finished message with correct verify_data from the client to complete the handshake.
Therefore, a man-in-the-middle attacker is not able to simply drop ChangeCipherSpec and use a fabricated Finished message to decrypt the traffic.
A valid verify_data would still be required to complete the handshake.
This is not possible to compute without possessing the master secret or exploiting further bugs.
However, this behavior shows fragility of the Scandium state machine.The early Finished message bug is remarkably similar to the bug reported for JSSE 1.8.0_25 [13], and is related to the attack described by Wagner and Schneier [44].
An attacker could exploit this behavior by injecting a backdoor into a library which would force a DTLS client to skip ChangeCipherSpec messages.
The attacker could then observe plaintext connections established with any Scandium server.
Multiple ChangeCipherSpec in a handshake.
Scandium can complete handshakes wherein ChangeCipherSpec is followed by one or more ChangeCipherSpec messages and then Finished.
On each ChangeCipherSpec sent, the MAPPER increments the epoch used in follow-up messages.
Thus, the sent Finished carries an epoch number for which a cipher has not been negotiated.
The fact that Scandium completes handshakes in such a situation further showcases the looseness of its implementation.
Measurable improvements.
After we reported the vulnerabilities to the Scandium developers, they were able to simplify Scandium's state machine significantly.
Scandium new generates at most 17 states, whereas Scandium old generates up to 45 in a more restricted setting.
Early Finished revisited.
PionDTLS exhibits an early Finished message bug which is similar to the one found in Scandium.
Obtained for a server requiring certificate authentication, PionDTLS's model (Fig. 5) captures three handshakes instead of the one expected.
The two additional handshakes are an early Finished handshake and a handshake with a ChangeCipherSpec message preceding CertificateVerify (where the CertificateVerify is sent encrypted).
This latter bug clearly shows that PionDTLS does not correctly validate the ordering of messages.
Processing of unencrypted application data.
During the analysis of the previous bug, we noticed that PionDTLS freely processed unencrypted application data delivered with epoch 0.
This bug has severe consequences by allowing an attacker to inject arbitrary application data at any point once a handshake has been completed.
The bug was promptly fixed once we reported our findings to the developers.
HelloVerifyRequest retransmissions.
PionDTLS occasionally responds to the first ClientHello message with multiple HelloVerifyRequest messages.
This response is marked with HVR+ in Fig. 5.
When investigating this behavior we found that PionDTLS will retransmit HelloVerifyRequest messages until a timeout elapses or it receives the second ClientHello.
RFC 6347 advises against retransmitting HelloVerifyRequest [36, p. 6], as doing so requires the server to keep state, making it susceptible to Denial-of-Service attacks.
The retransmission also enables amplification attacks, wherein an attacker sends ClientHello messages to the server with the IP address of a victim as the source address.
As a result, the server will then send its replies to the spoofed source address, thus flooding the victim with HelloVerifyRequest messages.
In GnuTLS 3.5.19, we detected a bug in the initial state; the implementation treated most messages as if they were ClientHello.
In doing so, the server responded to them with HelloVerifyRequest and it transitioned to the next handshake state.
We reported the bug to the GnuTLS developers who were able to reproduce and fix the issue.
Insecure renegotiation.
After performing a DTLS handshake with a TinyDTLS server, we were able to use the established encrypted connection to perform the next handshake.
This process is also called renegotiation and allows the client to establish new keys for the given connection.
However, it can only be safely used if the ClientHello message contains a renegotiation indication extension and the server can process it [34].
Otherwise, the server may be vulnerable to an insecure renegotiation attack [34]; see also CVE-2009-3555.
The ClientHello messages we used did not contain any renegotiation indication extension.
Therefore, every renegotiation attempt should have been rejected by the processing server.
However, this was not the case.
TinyDTLS violated RFC 5746 [34, Sect. 3.2] and was vulnerable to the insecure renegotiation attack.
The real exploitability of this behavior depends on the application using the TinyDTLS library.
Crashes on ChangeCipherSpec.
In addition, we found that in certain states TinyDTLS E crashes on receiving ChangeCipherSpec.
For example, it crashed on receiving this message in the initial state.
The crashing behavior resulted in a reduction of states compared to TinyDTLS C since crashing inputs predictably lead to a single sink state.
The crash was a result of a segmentation fault resulting from a null address read.
This bug is a rediscovery of CVE-2017-7243, which is still unfixed in the master branch of the TinyDTLS E .
From inconsistent alert to unreliable handshake protocol.
By analyzing the learned model, we could observe frequent usage of Alert(DecryptError) messages.
This alert is sent by TinyDTLS whenever it tries to decrypt a record (whether it is actually encrypted or not), and fails to find key material for the epoch in its internal state.
This behavior is in itself rather unproblematic, but TinyDTLS also invalidates the whole connection in such a case.
This can result in connections breaking unnecessarily when the ChangeCipherSpec and Finished messages are received out of order in a regular handshake.
Handshake with invalid epoch numbers.
The model for TinyDTLS C revealed that the server can perform the first two steps of a handshake using ClientHello messages with epoch 1 when no cipher for epoch 0 has yet been negotiated.
Upon further investigation, we were able to complete the handshake by sending ClientKeyExchange, ChangeCipherSpec and Finished having the same epochs as in a normal handshake (which are 0, 0 and 1, respectively).
The handshake is clearly invalid and should not have been possible to complete.
Finished treated as retransmission.
After a successful handshake completion, the OpenSSL server treats retransmitted Finished messages incorrectly.
OpenSSL responds to a newly computed and transmitted Finished message by resending the last flight (ChangeCipherSpec, Finished).
The Finished message received from the server has a different message sequence number and verify_data content.
An adequate response would have been either to discard this message, or to send an alert and possibly terminate the connection.
InternalError alerts.
Alert(InternalError) is sent by OpenSSL in response to unexpected Finished messages.
Internally, OpenSSL is processing the message and trying to compute the verify_data for the Finished message.
However, due to defensive programming, missing parameters in the session context are discovered, the processing of the message is stopped, and an Alert(InternalError) is returned.
An appropriate response should have been an alert indicating the receipt of an out-of-order message.
Alert(UnexpectedMessage) has been designed for such purposes.
We can conclude that in our analysis we observed several repeating code patterns, which led to the bugs and vulnerabilities.
Most importantly, most of the analyzed implementations do not use proper state machines.
While they attempt to verify the handshake protocol flow with simple checks in switch statements, a complete message flow validation is missing.
This was, for example, observed by the analysis of the Scandium implementation, which was too liberal when it comes to the message sequence verification; only other additional checks in the code prevented further security vulnerabilities.
One reason for missing state machines could be the fact the DTLS specification [36] does not give a design for one.
We believe that protocol standards should contain such designs and demand that implementations use them.In the libraries implementing TLS and DTLS, we could observe that the code is re-used in both protocols.
This means that similar vulnerabilities in one protocol implementation can influence the other.
For example, we found the authentication bypass in JSSE by analyzing the DTLS server implementation.
However, our subsequent analysis revealed that the bug is also applicable to TLS.
We expect that similar behaviors will be found in the future.Interestingly, both Scandium and PionDTLS include the same early Finished message bug that was found in JSSE TLS in 2015 [13].
While this again may be attributed to missing state machine implementation, we believe that this bug is closely related to an ambiguity, which is mentioned in [36].
As with TLS, the ChangeCipherSpec message is not technically a handshake message [...].
This creates a potential ambiguity because the order of the ChangeCipherSpec cannot be established unambiguously with respect to the handshake messages in case of message loss.In DTLS up to version 1.2, this ambiguity has to be resolved by hard-coding the expected ChangeCipherSpec message.
In the recent DTLS 1.3 drafts [16], the problem has been resolved by removing ChangeCipherSpec messages entirely.
In this section, we give a brief summary of previous work on analyses of DTLS and on state fuzzing of security protocols.Due to the similarity with TLS, most of the attacks applicable to TLS are potentially applicable to DTLS protocol implementations as well.
This includes attacks like Heartbleed [37], Bleichenbacher's attack [7], or CBC padding oracle attacks [43].
One exception is the attack presented by AlFardan and Paterson in 2012, who adapted padding oracle attacks to DTLS by using novel DTLS side channels [1].
The adaptation exploits subtle timing differences between processing packets with valid and invalid padding, amplified by the processing of subsequent Heartbeat messages.
The attack was applicable to OpenSSL and GnuTLS.
In 2013, the same authors extended their work to a powerful attack breaking both TLS and DTLS -Lucky13 [2].
Van Drueten obtained some preliminary results on analyzing DTLS implementations using protocol state fuzzing, from which this work branched off.
His thesis [42] analyzed OpenSSL and mbedTLS with a limited input alphabet and did not reveal any security vulnerabilities.
De Ruiter and Poll [13] used protocol state fuzzing to analyze TLS implementations and found several security bugs.
In comparison, the models we learn are significantly larger, due to complexity in DTLS introduced by UDP, and our inclusion of several key exchange algorithms and certificate settings.
Also, as stated before, some of the bugs we found are only possible under particular configurations or are specific to DTLS.McMahon Stone et al. [28] extend state learning such that it also captures time behavior and can operate also over an unreliable communication medium.
They then use the extension to analyze implementations of the 802.11 4-Way Handshake in seven Wi-Fi routers.
In dealing with non-determinism, our work employs some of the same strategies, such as checking counterexamples against a cache, or using majority voting.
However, it can use a more efficient learning setup, as it does not have to deal with a lossy medium and resulting timeouts.
Chalupar et al. [9] also had to address non-determinism of the system, though this time it was not introduced by the medium but by the system itself.
In their work, a simple majority voting system was sufficient to address these issues.
We have presented the first protocol state fuzzing framework for DTLS.
As a basis, in particular for constructing a MAPPER, we have developed a test framework for DTLS, based on TLS-Attacker.
The MAPPER and test framework implement DTLS specifics including explicit sequence number, support for cookie management, and epoch numbers.
In this paper, we focused on discovering state machine bugs, triggered by sequences of valid handshake messages.
We did not exercise reordering and fragmentation.
Nevertheless, we used our platform to generate models of thirteen widely used DTLS server implementations, and were able to find critical security vulnerabilities and implementation flaws in them.There are several directions for future work: (i) The analysis can also explore Record Layer functionality such as fragmentation and reordering, by adding a strategy for sending reordered and fragmented records.
Since these functionalities should be handled transparently by the Record Layer, we can directly use our already learned models as specifications.
(ii) Our learned models can be used to support systematic testing with invalid input messages, as is done in protocol fuzzers.
(iii) Our analysis of learned models was performed manually; automation using model checking techniques should be investigated, for example, by following the methodology presented in work for TCP [18] or SSH [19].
We would like to thank Jörg Schwenk, our shepherd Kenneth Paterson, and the anonymous reviewers for many insightful comments.
We also thank Niels van Drueten for his contribution to an initial version of the test framework.The research was established at the Lorentz Center workshop on Systematic Analysis of Security Protocol Implementations.
It was partially funded by the Swedish Foundation for Strategic Research (SSF) through the aSSIsT project, the Swedish Research Council, and the Deutsche Forschungsgemeinschaft (DFG, German Research Foundation) under Germany's Excellence Strategy -EXC 2092 CASA -390781972.
